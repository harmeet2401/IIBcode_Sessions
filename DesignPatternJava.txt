Design patterns in java -------------------- Really important.

Design pattern helps in identify recurring problems and create a solution arround that problem.
1. Design patterns helps in creating a solution arround the problem 
2. This patterns can be re-used to be applied to any project which face this issue. As design pattern is a patterns(kind of  prob recurring)
3. Design pattern make the project structure better.

How to apply design pattern 
1. First check the design pattern from the pattern catalog which can be appled to the problem occuring in the projects 
2. In no pattern is there to solve issue. Document the issue (problem) , create a solution and keep it as a candidate pattern.
3. If the above issue keeps on coming across the projects and is getting resolved by applying above candidate pattern then that candidate pattern will be added to the pattern catalog

Types of Pattern catalog to choose pattern from .
1. GOF pattern catalog : 
	- Creational patterns : which is all related to the creation and instantiation of the class objects
	- Structural patterns : Which is all realted to the class struture.
	- Behaviour patterns : which is all related to the calling heppens or communication between classes.
	
	a. Singleton Pattern : Its a creational pattern which will allow only one object to be created for the  class and shared across all the classes.
			for example : 
					case 1 : in this case singleton pattern will allow only one object of PropertyReader class to be created to save memory.
						Class 1 ----------------------|
													  |
													  PropertyReader class (which has  function to read/write values from the file) <---------------------> file
						class 2 ----------------------|
					Case 2: 
						public static Logger log = LoggerFactory.getLogger(Classname.class)
						
						Above log object singleton will be used by all the classes to log message.
						
			Ques: How to make a singleton design pattern 
			Ans : step sto follow : 
					- Create the constructor private to stop the instantiation from other classes.
					- Then create the private static variable of same class type so that we can instantiate it back .
					- then create a public static method to return the above private static class variable back . Check is added to check if private static attribute is null or not.
					
				a. lazy instantiation : with in the method . to instantiate private static attribute. PREFFERED
				b. eager instantiation : eg : private static DateUtil dateUtil = new DateUtil(); ----- on class level.
										   public static DateUtil getInstance(){
											return dateUtil;
											}
									it means we are returning the variable value only once whic is instantiated once at class level.
				c. Static block instantiation : we can instantiate with in the static block to instantiate the dateUtil variable once.
									static {
									
										 dateUtil = new DateUtil();
										}
				d. Issue 1 : How to make the instantiaton of the private static attribute thread safe is by marking the block of code s static.
				
						synchronized keyword to mark the function thread safe .
						synchronized (DateUtil.class){ ---- block to mark piece of LOC 
						
						}
				e. Issue 2 : serialisation and de-serialisation : Serialization in Java is a way of saving and sending objects as bytes, like a snapshot of their state
					Like we can send the value of a variable and object to a file after serialisation. And then de-serialise it back while reading from the file or the network.
					
					
					- First implement Serialisable interface in the class of which the objects will be serialised and writtern/read to/from the file.
					- ObjectOutputStream(new FileOutputStream(new File(filepath))) is the class we can use to convert/serealize the object and send it as a byte to the file or to the network socket.
					- ObjectInputStream(new FileInputStream(new File(filepath))) is the class we can use to convert/de-serealize the object from the file or the network socket back 

				Issue : In singleton classes while serialisation and de-serialisation an issue occurs that jab ham singleton class ke object ko serialise krte hai ObjectOutputStream class use krke and file mai write krne ke baad usse read krte hai (de-serealize) to who read object same nhi hotta original vale se. Means de-serialisation creates a new instance of the singleton class.
					To resolve the issue we use readResolve() function which will be called by ObjectInputStream while reading and will return the same instance as we created in singleton  class in  getInstance() method. Olaaaaaaaa !
					
				f. Issue 3 : Handle cloneable : For singleton to work 100% we have to take care of the cloneable issue . Means if some class extends our singleton class and wants to clone it then that class should get CloneNotSuportedException().

					- Implements Cloneable interface 
					- Override the Clone() method and throw CloneNotSuportedException().
						olllllllllllllllaaaaa! this issue also resolved.
				
				g. Issue 4 : Reflection problem : Now we know our class is singleton and we can create only one instance . But reflection is the technique using which we can interate through the constructors of the singleton class and change the accessibility to public type by changing the flag and use it to create the new instance.
				Is reflection technique ne singleton pattern ko break krdiya  and allowed user to create new instance easily.
				
						Constructor[] constructors = DataUtil.class.getDeclaredConstructors();
						Loop through the constructors and setAccessibility(true)
						then use that constructor to create new instance 
						booooooooooommmmm hacked.
						
						
				To resolve this issue , we have to use something which doesn't have constructors . So ENUM is one of the feature by java which has no constructors and help in creating the INSTANCE only by enumname.INSTANCE.
				
				As there is no constructors , we can not use reflection technique to loop through the constructors and set the accessibility flag true to start creating new instances.
									
				NOTE : IN NUTSHELL MAKE SURE TO INSTANTIATE THE CLASS TYPE PRIVATE ATTRIBUTE ONLY ONCE AND RETURN IT.
				
				
	b. Factory Design pattrn : Its used to hide the Object creational process. 				
		In nut shell we have to hide the object creation in factory class. its a normal java class with only operations is to instantiate the other class objects.
		
		Order(test class)----
							|
							|
						PizzaStore 
							|
			----------------PizzaFactory(factory class with static method.)
		Pizza(interface)
		|
		|- ChickenPizza
		|
		|- VeggiePizza
		|
		|- CheesePizza
		
		- In abve digram Pizza is the interface which will have three function , PreparePizza , backPizza and Cutpizza. And will have three implementations to define the functions of the interface with appropriate values.
		
		
		- Pizzafactory is the normal java class which will hndle the object instantiation for the Pizza Interface. Which will contains a static method which will instantiate or create the objects and return back. As it is static we won't be needing the object creation for PizzaFactory class. directly do PizzaFactory.staticmethodname()
		
	c. Abstract Factory Design pattern : An abstract factory is the factory of factories . Means To create the object for factory classes we have Abstract factory class which knows how to do it. Now this abstract factory class should also be invoked to create downstream factory class which is done by Producer.
	Its an abstract class with abstract method in it.
	
			ClientClass input ---|
								 |
								 |
							 Producer 
								|
							VehicleAbstartctFactory (Factory of factories)
								|
					  ---------   ------------
					  |						 |
				FourWheelerfactory         TwoWheelerFactory	
				
				
				
				   ---------VehicleDAO(Interface)----
				  |- audiar			                 |- hondaScooty
				  |- audibus					     |- hondaBIke
				
				

			in above diagram it shoes that PizzaFactory and TwoWheelerFactory will be created by an abstractFactory which will be produced by producer.

	d. Template Method deisgn pattern : Its like creating a template method which will be same for all the implementing classes. 
			Example , One interface or an abstract class with three fns (renderdata() , readdata(), processdata()).
				out of above gave defination for the renderdata() function which will act as a template for all the other implementing classes. and other two funcstions to be deifned accordingly in implementing classes.
				
	e. Adapter pattern :  Its like we will use a program between two modules , two apps or two cross platform application to transform the data which is required by the other apps .

		App1 (send XML) --------> Adapter program  --------------> App2(which data to be in json format.)
								transform it in json 
								and feed it to app2
    f. flywight design pattern : Its a structure design pattern .In this design pattern , the main problem which is resolved is creating multiple instances of the objectc again again.
								To overcome that we can use Map<String, Object> map = new HashMap<>(). To cache the object in sthe hash table which is then returned everytime we need to invokve the method of the class for which the object is created.
								Now the string type or the key should be unique so that same copy of the object can be retrived from the cache.
								
							Human (Interface)
							beath(){}
							eats()
							weight()
							

					Girl 				Boy (implements HUman interface )

			Note : Factory method along with map or hashmap act as flyweight design pattern . Which is used to overcome the issue of large number of objects creation which eats up the memory
	g. Command design pattern : 
		The command pattern encapsulates a request as an object, thereby letting us parameterize other objects with different requests, queue or log requests, and support undoable operations.	
		
				Person -----------------------------------------> RemoteControl class (pressButton())
																	|
																	|
																	|
																  Command (interface) execute()
																	|
																	|
																	|
													  -----------------------------
													  |							  |
													  |							  |
													  |						      |
												  OnCommand	execute()		OffCommand execute()
												    |							  |
												    |							  |
												    \/						      |
												 Televison <-----------------------
												  on()
												  off()
												  
	h. (Revisit)Decorator design patter : It is also a behavioural pattern which allow a decorator to be wrapped arround the wrapper class.example : 
	new BufferReader(new FileReader());
				      								  
	i. Dependency Injections and Inversion of control patterns  :  We know that we can inject the instance of one class to the another class using spring framework dependency       	injection fetaure . Its also know as IOC(Invertion of control)	
			In lemen term dependency injection is to inject the class dependency at runtime by creating the instance of the dependency class and using it dynamically with in the main class which need DI. We know that @Autowired is the annotation for the field level DI which inject the instance of the class created at runtime by the Spring container at runtime while scanning @Component , @Repository , @Service etc. The main annotation needed is @component to come up as part of the scan list of classes for the spring container. In case of an interface to be injected . We need to make the implementing class for the interface as @Component
			Or else  @Component can be done on all classes to be insjected.
			Three types of DI or IOC 
				1. Field level DI  : in which we will declare the Class object and to instantiate it use @Autowired.
				2. Setter Injection : in which we will annotate the setter of the object to be injected into the other class by creating the setter and getter for the dependency class.
				3.  Constructor level DI : in which we can use the parameterize Constructor of the class where we need to inject the other class (annotated as @Component) and give the dependency class as a parameter and initialize it using this.object=object . Annotate the constructor with @Autowired
			

	j. Prototype Objects Design Patterns : In this the one existing object will be used to create another object quickly .
				This case we can  have a prototype object ready with all data initialized and create a copy of it and do the work . No need to create a new object from the sctrach and do the initialization again.
				
			For that Cloneable interface is used which allow clone method to be override so that a copy of the class (object) can be done. Which servers our purpose of creating a prototype.	
			
			Example  : Create a class 
					class Game implements Cloneable{
					private int a ;
					private int b;
					
					 @Override
						protected Game clone() throws CloneNotSupportedException {
							return (Game) super.clone();
							
							
						}
						
						//getter and setter 
						// tostring just in case you print the object of this class it will print the attribute values.
					
					}
	
	k. Proxy Design Pattern : We know about the proxy servers which act as an internet or the placeholder for the actual url where the required files are.
	
				client -------Sends download request---------------> Proxy Server ----------------------> Actual Server
				Here proxy server will go to the actual server to get the required data or liberaries to be downalode.
				In java we can create a proxyclass that will get the data for you .
				So example : 
				
						Customer Interface 
						|               |      
				CustomerImp			CustomProxyImpl		
						
							Order bean 					  
2. JEE pattern catalog : 
	This catalog contains design patterns which are scattered across the different layers for java applications
	for example  : 
	
				Presentation layer 					Intergation layer
							|						|
							|						|
							Service Layer/Busines Layer
										|
										|
							     Data Access layer
								 
				- Presentation layers : Contains patterns which will allow users to interact with the users like UI , GUI etc .
				- integration layers : Contains patterns which will allow the Service layers / business layers to interact with other applications
				- data access layer : Patterns for DB access. Where all CRUD operations will happens.
				- Service/Business layers : which is used to transform the data and allow service to the consumer
	
	
	Number of classes in JEE pattern 
	
		1. Model View Class(c)
	-Data access layer	
		2. IDAO(Interface for DB access)
		3. IDAOImpl(implementations of IDAO)
	-Service/Business layers	
		4. IService(I)(interface to do the business logic)
		5. IServiceImpl(to write the business logic by overriding the methods in above iterface)
	-Presentation layers 	
		6. Controller ()
		
	    7. Utility classes 
		8. Validator class(C) : For validation of incoming request and so on.
	
	-integration layers : 
		9. Service Producer or Service Consumer (mostly the rest apis consuming or sending the request )
		
	    10. View(C) : to show the data in excel sheet , pdf etc 

   Type of Design patterns in JEE Layers : 
a. Intercepting Filter design pattern : 
	This design pattern will allow you to write a filter logic or prgram to authenticate , encrypt/decrypt, uncomporess etc before it reached the target system.
	