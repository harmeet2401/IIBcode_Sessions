Design patterns in java -------------------- Really important.

Design pattern helps in identify recurring problems and create a solution arround that problem.
1. Design patterns helps in creating a solution arround the problem 
2. This patterns can be re-used to be applied to any project which face this issue. As design pattern is a patterns(kind of  prob recurring)
3. Design pattern make the project structure better.

How to apply design pattern 
1. First check the design pattern from the pattern catalog which can be appled to the problem occuring in the projects 
2. In no pattern is there to solve issue. Document the issue (problem) , create a solution and keep it as a candidate pattern.
3. If the above issue keeps on coming across the projects and is getting resolved by applying above candidate pattern then that candidate pattern will be added to the pattern catalog

Types of Pattern catalog to choose pattern from .
1. GOF pattern catalog : 
	- Creational patterns : which is all related to the creation and instantiation of the class objects
	- Structural patterns : Which is all realted to the class struture.
	- Behaviour patterns : which is all related to the calling heppens or communication between classes.
	
	a. Singleton Pattern : Its a creational pattern which will allow only one object to be created for the  class and shared across all the classes.
			for example : 
					case 1 : in this case singleton pattern will allow only one object of PropertyReader class to be created to save memory.
						Class 1 ----------------------|
													  |
													  PropertyReader class (which has  function to read/write values from the file) <---------------------> file
						class 2 ----------------------|
					Case 2: 
						public static Logger log = LoggerFactory.getLogger(Classname.class)
						
						Above log object singleton will be used by all the classes to log message.
						
			Ques: How to make a singleton design pattern 
			Ans : step sto follow : 
					- Create the constructor private to stop the instantiation from other classes.
					- Then create the private static variable of same class type so that we can instantiate it back .
					- then create a public static method to return the above private static class variable back . Check is added to check if private static attribute is null or not.
					
				a. lazy instantiation : with in the method . to instantiate private static attribute. PREFFERED
				b. eager instantiation : eg : private static DateUtil dateUtil = new DateUtil(); ----- on class level.
										   public static DateUtil getInstance(){
											return dateUtil;
											}
									it means we are returning the variable value only once whic is instantiated once at class level.
				c. Static block instantiation : we can instantiate with in the static block to instantiate the dateUtil variable once.
									static {
									
										 dateUtil = new DateUtil();
										}
				d. Issue 1 : How to make the instantiaton of the private static attribute thread safe is by marking the block of code s static.
				
						synchronized keyword to mark the function thread safe .
						synchronized (DateUtil.class){ ---- block to mark piece of LOC 
						
						}
				e. Issue 2 : serialisation and de-serialisation : Serialization in Java is a way of saving and sending objects as bytes, like a snapshot of their state
					Like we can send the value of a variable and object to a file after serialisation. And then de-serialise it back while reading from the file or the network.
					
					
					- First implement Serialisable interface in the class of which the objects will be serialised and writtern/read to/from the file.
					- ObjectOutputStream(new FileOutputStream(new File(filepath))) is the class we can use to convert/serealize the object and send it as a byte to the file or to the network socket.
					- ObjectInputStream(new FileInputStream(new File(filepath))) is the class we can use to convert/de-serealize the object from the file or the network socket back 

				Issue : In singleton classes while serialisation and de-serialisation an issue occurs that jab ham singleton class ke object ko serialise krte hai ObjectOutputStream class use krke and file mai write krne ke baad usse read krte hai (de-serealize) to who read object same nhi hotta original vale se. Means de-serialisation creates a new instance of the singleton class.
					To resolve the issue we use readResolve() function which will be called by ObjectInputStream while reading and will return the same instance as we created in singleton  class in  getInstance() method. Olaaaaaaaa !
					
				f. Issue 3 : Handle cloneable : For singleton to work 100% we have to take care of the cloneable issue . Means if some class extends our singleton class and wants to clone it then that class should get CloneNotSuportedException().

					- Implements Cloneable interface 
					- Override the Clone() method and throw CloneNotSuportedException().
						olllllllllllllllaaaaa! this issue also resolved.
				
				g. Issue 4 : Reflection problem : Now we know our class is singleton and we can create only one instance . But reflection is the technique using which we can interate through the constructors of the singleton class and change the accessibility to public type by changing the flag and use it to create the new instance.
				Is reflection technique ne singleton pattern ko break krdiya  and allowed user to create new instance easily.
				
						Constructor[] constructors = DataUtil.class.getDeclaredConstructors();
						Loop through the constructors and setAccessibility(true)
						then use that constructor to create new instance 
						booooooooooommmmm hacked.
						
						
				To resolve this issue , we have to use something which doesn't have constructors . So ENUM is one of the feature by java which has no constructors and help in creating the INSTANCE only by enumname.INSTANCE.
				
				As there is no constructors , we can not use reflection technique to loop through the constructors and set the accessibility flag true to start creating new instances.
									
				NOTE : IN NUTSHELL MAKE SURE TO INSTANTIATE THE CLASS TYPE PRIVATE ATTRIBUTE ONLY ONCE AND RETURN IT.
				
				
	b. Factory Design pattrn : Its used to hide the Object creational process. 				
		In nut shell we have to hide the object creation in factory class. its a normal java class with only operations is to instantiate the other class objects.
		
		Order(test class)----
							|
							|
						PizzaStore 
							|
			----------------PizzaFactory(factory class with static method.)
		Pizza(interface)
		|
		|- ChickenPizza
		|
		|- VeggiePizza
		|
		|- CheesePizza
		
		- In abve digram Pizza is the interface which will have three function , PreparePizza , backPizza and Cutpizza. And will have three implementations to define the functions of the interface with appropriate values.
		
		
		- Pizzafactory is the normal java class which will hndle the object instantiation for the Pizza Interface. Which will contains a static method which will instantiate or create the objects and return back. As it is static we won't be needing the object creation for PizzaFactory class. directly do PizzaFactory.staticmethodname()
		
	c. Abstract Factory Design pattern : An abstract factory is the factory of factories . Means To create the object for factory classes we have Abstract factory class which knows how to do it. Now this abstract factory class should also be invoked to create downstream factory class which is done by Producer.
	Its an abstract class with abstract method in it.
	
			ClientClass input ---|
								 |
								 |
							 Producer 
								|
							VehicleAbstartctFactory (Factory of factories)
								|
					  ---------   ------------
					  |						 |
				FourWheelerfactory         TwoWheelerFactory	
				
				
				
				   ---------VehicleDAO(Interface)----
				  |- audiar			                 |- hondaScooty
				  |- audibus					     |- hondaBIke
				
				

			in above diagram it shoes that PizzaFactory and TwoWheelerFactory will be created by an abstractFactory which will be produced by producer.

	d. Template Method deisgn pattern : Its like creating a template method which will be same for all the implementing classes. 
			Example , One interface or an abstract class with three fns (renderdata() , readdata(), processdata()).
				out of above gave defination for the renderdata() function which will act as a template for all the other implementing classes. and other two funcstions to be deifned accordingly in implementing classes.
				
	e. Adapter pattern :  Its like we will use a program between two modules , two apps or two cross platform application to transform the data which is required by the other apps .

		App1 (send XML) --------> Adapter program  --------------> App2(which data to be in json format.)
								transform it in json 
								and feed it to app2
    f. flywight design pattern : In this design pattern , the main problem which is resolved is creating multiple instances of the objectc again again.
								To overcome that we can use Map<String, Object> map = new HashMap<>(). To cache the object in sthe hash table which is then returned everytime we need to invokve the method of the class for which the object is created.
								Now the string type or the key should be unique so that same copy of the object can be retrived from the cache.
								
							Human (Interface)
							beath(){}
							eats()
							weight()
							

					Girl 				Boy (implements HUman interface )

			Note : Factory method along with map or hashmap act as flyweight design pattern . Which is used to overcome the issue of large number of objects creation which eats up the memory
					
								
2. JEE pattern catalog : 
	This catalog contains design patterns which are scattered across the different layers for java applications
	for example  : 
	
				Presentation layer 					Intergation layer
							|						|
							|						|
							Service Layer/Busines Layer
										|
										|
							     Data Access layer
								 
				- Presentation layers : Contains patterns which will allow users to interact with the users like UI , GUI etc .
				- integration layers : Contains patterns which will allow the Service layers / business layers to interact with other applications
				- data access layer : Patterns for DB access. Where all CRUD operations will happens.
				- Service/Business layers : which is used to transform the data and allow service to the consumer
	
	
	
	