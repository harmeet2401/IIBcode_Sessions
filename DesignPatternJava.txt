Design patterns in java -------------------- Really important.

Design pattern helps in identify recurring problems and create a solution arround that problem.
1. Design patterns helps in creating a solution arround the problem 
2. This patterns can be re-used to be applied to any project which face this issue. As design pattern is a patterns(kind of  prob recurring)
3. Design pattern make the project structure better.

How to apply design pattern 
1. First check the design pattern from the pattern catalog which can be appled to the problem occuring in the projects 
2. In no pattern is there to solve issue. Document the issue (problem) , create a solution and keep it as a candidate pattern.
3. If the above issue keeps on coming across the projects and is getting resolved by applying above candidate pattern then that candidate pattern will be added to the pattern catalog

Types of Pattern catalog to choose pattern from .
1. GOF pattern catalog : 
	- Creational patterns : which is all related to the creation and instantiation of the class objects
	- Structural patterns : Which is all realted to the class struture
	- Behaviour patterns : which is all related to the calling heppens or communication between classes.
	
	a. Singleton Pattern : Its a creational pattern which will allow only one object to be created for the  class and shared across all the classes.
			for example : 
					case 1 : in this case singleton pattern will allow only one object of PropertyReader class to be created to save memory.
						Class 1 ----------------------|
													  |
													  PropertyReader class (which has  function to read/write values from the file) <---------------------> file
						class 2 ----------------------|
					Case 2: 
						public static Logger log = LoggerFactory.getLogger(Classname.class)
						
						Above log object singleton will be used by all the classes to log message.
						
			Ques: How to make a singleton design pattern 
			Ans : step sto follow : 
					- Create the constructor private to stop the instantiation from other classes.
					- Then create the private static variable of same class type so that we can instantiate it back .
					- then create a public static method to return the above private static class variable back . Check is added to check if private static attribute is null or not.
					
				a. lazy instantiation : with in the method . to instantiate private static attribute. PREFFERED
				b. eager instantiation : eg : private static DateUtil dateUtil = new DateUtil(); ----- on class level.
										   public static DateUtil getInstance(){
											return dateUtil;
											}
									it means we are returning the variable value only once whic is instantiated once at class level.
				c. Static block instantiation : we can instantiate with in the static block to instantiate the dateUtil variable once.
									static {
									
										 dateUtil = new DateUtil();
										}
				d. Issue 1 : How to make the instantiaton of the private static attribute thread safe is by marking the block of code s static.
				
						synchronized keyword to mark the function thread safe .
						synchronized (DateUtil.class){ ---- block to mark piece of LOC 
						
						}
				e. Issue 2 : serialisation and de-serialisation : Serialization in Java is a way of saving and sending objects as bytes, like a snapshot of their state
					Like we can send the value of a variable and object to a file after serialisation. And then de-serialise it back while reading from the file or the network.
					
					
					- First implement Serialisable interface in the class of which the objects will be serialised and writtern/read to/from the file.
					- ObjectOutputStream(new FileOutputStream(new File(filepath))) is the class we can use to convert/serealize the object and send it as a byte to the file or to the network socket.
					- ObjectInputStream(new FileInputStream(new File(filepath))) is the class we can use to convert/de-serealize the object from the file or the network socket back 

				Issue : In singleton classes while serialisation and de-serialisation an issue occurs that jab ham singleton class ke object ko serialise krte hai ObjectOutputStream class use krke and file mai write krne ke baad usse read krte hai (de-serealize) to who read object same nhi hotta original vale se. Means de-serialisation creates a new instance of the singleton class.
					To resolve the issue we use readResolve() function which will be called by ObjectInputStream while reading and will return the same instance as we created in singleton  class in  getInstance() method. Olaaaaaaaa !
					
				f. Issue 3 : Handle cloneable : For singleton to work 100% we have to take care of the cloneable issue . Means if some class extends our singleton class and wants to clone it then that class should get CloneNotSuportedException().

					- Implements Cloneable interface 
					- Override the Clone() method and throw CloneNotSuportedException().
						olllllllllllllllaaaaa! this issue also resolved.
				
				g. Issue 4 : Reflection problem : Now we know our class is singleton and we can create only one instance . But reflection is the technique using which we can interate through the constructors of the singleton class and change the accessibility to public type by changing the flag and use it to create the new instance.
				Is reflection technique ne singleton pattern ko break krdiya  and allowed user to create new instance easily.
				
						Constructor[] constructors = DataUtil.class.getDeclaredConstructors();
						Loop through the constructors and setAccessibility(true)
						then use that constructor to create new instance 
						booooooooooommmmm hacked.
						
						
				To resolve this issue , we have to use something which doesn't have constructors . So ENUM is one of the feature by java which has no constructors and help in creating the INSTANCE only by enumname.INSTANCE.
				
				As there is no constructors , we can not use reflection technique to loop through the constructors and set the accessibility flag true to start creating new instances.
									
				NOTE : IN NUTSHELL MAKE SURE TO INSTANTIATE THE CLASS TYPE PRIVATE ATTRIBUTE ONLY ONCE AND RETURN IT.
				
				
	b. Factory Design pattrn : Its used to hide the Object creational process. 				
		In nut shell we have to hide the object creation in factory class. its a normal java class with only operations is to instantiate the other class objects.
		
		
						PizzaStore 
							|
			----------------PizzaFactory
		Pizza 
		|
		|- ChickenPizza
		|
		|- VeggiePizza
		|
		|- CheesePizza
		
		In abve digram Pizza is the interface which will have three function , PreparePizza , backPizza and Cutpizza. And will have three implementations to define the functions of the interface with appropriate values.
		
		
		Pizzafactory is the normal java class which will hndle the object instantiation for the Pizza Interface.
	
2. JEE pattern catalog : 
	This catalog contains design patterns which are scattered across the different layers for java applications
	for example  : 
	
				Presentation layer 					Intergation layer
							|						|
							|						|
							Service Layer/Busines Layer
										|
										|
							     Data Access layer
								 
				- Presentation layers : Contains patterns which will allow users to interact with the users like UI , GUI etc .
				- integration layers : Contains patterns which will allow the Service layers / business layers to interact with other applications
				- data access layer : Patterns for DB access. Where all CRUD operations will happens.
				- Service/Business layers : which is used to transform the data and allow service to the consumer
	
	
	
	