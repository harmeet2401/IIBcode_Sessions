Spring boot --------------------------------------------------------------------------------------- UDEMY ------------------------------------------------------------------------

Download spring tool eclipse plugin for cntrl + space feature in application.yml files

Web service app : The app or technique using which we can provide services using internet to allow app to app interaction and make the 
				Service interoperability(platform in-dependent).
				These service we can expose to other application to consumer the response . so a rest full api that is hosted on to a servers 
				with Http protocol is an example of  it.
				
Parts of a web service (rest api )	:
				Service Definition  : It contains the type of request and response required for the api (The format for it) can be a swagger 
				Request  : Will involve the sample request 
				Response : Will involve the sample response 
				Endpoint  : how to call the web service(api)

Service provider : The web service which is exposed to the internet is the service provider.
Service consumer : is the one which hitting that web service to get the response back. 
Transport : Is the medium using which the data (request and response) will be sent example : MQ , kafka , HTTPs , HTTP.
Message exchange format : The format of the request and response which is exchanged between consumer and provider.

SOAP :---------- Its simple object access protocol it works on top of the HTTP protoocol which is more secure and wrapped the message in to a soap envelop and send it along with the soap headers , for soap we need a wsdl to define the defination file which will contains the sample request , response and url at which we need to trigger the request for 

Its a protocol that allow app to communicate using a defined message structure .
		
		--------------------------------
		
				SOAP ENVELOP
				
				-----------
				 SOAP HEDER
				-----------
				
				-----------
				 SOAP BODY 		

			
			
				 SOAP BODY 		
				-----------
				
				
				
				SOAP ENVELOP
		-------------------------------
		

Soap defines does not impose any restriction on the transport , we can use either http and mq 

A WSDL is create web service definition language that  contains :

	The End point 
	the operation (delete employee , get employee , update employee data )
	The request structure 
	The response structure.

Soap only involve XML as the message format to exchange request and response .

	
REST : --------- REpresentational State transfer method/methodology. is developed to make best use of the HTTP protocol .

The HTTP protocol is used to transfer HTML data from consumer to service provider .

rest contains 
	Message format  : The format of the message to exchange in between is Json , XML or any other format  
	Transport : Only HTTP protocol. Where as the soap request can be transported using any  messaging service (MQ , kafka , HTTP.)
	Rest full definition : WADL web application definition language / Swagger that contains the end point , operation  , request structure and response structure .
	
start.sring.io  : to initialize your rest-full service by selecting the package and dependencies you need for building an api.	
The dependencies we select is JPA (java persistent api) for sql , H2 is for hybernate , web , devtools 

There are multiple methods for the rest api to send/retrive/update the data .

get , put , post , delete : These methods will help in doing that 

Lab 1 ----------------- Create a hello world rest api service to respond as hello world when get method is used for it.
We need two things 

DispatcherServlet is the one which is sitting on the front receives the input request and sends the control to the desired controller method as per uri.
	@RestController ---- > to tell the spring mvc that this controller is going to handle the rest http request : that contains all request mapping functions 
	@RequestMapping --- >  This annotation will allow to mention the method and uri for which the controller will react. @RequestMapping(method='Get',Path="/hellow-world")
	@GetMapping -- > We can also use this annotation  . no need to mention method as get . @GetMapping(path="/hello")
	@PutMapping -- > We can also use this annotation  . no need to mention method as PUT . @PutMapping(path="/hellow-world")
	@PostMapping -- > We can also use this annotation  . no need to mention method as POST . @POstMapping(path="/hellow-world")
	@RequestParam ---- > to get the value from url which is send like localhost:8080/test?name=harmeet , where harmeet is the requestparms
	@ResponseEntity ----- > to modulate the outgoing response from the controller function 
	@RequestBody ----- > to map the incoming request to the bean wrote .
	@Pathvariables ----- > to bind the value frm url to a variable url like : localhost:8080/test/2/ , so the path = /test/{id} . So 2 will be mapped to id 
	@RequestMapping ----> its a class level annotation or can also be applied to the function to receive request eith post , get , delete etc.
	@SpringbootTest --- > Annotation that can be specified on a test class that runs Spring Boot based tests. Which is further annotated as @ExtendWith
	@ExtendWith ------>is a repeatable annotation that is used to register extensions for the annotated test class or test method. Is used for JUNIT test => 5 
	@Runwith  -------- is used for junit test < version 5 
	@SpringBootTest(webEnvironment =  SpringBootTest.WebEnvironment.RANDOM_PORT) -----> in order to test the controller 
	
	

--------------------------------------	
@SpringBootTest
@ExtendWith(SpringExtension.class)
@RunWith(SpringRunner.class)
public class testclas{

}
-------------------------------------

testing uri : http://localhost:8080/hello : because spring boot run contains an inbuilt tomcat server which starts on localhost 8080 port by default .
	http://localhost:8080/hello-employee
Lab 1 ----------------- Create a hello world rest api service to respond as hello world when get method is used for it.
Create a controller using start.spring.io to set up the projects for spring boot.
in order to create spring controller mentions @RestController to the class other than the @SpringBootApplication class.

Inside the controller class mention or define a @RequestMapper method that will take the incoming request on a HTTP get / post/  , put etc and return the message hello world.

Lab 1 ----------------- Create a hello world rest api service to respond as hello world when get method is used for it.


Lab 2 ----------------- Create a hello world rest api service to respond as a bean back to the user.
How to return a BEan(A bean is a class with separate attributes(variables)) in which the constructor will require a string parameter and display it as 
JSON (which will be done by spring mvc in the back end)

Spring-boot-Auto-configuration : helps in configuring the dispatcher server and also initialize the Jackson bean that converts the Bean to Json while sending a response back.

We can start the debug the level logs for spring boot started console .

logging.level.org.springframework = debug


Dispatcher servelet is the front end controller for spring mvc frame work who knows which controller to call after looking at the uri . when we hit the uri , the dispatcher servelet will take the uri call the controller run the method get the bean , call the jackson parser convert it to json and send the json response back to the browser or consumer.

Complete uri : http://localhost:8080/hello
in above uri : / is mapped to dispatcher servelet and then it looks at the uri hello and send the control to the controller method which it knows.

Need below classes :
@SpringBootApplication class : starter class 
@Component which we use for service classes to manipulate the data coming from bean , this class can be autowired as it is annotated as a @component or a @Service
@Controller : which will contain the request mapping functions for incoming requests.
NOte : The controller and Component should be in same package 

Lab 2 ----------------- Create a hello world rest api service to respond as a bean back to the user.


NOte  : Change the log level for the spring boot aapp to debug mode is by adding below line in app.yml
logging.level.org.springframework = debug


Lab 3 ----------------- Create an another GetMapping method that will receive a Path variable and use that path variable to do more operations.
for this lab we created an another GetMapping function in which we map the path to this path=/hellow-world/path-varable/{name}
Now in above path the name variable will contains the value when we will hit the url 

Example : http//:localhost:8080/hellow-world/path-varable/Harmeet 

Then the GetMapping function named x() will receive the 'Harmeet' value in variable name and that can be used anywhere inside the program.

for postmapping function we can map the incoming request to the objectmodel by mentioning @RequestBody
Lab 3 ----------------- Create an another GetMapping method that will receive a Path variable and use that path variable to do more operations.


Lab 4 ----------------- Now create a service that will respond on three operations to get all users , to get specific user and to save user.
For that we need a new Bean User 
							
							--- >id
							--- >name
							--- >date
					Three methods to implement the operations in a service (Spring component)
								findAllUsers() 
								findUser(int id)
								saveUsre(User)
								Delete all users : need to clear the list created
								Delete the specific user , get the id for which the user wants to be deleted. Use Iterator 
										(what is an iterator?):	An Iterator is an object that can be used to loop through collections, like ArrayList and HashSet
								
Note : In order to Autowired the class object in to another class the class should either be annotated as a component or a service 								

IN ORDER TO AUTO GENERATE THE ID VALUE : WE CAN USE @GeneratedValue annotation so that sending null in creating an object will not throw null pointer exception 

When you hit the post request : we will get below error

{
    "timestamp": "2021-04-18T18:03:47.649+00:00",
    "status": 500,
    "error": "Internal Server Error",
    "trace": "org.springframework.http.converter.HttpMessageConversionException: Type definition error: [simple type, class myproject.minlearning.startertestclass.users.Users]; nested exception is com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Cannot construct instance of `myproject.minlearning.startertestclass.users.Users` (no Creators, like default constructor, exist): cannot deserialize from Object value (no delegate- or property-based Creator)\n at [Source: (PushbackInputStream); line: 3, column: 3]\r\n\tat org.springframework.http.converter.json.AbstractJackson2HttpMessageConverter.readJavaType(AbstractJackson2HttpMessageConverter.java:386)\r\n\tat org.springframework.http.converter.json.AbstractJackson2HttpMessageConverter.read(AbstractJackson2HttpMessageConverter.java:342)\r\n\tat org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodArgumentResolver.readWithMessageConverters(AbstractMessageConverterMethodArgumentResolver.java:186)\r\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor.readWithMessageConverters(RequestResponseBodyMethodProcessor.java:158)\r\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor.resolveArgument(RequestResponseBodyMethodProcessor.java:131)\r\n\tat org.springframework.web.method.support.HandlerMethodArgumentResolverComposite.resolveArgument(HandlerMethodArgumentResolverComposite.java:121)\r\n\tat org.springframework.web.method.support.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:170)\r\n\tat org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:137)\r\n\tat org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:106)\r\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:894)\r\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:808)\r\n\tat org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)\r\n\tat org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1060)\r\n\tat org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:962)\r\n\tat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)\r\n\tat org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909)\r\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:652)\r\n\tat org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)\r\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:733)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:227)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\r\n\tat org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\r\n\tat org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\r\n\tat org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\r\n\tat org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\r\n\tat org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202)\r\n\tat org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97)\r\n\tat org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:542)\r\n\tat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:143)\r\n\tat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)\r\n\tat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78)\r\n\tat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:357)\r\n\tat org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:374)\r\n\tat org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)\r\n\tat org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:893)\r\n\tat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1707)\r\n\tat org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\r\n\tat java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)\r\n\tat java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)\r\n\tat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\r\n\tat java.base/java.lang.Thread.run(Thread.java:834)\r\nCaused by: com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Cannot construct instance of `myproject.minlearning.startertestclass.users.Users` (no Creators, like default constructor, exist): cannot deserialize from Object value (no delegate- or property-based Creator)\n at [Source: (PushbackInputStream); line: 3, column: 3]\r\n\tat com.fasterxml.jackson.databind.exc.InvalidDefinitionException.from(InvalidDefinitionException.java:67)\r\n\tat com.fasterxml.jackson.databind.DeserializationContext.reportBadDefinition(DeserializationContext.java:1615)\r\n\tat com.fasterxml.jackson.databind.DatabindContext.reportBadDefinition(DatabindContext.java:400)\r\n\tat com.fasterxml.jackson.databind.DeserializationContext.handleMissingInstantiator(DeserializationContext.java:1077)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializerBase.deserializeFromObjectUsingNonDefault(BeanDeserializerBase.java:1332)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeFromObject(BeanDeserializer.java:331)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:164)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:4526)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3521)\r\n\tat org.springframework.http.converter.json.AbstractJackson2HttpMessageConverter.readJavaType(AbstractJackson2HttpMessageConverter.java:378)\r\n\t... 51 more\r\n",
    "message": "Type definition error: [simple type, class myproject.minlearning.startertestclass.users.Users]; nested exception is com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Cannot construct instance of `myproject.minlearning.startertestclass.users.Users` (no Creators, like default constructor, exist): cannot deserialize from Object value (no delegate- or property-based Creator)\n at [Source: (PushbackInputStream); line: 3, column: 3]",
    "path": "/users"
}	

This is because in current version of jackson we need a default constructor in the bean we are using .

So add a protected default no arg constructor
								
I have also added the method to delete the user from the list using PUT methods in the controller.		

For best HTTP REST api service : While creating an object you can send the Build uri back to the user in header .
This can be achieved by using ServeletUriComponentbuilder class that helps in creating the uri which we can pass to the user in header 				

URI location = ServletUriComponentsBuilder.fromCurrentRequest().path("/{id}").buildAndExpand(users.getId()).toUri();
        ResponseEntity.created(location);
		
http status code : 201 : the object created
					200 : get ok 
					404 : not found 
					
Now if we need to handle the not found exceptions we can throw the runtimeexception under a certain conditions	. By creating a class exception class 

package myproject.minlearning.startertestclass.users;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;


@ResponseStatus(HttpStatus.NOT_FOUND)
public class UserNotFouncException extends RuntimeException {
    public UserNotFouncException(String message) {
        super(message);
    }
}



Post that RUntimeexception we start getting exception 500 internal server error 

We can make it more readable htppstatus by adding @ResponseStatus(HttpStatus.NOT_FOUND) to the UserNOtFoundException class.
We can modify the http status code accordingly.

*******NOTE : WHENEVER YOU WANT TO CUSTOMIZE ANY RESPONSE FROM REST API , CREATE A BEAN AND USE THAT BEAN AND THE ATTRIBUTES DEFINED IN IT AS A STRUCTURE FOR YOUR API RESPONSE.				

But for the generic exception response to be sent to the user we need to use ResponseEntityExcpetionHandler class to be extend this class provide various functions to override so 
that we can send an instance of our bean to the user when ever an exception comes around any controller

For that we need to make that class A extend ResponseEntityExcpetionHandler to be a Restcontroller and with annotation @ControllerAdvicer (which is used to share the feature 
across all the controller ).

	ThIS IS USED TO SEND THE RESPONSE IN ANY KIND OF EXCEPTION COMES  FOR WHICH WE ARE CREATING ResponseEntityExcpetionHandler class
	----------------------------------------------------------------
    THATS COOL , I MEAN YOU JUST HAVE TO DEFINE THE @RestController AND @controllerAdviser to share the feature to all controllers .
				You need to handle the exceptions whether it is generic or it is specific .
				using @ExceptionHandler annotation on a function we can handle any kind of exceptions, whenever you throw an exception from anywhere  of the controllers , 
				This handler will send a response in a generic structure defined in our bean.
Lab 3 ----------------- Now create a service that will respond on three operations to get all users , to get specific user and to save user.


Lab 4 ----------------- now for above created Rest api we are to perform validation 

If you are making use of Spring Boot Release (> 2.3.0) make sure to add the following dependency to your pom.xml (We are going to implement validations in next step):

<dependency>    
    <groupId>org.springframework.boot</groupId>    
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>

For the validation to work on the attributes of the bean , we need to use :
		@valid along with the @RequestBody 
		In bean class for each attibutes for which we need the validation to happen . use validation annotation like , @Size (which says the min or max lenght of the string )
			or @Past to constraints the date to be in past 
		
			Now when you hit the api it will validate and send you bad request , but the respose body will be empty :(
			So to bring something readable for user to read we need to add one more function in customexceptionresponseentityclass which is the override function of
			ResponseEntityExcpetionHandler class named : handlemethodArgumentnotvalid


*********CREATING A CUSTOMIZEEXCEPTIONHANLDER CLASS IS MUST , DON'T FORGET TO ADD THIS CLASS . EXTENDS ResponseEntityExcpetionHandler CLASS.			
Lab 4 ----------------- now for above created Rest api we are to perform validation 


HATEOAS : --------------------------------------------------------

HATEOAS : Hyper media at the engine of application state . this is the feature using which we can provide more information apart from the data we are returning bck to the consumer .
For example: whenever we search for a repo in git , we got whole lot of other informations also , like number of stars , other links also .

Soooooooooooooo in order to add more info or more links to your response you can use HATEOAS .

Add a starter dependencies :

<dependency>    
    <groupId>org.springframework.boot</groupId>    
    <artifactId>spring-boot-starter-hateoas</artifactId>
</dependency>

import static org.
This spring feature treat other infor to be sent back as a response as Resource , so we need to use Resource java class for that . and return along with it 
example : EntityModel<bean class >   resource = new EntityModel<user>();

NOTE : WE ARE RETURNING DATA AS  WELL AS THE LINKS , BOTH ARE PART OF THE RESOURCE FIRST WE CREATED THE DATA RESOURCE USING ENTITY AND THEN LINK THE OTHER INFO TO IT.

HATEOAS : --------------------------------------------------------


INTERNATIONALIAION : ---------------------------------------
This is the feature in which suppose you are getting data request or get request from different country or locale .
So language is a barrier , in order to response with different data as per the locale we internationalize the response using property files.

@Bean
	LocaleResolver localeResolver(){
		SessionLocaleResolver localeResolver = new SessionLocaleResolver();
		localeResolver.setDefaultLocale(Locale.US);
		return localeResolver;
	}
	in the getter method of the controller we have to pass the locale paramter in header .
	
In order to pick the properties value and send that as a resource back we will use 
The Locale value the consumer will send that in the message header and we can get that using @RequestHeader Locale local.


----------Simplify the internationalization -----------
In order to add @RequestHeader Locale locale as a parameter for multiple get methods it would be a pain 
 To remove that take the locale object from localeContext and change the SessionLocaleResolver to AcceptHeaderLocaleResolver
 And we can also add the setBasename in application.properties.  spring.message.basename=messages

INTERNATIONALIAION : ---------------------------------------


Lab 5 --------------------As we know jackson is doing the conversion from object to json sofar , So in-order to receive the response in XML we can add jackson other dependencies for XMl data format ---------------

Need to add jackson-dataformat-xml dependencies

			<dependency>
                <groupId>com.fasterxml.jackson.dataformat</groupId>
                <artifactId>jackson-dataformat-xml</artifactId>
            </dependency>
and send the header explicitly as application\xml to receive the response in xml format 

json : 
[
    {
        "id": 1,
        "name": "Harmeet",
        "birthdate": "2021-04-26T11:37:01.480+00:00"
    },
    {
        "id": 2,
        "name": "Simran",
        "birthdate": "2021-04-26T11:37:01.480+00:00"
    },
    {
        "id": 3,
        "name": "Harpreet",
        "birthdate": "2021-04-26T11:37:01.480+00:00"
    }
]


xml : 
<List>
    <item>
        <id>1</id>
        <name>Harmeet</name>
        <birthdate>2021-04-26T11:37:01.480+00:00</birthdate>
    </item>
    <item>
        <id>2</id>
        <name>Simran</name>
        <birthdate>2021-04-26T11:37:01.480+00:00</birthdate>
    </item>
    <item>
        <id>3</id>
        <name>Harpreet</name>
        <birthdate>2021-04-26T11:37:01.480+00:00</birthdate>
    </item>
</List>

Jackson do all the magic to it  this is called CONTENT NAGOTIATION 



Lab 5 --------------------As we know jackson is doing the conversion from object to json sofar , So inorder to receive the response in XML we can add jackson other dependencies for XMl data format ---------------



Lab 6 ---------------Auto swagger generation ---------------
For rest full service we have swagger and for soap service we have WSDL .

For Auto generate the Swagger for an api we can use below dep 
<dependency>
      <groupId>org.springdoc</groupId>
      <artifactId>springdoc-openapi-ui</artifactId>
      <version>1.5.10</version>
   </dependency>
   
 http://localhost:8081/swagger-ui/index.html is the url we can use to see the ui documentation
 
 http://localhost:8081/v3/api-docs : to get the json file out 
   

below steps are used to modify the swagger as per our needs.


Step 1 : 

Add below dependency instead of above two :

<dependency>
	<groupId>io.springfox</groupId>
	<artifactId>springfox-boot-starter</artifactId>
	<version>3.0.0</version>
</dependency> 	
	
	
Step 2 :	
Now configure swagger : 
	Create a configuration class SwaggerClass2.java use @Configuration  , @EnableSwagger2
	Create a @Bean name Docker , which is part of the springfox documentation 


Step 3 : 
You will see below urls :

		\v2\api-docs : - to get the entire swagger json 
		NEW URL for SWAGGER UI - http://localhost:8080/swagger-ui/ or http://localhost:8080/swagger-ui/index.html

A swagger contains  :
			Swagger version : version 2.0 , 3.0
			info : The info about the api , and the license
			path  : the paths contains the various get-mapping  , put-mapping and post-mapping functions we have created .
			tags 
			definition : will contains the bean definition used .
			host : the server host where it will be run..
			base-path : the base path for the url

Step 4 : To improve some things in swagger documentation like , validations we applied on some fields and Api info description and the consumption format and production format
	For that we can make some changes in swagger config class we created .
	
	We can use class ApiInfo.java by importing it . This class will give the objects to be copied for the modification 
	@ApiModel(Description = "") : to give description about the Api model we have like User.java class on class level we can annotate it.
	@ApiModelProperty(Notes = "") : 	We can also use that on an attribute level .

The docket function bean we have created we can use to modify different property of the swagger documents (NOTE : LOOK AT THE SWAGGER CREATED).
 example :  return new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(DOCKET_API_INFO).produces(produces)
                .consumes(consumes);


Lab 6 ---------------Auto swagger generation ---------------



Lab 7 : ----------- Spring boot actuator -----------

Please add the below dependency instead of spring-data-rest-hal-browser

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-actuator</artifactId>
		</dependency>
		
		<dependency>
			<groupId>org.springframework.data</groupId>
			<artifactId>spring-data-rest-hal-explorer</artifactId>     ---------------- this will launch a browser at localhost:8080 to hit the api using paths .
		</dependency>
		
		The actuator works around hal : HyperText Application language  : 
		
Why we use Actuator   ?   Now as we know we have documented our application  , now i need some monitoring feature for my api to show it is up and running or to see the metrics , for that spring boot have provided actuator for it.		

Url to launch Actuator : localhost:8080/applications
							localhost:8080/actuator
{
	"_links": {
		"self": {
			"href": "http://localhost:8080/actuator",
			"templated": false
		},
		"health": {
			"href": "http://localhost:8080/actuator/health",
			"templated": false
		},
		"health-path": {
			"href": "http://localhost:8080/actuator/health/{*path}",
			"templated": true
		},
		"info": {
			"href": "http://localhost:8080/actuator/info",
			"templated": false
		}
	}
}



Lab 7 : ----------- Spring boot actuator -----------



Lab 8 : ----------- Spring boot filtering , in which we can filter out the fields we dont need from a bean ---

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
 
 Jackson provide two annotations for JsonIgnore on a field level that will help in removing the fields don't want to be in the response.
 
 or 
 JsonIgnoreProperties on class level and mention the fields to be removed .




Lab 8 : ----------- Spring boot filtering , in which we can filter out the fields we dont need from a bean ---

Lab :------------------- Dynamic filtering 

We can use mappingjacksonValue is the class that help is sending a filtered bean value back as a response.

MappingjacksonValue mapping = new mappingjacksonValue(bean)
mapping.setfiltering(filter);
return mapping;


Verry important point always mention the @JsonFlter on top of the bean class to implement the dynamic filter occuring from controller.



Lab :------------------- Dynamic filtering 




Lab 9 : ----------- Version rest api

Example for versioning : The customer may ask to send the name as a single string and also to send name as two string as first name and last name .
for that we can keep two @GetMapping mapped with two different urls and share those urls with customer to hit.

There are four methods to implement versioning for your API : in all below methods we update the path in get/post mapping 

URI versioning : in which we can create two uri's for external user , but this will pollute the uri space .
Param versioning : in which we can send the query parameters in uri , this will also pollute the uri space 
header versioning : in which we can send different header values to be picked up for different version response , header are never meant for versioning.
MIME versioning : in this by sending the Accept header value as different version we can send differnt response .
Lab 9 : ----------- Version rest api


Lab 10 : ----------- Authentication implement

add below dependency : 
	<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-security</artifactId>
	</dependency>
		
		
This will allow spring to add basic authentication to your rest api .
fire up your api in logs you will get the password in alpha numeric value and default username will be : user

this will add authentication for all controllers

username : user 
Using generated security password: 0812eff5-00c0-4390-8271-35c6f688512e

Everytim you spun up the rest api it will create a new password to stop that 
we can mention below two properties in application.yml file.
spring.security.user.name=username
spring.security.user.password=Gogi!1234

Lab 10 : ----------- Authentication implement
		
Lab 11 :------------  JPA (java persistent api) for sql		
The Java Persistence API (JPA) is a specification of Java. It is used to persist data between Java object and relational database. JPA acts as a bridge between object-oriented domain models and relational database systems.
we can use @Entity for the bean we created to convert that bean into an entity in which the attibutes will be converted to each column and bean will be a table 
1) H2 database name is randomly generated each time you restart the server. You can find the database name and URL from the console log.


Step 1 : add below 
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>



Step 2 : add below in app.yml
2) To use data.sql, you need to add this to 
spring.jpa.show-jpa=true
spring.h2.console.enabled=true
spring.datasource.url=jdbc:h2:mem:testdb
spring.data.jpa.repositories.bootstrap-mode=default
spring.jpa.defer-datasource-initialization=true

http://localhost:8080//h2-console

Step 3 : create an sql file and run three insert queries to insert data to h2 in memory db


Step 4 : 
	a. Create a different user(bean) controller
	b. create a repository as an interface extending JPArepository<Users(bean) , Integer> , this repository is just like a daoservice that we used to get the value from Bean data.
		Now this repository will get the data from in memory db (h2)

Keep track of the function we use for the DAO service while intercating with the h2 database.
Lab 11 :------------  JPA (java persistent api) for sql		

Lab 12 ----- Spring cloud
challanges  for monolithic approach 
1. cloud config 
2. Elasticity 
3. Failt tolerance 
4. tracebility
5. auto - cloud configuration
5. Bounderies -- this shows what a single microservice is doing 
6. load balancing 


Spring Cloud Config : just like we can save all configs properties in one place in in git repo
Centralized external configuration management backed by a git repository. The configuration resources map directly to Spring Environment but could be used by non-Spring applications if desired.
Which will have Spring cloud client and spring cloud server dependenciesto be used .



Spring Cloud Netflix - for load balancing process.
This can be use to add the new instances .
Integration with various Netflix OSS components (Eureka, Hystrix, Zuul, Archaius, etc.).
Eureka(Naming server) : two feature : 
				Registry 
				instance discovery


Spring Cloud Sleuth is used for tracing along with zipkin
Distributed tracing for Spring Cloud applications, compatible with Zipkin, HTrace and log-based (e.g. ELK) tracing.

spring cloud api gateway : which is used to hold many common fetaure which involved authentication  , logging etc.
 
LAB : ----------Configuration load from app.yml file --------------------

We have two techniques to load properties from app.yml file 

1. Create a class with value which will hold the values from app.yml file.
	and annotate it with @Value("${key.value}")  where key.value =90 is in app.yml file .
	 annotate the class as component as it is to be autowired in function class.

2. Create a class annotate it with @Component and @ConfigirationProperties(prefix= "word.something to load")
		Then autowired and use that .



LAB : ----------Configuration load from app.yml file --------------------

Lab 12 ----- Spring cloud

lab 13 ----------------------Spring cloud config

microservice 1 				microservice 2
Spring 						Spring 
cloud client 			 	cloud client 
    |							|
	|							|
	|							|
	|connects to 				|connect to the 
	|							|spring cloud server
	|server						|
	|--------|			|-------|
			 |	        |
			 |          |
			 |          |
			 |          |
			Sprig cloud server 
			  Microservice 	3
					|
                    |
                    |connects to Git repo
                    |
                    |
				Git Repository

Annotate the spring cloud config app  as @EnableConfigServer				
				
@application.yml for spring cloud server app :
spring.application.name = spring-cloud-config-server
server.port = 8888
spring.cloud.config.server.git.uri=https://github.com/harmeet2401/serviceconfigcenter
                                   #https://github.com:harmeet2401/serviceconfigcenter.git
spring.cloud.config.server.git.search-paths=sprincloud-config
spring.cloud.config.server.git.force-pull=true
spring.cloud.config.server.git.username=harmeet2401
spring.cloud.config.server.git.password=Gogi!321
spring.cloud.config.server.git.default-label=main


@application.yml for microservice1 connecting to spring cloud srever
spring.application.name= limits-service
spring.config.import= optional:configserver:http://localhost:8888
limits-service.minimum=9
limits-service.maximum=800			

@application.yml for microservice2 connecting to spring cloud srever
server.port=8081
spring.application.name= startertestclass
spring.config.import= optional:configserver:http://localhost:8888/
startertestclass.username=harmeet singh
startertestclass.address= Plot no-988
startertestclass.id= 0023N7744
startertestclass.dept= IT

application.yml for microservice3
spring.application.name=micro-service2
spring.config.import=optional:configserver:http://localhost:8888
micro-service2.username=testname
micro-service2.password=testpass
micro-service2.dept=testdept
micro-service2.address=testaddress
server.port=8082
				
				
Now for the different region and single microservice how we will maintain the config files ?
By adding below two props we can call for the specific file

spring.profile.active=dev
spring.cloud.config.profile=dev

Then the complete yaml file will be 
spring.application.name=micro-service2
spring.config.import=optional:configserver:http://localhost:8888
micro-service2.username=testname
micro-service2.password=testpass
micro-service2.dept=testdept
micro-service2.address=testaddress
spring.profile.active=dev
spring.cloud.config.profile=dev
server.port=8081

NOTE********** : ALWAYS BOUNCE THE APP ONCE CHNAGE THE VALUE IN GIT FILE , DON'T BOUNCE THE SPRING CLOUS SERVER .
				
For spring boot  Auto yml assists add below dependencies : 
<!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-configuration-processor -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-configuration-processor</artifactId>
			<optional>true</optional>
		</dependency>				
		
				
lab 13 ----------------------Spring cloud config

lab 14 ----------------------currency conversion/exchange microservices

1. Currency exchange microservice : This microservice will contains the exchange rate for a Dollar to Ruppess .
It means it will send a response in which the value of 1 dollar is given as 65 ruppess.

2. Currency conversion  microservice : This will convert the currency from Dollar to ruppees . Now this MICRO will call the exchange service to get the exchange rate and use that to multiply it will input dollar and send it back as a response.

						call(getexchange value)
Currency Conversion MICRO -------------------------> Currency exchange MICRO 
											|
											|
											|
											|
											|
											database to save the value .
											
----------------------------MICRO1-------------
	group id : com.in28minutes.microservices
	artifact id : currency-exchange-service
	dependencies : Actuator , devtools  , spring cloud client , web(to make it as an api)											
	
	URL
	http://localhost:8000/currency-exchange/from/USD/to/INR
	
spring.application.name=currency-exchnage
server.port=8000
spring.config.import=optional:configserver:http://localhost:8888
spring.jpa.show-sql=true # this will show all the sqls running 
spring.datasource.url=jdbc:h2:mem:testdb
h2.console.enabled=true #need to see the details of the data in Data base.
spring.jpa.defer-datasource-initialization=true # this will help in not runing the insert data.sql file before the table is created whenevr the app get started.	
	
	Response Structure
	{
	"id":10001,
	"from":"USD",
	"to":"INR",
	"conversionMultiple":65.00,
	"environment":"8000 instance-id"
	}
	
Now connect it to the in memory data base H2 hibernate using JPA framework 
dependencies : h2 and spring boot starter-data-jpa
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>

		<dependency>
			<groupId>com.h2database</groupId>
			<artifactId>h2</artifactId>
		</dependency>


In the bean below imports are important :

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;


url to chck jpa : http://localhost:8000/h2-console

the bean we  created will be annotated as @Entity  and Id as @Id so that the JPA will create a table out of that .
we know that 'from' is a keyword in sql query so using an attribute in entity as from is a syntax error.
so change those .
Now create a data.sql(specific name) in src.main.resources folder. whenever the app starts it will run this file to insert the data into the table .
	
Now create a iterface  (@repository)	extending jparepository to connect to the h2 database.

NOTE**** : WHENEVR WE WANT ANY QUERY TO BE RUN ON DB USING THE INTERFACE  , WE CAN SIMPLY ADD THE METHOD AND PASS IN THE PARAMETERS , THEN JPA WILL CREATE A SQL QUERY OUT OF IT AND FETCH THE DATA FROM YOU .	
	
	
	
	
	
----------------------------MICRO1-------------
	
----------------------------MICRO2-------------
	
	URL
http://localhost:8100/currency-conversion/from/USD/to/INR/quantity/10



Response Structure
{
  "id": 10001,
  "from": "USD",
  "to": "INR",
  "conversionMultiple": 65.00,
  "quantity": 10,
  "totalCalculatedAmount": 650.00,
  "environment": "8000 instance-id"
}
 
 server.port=8100
spring.application.name=currency-conversion


We will call the currency-exchange-service from currency-conversion using RestTemplate class 
      HashMap<String,String> uriVariables = new HashMap<>();
        uriVariables.put("from",from);
        uriVariables.put("to",to);
            ResponseEntity<CurrencyConversion> forEntity = new RestTemplate().getForEntity("http://localhost:8000/currency-exchange/from/{from}/to/{to}", CurrencyConversion.class,
                    uriVariables);
        CurrencyConversion currencyConversion = forEntity.getBody();
		
		
Now the bean model of currency-exchange-service is subset of bean model of currency-conversion , so the response coming from currency-exchange-service will get mapped to values to bean model of currency-conversion and we used that to create (multiple) whatever to create new currency-conversion object to return .


FEIGN : --- MAKES IT REALLY EASY TO MAKE A REST CALL TO THE API  This is much easier then the resttemplate 

Steps : to do in Currency-conversion service from where the service to be called .

1. Add the dep : 
<!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-openfeign -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
    <version>3.0.3</version>
</dependency>

2. Just like we created an interface for the DB using JPA or mongo or any other , we need to create a interface(act as a proxy) Annotating it as @FeignClient(name , url : localhost:8000)
3. Also annotate the Currency-conversion main class as @EnableFeignClient
4. Add the method in the interface for @Getmapping.
		
----------------------------MICRO2-------------

Both of our service is connected where the currency-conversion -----------------. calling ------> currency-exchange-service
																										|
																										|
																										|
																										|
																								Which is calling DB(h2) to get the values .
lab 14 ----------------------currency conversion/exchange microservices
	
	
Lab 15 : -------------- naming srever (Eureka netflix server ) at port 8761-------------	
Steps : 

1. Add dep : Eureak server  , devtools , actuater 
	<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
		</dependency>
2. Annotate main class with @EnableEurekaserver  , this i just like when we created the config server we annotate it as @EnableConfigServer .
		@EnableFeignClient is annotated the main class from where we are using the proxy .
3.	Add name of the app 
	eureka.client.register-with-eureak = false
	eureka.client.fetch-registry = false


Now just we added the config client dep in all other micro , we will be adding the naming eureka client in all micro which wants to register them to the naming server .



Lab 15 : -------------- naming srever (Eureka netflix server )-------------	

lab16 : -------now connect micro to naming server------------
1. Add client dependencies to all micro to be register

	<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
		</dependency>
		
2. Add prop in app.yml file of all micro.
	eureka.client.servieUrl.defaultZone=http://localhost:871/eureka

lab16 : -------now connect micro to naming server------------
	
	
LAB 17 : ------------- load balancing the currency-exchange-service ----------------- using naming server ----------
Steps : 

1. We will use already set up feign to talk to eureka and for that we need to remove the localhost url we gave in @FeignClient(name , url)
	ex : @FeignClient(name="currency-exchange")   ---- > this is enough for the load balancer to work using naming server .
		Note : we already set up the mandate eureak server for this in above steps .
		The eureka.client jar contains 
			spring - cloud -strater -Load balancer code which is doing the switch. use dby feign

LAB 17 : ------------- load balancing the currency-exchange-service ----------------- using naming server ----------	

LAB 18 : ---------------Api gateway :------ 
to contain the common features like authentication , authorization , logging etc.
so all the api hit will go through this api gateway containing the common feature .

Steps : 
1. Add the dep 
	DevTools
Actuator
Config Client
Eureka Discovery Client
Gateway (Spring Cloud Routing)
2. now how it works ?
		Apigatewayurl/micro registered name on naming server / url of the micro to hit 
		
		example : http://localhost:8765/CURRENCY-EXCHANGE/currency-exchange/from/{from}/to/{to}
		
		This will tell the api gateway to talk to eureka client with name CURRENCY-EXCHANGE find it and hit it with currency-exchange/from/{from}/to/{to} url
		
			for that add :  spring.cloud.gateway.discovery.locator.enabled=true=true
							spring.cloud.gateway.discovery.locator.lowerCaseServiceID=true # to make the CURRENCY-EXCHANGE in lowercase 
	

3. app.yml 
spring.application.name=api-gateway
server.port=8765
spring.config.import=optional:configserver:http://localhost:8888/
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka
spring.cloud.gateway.discovery.locator.enabled=true
eureka.instance.hostname=localhost
spring.cloud.discovery.enabled=true
spring.cloud.gateway.discovery.locator.lowerCaseServiceId=true


VERRRY VERRRY IMPORTANT 
	eureka.instance.hostname=localhost	  ADDD THIS TO ALL THE MICRO WHICH ARE REGISTERED TO EUREKA 
---------------------ROUTING THING IT --- uRLS ------------------------	
	Initial

- http://localhost:8765/CURRENCY-EXCHANGE/currency-exchange/from/USD/to/INR

- http://localhost:8765/CURRENCY-CONVERSION/currency-conversion/from/USD/to/INR/quantity/10

- http://localhost:8765/CURRENCY-CONVERSION/currency-conversion-feign/from/USD/to/INR/quantity/10



Lower Case  : BCSE OF spring.cloud.gateway.discovery.locator.lowerCaseServiceId=true

- http://localhost:8765/currency-exchange/currency-exchange/from/USD/to/INR

- http://localhost:8765/currency-conversion/currency-conversion/from/USD/to/INR/quantity/10

- http://localhost:8765/currency-conversion/currency-conversion-feign/from/USD/to/INR/quantity/10




LAB 18 : ---------------Api gateway :------ 



LAB 18 : ---------------Api gateway CUSTOM ROUTES MEANS USE URL AS PER YOUR NEED . THE API GATEWAY WILL MAPP IT TO THE RIGHT ONE IN BACK END  :------ 

@Configuration
public class ApiRouteConfiguration {

    /**
     * this function will help us to map a url for path parameter.
     * @param routeLocatorBuilder
     * @return
     */
    @Bean
    public RouteLocator gatewayRouter(RouteLocatorBuilder routeLocatorBuilder)
    {
        return routeLocatorBuilder.routes().
                route(p -> p.path("/get")
                        .filters(f -> f.addRequestHeader("MYheadre","Header")
                                .addRequestParameter("FirstParm","myparam"))
                                .uri("http://httpbin.org:80"))
                .route(p -> p.path("/currency-exchange/**")
                .uri("lb://currency-exchange"))
                .route(p -> p.path("/currency-conversion/**")
                        .uri("lb://currency-conversion"))
                .route(p -> p.path("/currency-conversion-feign/**")
                        .uri("lb://currency-conversion"))
                .route(p -> p.path("/currency-conversion-new/**")
                        .filters(f ->f.rewritePath("/currency-conversion-new/(?<segment>.*)",
                                "/currency-conversion-feign/${segment}"))
                        .uri("lb://currency-conversion"))
                .build();
    }
}

Custom Routes

- http://localhost:8765/currency-exchange/from/USD/to/INR

- http://localhost:8765/currency-conversion/from/USD/to/INR/quantity/10

- http://localhost:8765/currency-conversion-feign/from/USD/to/INR/quantity/10

- http://localhost:8765/currency-conversion-new/from/USD/to/INR/quantity/10


LAB 18 : ---------------Api gateway CUSTOM ROUTES MEANS USE URL AS PER YOUR NEED . THE API GATEWAY WILL MAPP IT TO THE RIGHT ONE IN BACK END  :------ 


LAB 19 : --------------------------------------Global filters :
Logging framework

LAB 19 : --------------------------------------Global filters :

LAB 20 : -----------Circuit breaker/failover/retry/rate limit  ----------------

		M1-----------> M2----------> M3-----------> M4-------------> M5
		
		
resilience4j.bulkhead.instances.default.maxConcurrentCall=10
resilience4j.ratelimiter.instances.default.limitForPeriod=2
resilience4j.ratelimiter.instances.default.limitRefreshedPeriod=10s
resilience4j.retry.instances.sample-api.maxRetryAttempts=4
resilience4j.retry.instances.sample-api.waitDuration=1s
resilience4j.retry.instances.sample-api.enableExponentialBackoff=true		

1. Resilience4j is the tool for circuit break and failover condition to recover from.
It is an open-source resilience library by Netflix. It provides latency and fault tolerance in a distributed system. It improves the overall resilience of the system by isolating the failing services and stopping the cascading effect of failures. It provides features like circuit break and fallback.

steps : 
1. dep to add 
	AOP 
	resilience4j
	<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-aop</artifactId>
		</dependency>
		<dependency>
			<groupId>io.github.resilience4j</groupId>
			<artifactId>resilience4j-spring-boot2</artifactId>
		</dependency>
2. Create a controller which have a get mapping function 
		write a failed rest call from it 
3. We can use @Retry (name="sample-api",fallBackMethod="methodname")
4. Add below prop in app.yml


retry ---------------------------

@Retry (name="sample-api",fallBackMethod="methodname")

# will go for max retry of 4 the default is 3 
resilience4j.retry.instances.sample-api.maxRetryAttempts=4  
# The wait time between each retry 
resilience4j.retry.instances.sample-api.waitDuration=1s
# the wait time increase exponentially .
resilience4j.retry.instances.sample-api.enableExponentialBackoff=true
retry ---------------------------

Circuit breaker : ----------------
IF the M4 IS DOWN then the resilience ciscuit breaker feature will know that oops M4 is down so why loading more request to it .
Lets break the circuit and send a default response back .

@CiscuitBreaker(name="sample-api",fallBackMethod="methodname")

There are three states of circuit breaker 

		closed(will send all requests to Micro) ----------------------> open (will not send any request to dead Micro)
						   /\														|
							|                                                       |
							|                                                       |
							|                                                       |
							-----------------half_open (kuch % req will send)<-------


Circuit breaker : ----------------


		
Rate limiter : ----------------

To limit the number of calls to come in 
resilience4j.ratelimiter.instances.default.limitForPeriod=2

resilience4j.ratelimiter.instances.default.limitRefreshedPeriod=10s

@RateLimiter(name="default")



Rate limiter : ----------------

Bulkhead: ----------------

@Bulkhead(name="default")

resilience4j.bulkhead.instances.default.maxConcurrentCall=10

Bulkhead : ----------------

LAB 20 : -----------Circuit breaker/failover/retry/rate limit  ----------------


-----------------Docker -------------------------------
1. container : an isolated space or a process which runs your application which is dynamic version
2. image : that contain the jar file for a java code , the runtime (jdk ) and run on top of the os stack . its a set of bytes .
3. registry container hub.docker.com 
4. docker engine : manage the images , registry and running containers and also help in cretaing the images and pushing it to docker registry.. It receives the command from docker client for all these activities.
		when we run docker run , the engine check the images availability on system and then go forward for run or to download from registry .

commands : 
1. docker run -p 5000:5000 in28min/todo-rest-api-h2:1.0.0.RELEASE : ------------------ to run the image to create a container .
	When you run the image , its a separate system(isolated from base machine) so you need to map the port to access it.
	-p is the argumemt to map the port of base machine to the port of container which is a seperate isolated system .
		-p (hostport/basemachine):containerport
sudo service docker status ----------------------------------------------------- after installation  will tell the running docker engine service status 
sudo service docker stop
sudo service docker start
sudo service docker restart
docker events ------------------------------------------------------------------ will shw the events (create stop etc )
docker stats : ---------------------------------------------------------------- will show the mem use
docker system df  : ------------------------------------------------------------ how much container , volumens et 
docker info -------------------------------------------------------------------- will give permission denied . the ubuntu user is not in docker group
sudo docker info --------------------------------------------------------------- will give docker installation info
sudo usermod -aG docker ubuntu  ------------------------------------------------ Add ubuntu user id in docker group and reconnect linux 
docker images ------------------------------------------------------------------ to see the images
docker pull ubuntu ------------------------------------------------------------- will pull image ubuntu latest version(official image) .
docker run --name myubuntu ubuntu----------------------------------------------- you can specify the name of the container
docker pull ubuntu:16.04 ------------------------------------------------------- will pull ubuntu 16.04 version where 16.04 is a tag
docker run hello-world --------------------------------------------------------- helloworld is an image and command will create a container on docker engine
docker logs -f imageid : -------------------------------------------------------- to tail te logs of the container app
docker client told ---- docker daemon/engine ---- downloaded image hello-world ---- creates a container --- docker daemon sends the output of running container to ------ docker client (shows message)
docker run ubuntu -------------------------------------------------------------- ran the container and creats the container and existed by not showing  the container(empty container os / only bash program).
docker 
docker ps(docker container ls) ---------------------------------------------------------------------- will show you the list of running container
docker ps -a (docker container ls -a )------------------------------------------------------------------- will show all container (stopped , running).
docker run -it centos ---------------------------------------------------------- you will go into container in interactive mode(start and make connection).
cat /etc/system-release -------------------------------------------------------- will open a file system-release shows the os (output : CentOS Linux release 7.6.1810 (Core))
uname -a ----------------------------------------------------------------------- to see the kernel (centos container uses : Linux 7003536d015c 4.15.0-1044-aws #46-Ubuntu SMP Thu Jul 4 13:38:28 UTC 2019 x86_64 x86_64 x86_64).
exit --------------------------------------------------------------------------- after -it if you exit the container stops
docker run -itd centos---------------------------------------------------------- will send the running container to background and your cursor will on the base VM.
docker run -p 5000:5000 -d -restart=always imagename : ------------------------- This will restart the container once the engine restart 
docker run -p 5000:5000 -d -restart=always  -m 512m imagename : ------------------------- -m how much of mem to allow  
docker run -p 5000:5000 -d -restart=always -m 512m --cpu-quota 5000 imagename : ------------------------- --cpu-quota how much cpu 

docker exec -it container-id ls ------------------------------------------------ exec and -it will create an interactive tunnel to run shell command on container
docker exec -it container-id bash----------------------------------------------- it will lead you to inside the container (container-id you will get after running image docker ps(will give container-Id) )
apt install apache2 ------------------------------------------------------------ once you go inside of container using exec bash install apache2
service apache2 status---------------------------------------------------------- get the status
service apache2 start----------------------------------------------------------- start the apache service
docker commit container-id New-Name -------------------------------------------- will create a new image out of running container. Not ideal way to create image . USE DOCKER FILE
docker stop container-id-------------------------------------------------------- Its stop state but is not removed.
docker kill container-id :------------------------------------------------------ it will kill the container at once .
docker start container-id------------------------------------------------------- It will start the same container which is in stop state
docker run -it New-Nameimage---------------------------------------------------- it will create a container with apace2 installed already 
docker rm container-id---------------------------------------------------------- it will remove the container but first stop it using docker ps -- > then docker stop container-id
docker rm -f  $(docker ps -a -q)------------------------------------------------ it will remove all running container 
docker container prune---------------------------------------------------------- will remove all container in stopped state
docker  image prune -a --------------------------------------------------------- will remove all images 
docker rmi image-id ------------------------------------------------------------ will remove the image with that image id.
docker image history imagename-------------------------------------------------- to check the layer COPY , CMD command level .
docker inspect imagename : -----------------------------------------------------json view of images (env , java home  all that stuff , folder strc)
docker login ------------------------------------------------------------------- login to docker hub (user defined images always starts with username/imagename . docker push image-id will not work)
docker tag imagename dockerhub-username/imagename ------------------------------ rename the image to preferred one
docker push dockerhub-userid or dockerid/repo:imagename---------------------------------------- push the image to docker hub(docker push harmeet24011992/myrepo:imagename)
example : docker image push harmeet24011992/myrepo:firstimage_1.0.2.RELEASE   
docker cotainer unpause/pause containerid :------------------------------------------------------------------------- will pause/unpause the app.
docker container inspect :------------------------------------------------------------------------------------------ info about the container (status , port binding , volume )
docker pull reponame/imagename
docker file:-------------------------------------------------------------------- all steps we did , we can write line by line in docker file and just run the yaml file(best way to create image)
FROM ubuntu---------- -----------------------------------------------------------means we need base image
RUN apt-get update
RUN apt-get install apache2 ----------------------------------------------------- to run command on base image on which we will be installing apache2
ADD . /var/www/Html ------------------------------------------------------------- to add a file. there is a dot(.) which shows current folder files will be add to html
ENTRYPOINT apachectl -D FOREGROUND  or CMD apachectl -D FOREGROUND--------------- Run command on container initialize or  Run command on container starts
ENV DEVOPS INTELLIPAAT----------------------------------------------------------- Create ENV variable
copy / export ------------------------------------------------------------------- check what is it
docker build -t harmeet2401/myimagefromdockerfile .  ---------------------------- command to run docker file to create image
docker push harmeet2401/myimagefromdockerfile
docker run -itd -p 80:80 harmeet2401/myimagefromdockerfile  --------------------- 80:80(host machine-port : container-port)
docker create volume demo-vol---------------------------------------------------- create a volume (pendrive).
docker volume ls ---------------------------------------------------------------- to check the number of pendrives(volumes)
docker run -it --mount source=demo-vol,destination=/app/myspace/ -d unbuntu------ to attach the volume (pendrive) to you container . this command will creates a volume and attached to a folder /app/myspace/ inside new container
docker exec -it container-id bash ----------------------------------------------- go inside new container to run commands do [ls] you will found /app/yspace folder create and file and share it with other container
docker run -it --mount source=demo-vol,destination=/demo/ -d unbuntu------------- launch a new container mounted same volume(pendrive) attached to /demo/ folder 
docker exec -it container-id bash -----------------------------------------------go inside of the container and do [ls] you will find demo folder containing same file present in old container folder /app/myspace/ 
docker run -it -v /home/ubuntu/mount/:/app/ -d ubuntu --------------------------- this will mount the folder on you host machine [BIND MOUNT] be specific of your folder
docker run -it -v /home/ubuntu/mount/:/myspace/ -d ubuntu ----------------------- this is another container (above and this conatiner will get the file present in /home/ubuntu/mount)[BIND MOUNT] be specfic of your folderdo
docker volume rm demo-vol-------------------------------------------------------- to remove the volume
sudo curl -L "https://github.com/docker/compose/releases/download/1.23.1/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose----------- to install docker compose (used to deploy application with multiple container(microservices))
sudo chmod +x /usr/local/bin/docker-compose ------------------------------------- to make its access to execute 
docker-compose version ---------------------------------------------------------- to get the version of docker compose (LEARN ABOUT YAML FILES WHICH CONSISTS OF (MAP AND LISTS))
docker-compose.yml :
version: '3'
services:
  sample1:
    image: 'centos'
  sample2:
    image: 'ubuntu'
  sample2:
    image:  httpd
    ports:
      - "80:80"
docker-compose up -d ------------------------------------------------------------- will download images run multiple containers	  
docker-compose down  ------------------------------------------------------------- it will shutdown the service 
docker run -it --name container1 -d ubuntu --------------------------------------- set the name of the container for linking the containers
docker run -it --name container2 --link container1 -d ubuntu---------------------- linked with container1 on network
docker exec -it container2-id bash ----------------------------------------------- do cat etc/hosts/ , you will find new entry of container1's IP
root ==   apt-get update 
		  apt-get install iputils-ping-------------------------------------------- install ping on container 2 for pinging container1 after linkage
		  ping container1 -------------------------------------------------------- will send you reposne
docker run -it --name container3 --link container2 -d ubuntu --------------------- linking 3rd to 2nd

docker swarm init --advertise-addr=13.233.111.89 --------------------------------- launches a docker swarm master (if your node already part of swarm : docker swarm leave --force).
docker swarm join --token SWMTKN-1-5tyc8iih06c97qflvt0x7pozvuda755ft514gykil7v3p00ctr-1bn8yczjl8n1zmyqfdq3oxmwc 13.233.111.89:2377 ----------------- go to any node , install docker and run this command . take an image of your AWS instance(docker swarm leave --force) to leave a swarm
sudo apt-get install docker.io---------------------------------------------------- launch a new instance and install docker on slave instance
docker node ls ------------------------------------------------------------------- will list the nodes with star or something run this on manager
docker service create --name nam-of-service --replicas nummber-of-replicas 	-p (for port)  image-name ---------------------------------- creates a service
docker service create --name nginx --replicas 3 -p 80:80 nginx
docker service ls ----------------------------------------------------------------- list the service
docker ps  ------------------------------------------------------------------------ on master you will see 1 or 2 containers of nginx
docker ps ------------------------------------------------------------------------- on slave you will see one container of nginx
docker stop container-id	------------------------------------------------------- on master , it will create a new container auto in other slave. thats what swram is
docker network -------------------------------------------------------------------- now above swarm kept containers on different computers.. then we use docker network
docker nework create -d overlay my-overlay----------------------------------------- create a netwrokd
docker service create --name website --replicas 3 --network my-overlay --publish 80:80 hshar/webapp------------------- publishing network
docker service rm service id  ----------------------------------------------------- docker service  ls to get the id 
docker service create --name db --replicas 1 --network my-overlay hshar/mysql:5.6
mysql -u root -p intelli

-------------------docker command -----------------------------------

------------------docker images ---------in java microservices -------------------


steps 

------------------------zipkin distributed tracing system  server using docker ------------------
1. docker run -p 9411:9411 openzipkin/zipkin:2.23




2.  connect all micro to zipkin 
	Add dep 
		sleuth : to generate a unique id for a single transaction 
		sleuth-zipkin
		spring rabbit MQ : to get the message in Queue its a queing framework 
3. sample configuration : to sample small % of request , sampling all req will be performance issue .
	spring.sleuth.sampler.probability=1.0
4. run ur app post that and run a get req and refresh zipkin and run query 

------------------------zipkin db server------------------

	




---------------------------------images creating using pom for java -----------------https://github.com/in28minutes/spring-microservices-v2/tree/main/04.docker
steps : 

1. use maven plugin alrady in pom of yours spring >2.3

			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
				<!--this config below help in creating the image for this app  -->
				<configuration>
					<image>
						<name>harmeet24011992/mmv2-${project.artifactId}:${project.version}</name>
					</image>
					<pullPolicy>IF_NOT_PRESENT</pullPolicy>
				</configuration>
				<!--this config below help in creating the image for this app  -->
			</plugin>

2. Now right click on project -------> maven build -----> goal = spring-boot:build-image -dskipTests
		In intellij you can directly run from plugin and run spring-boot:build-image 

3. do above steps for all 4 apps 
	a. docker run -p 8000:8000 meet14764/mmv2-currency-exchange-service:0.0.1-SNAPSHOT
	b. docker run -p 8100:8100 meet14764/mmv2-currency-conversion-service:0.0.1-SNAPSHOT
	c. docker run -p 8765:8765 meet14764/mmv2-api-gateway:0.0.1-SNAPSHOT
	d. docker run -p 8761:8761 meet14764/mmv2-naming-server:0.0.1-SNAPSHOT
	
	meet14764 is the docker id , need to create that as old images are not getting updated.

4. We can directly push the image to docke hub 

	docker login 
	docker push meet14764/mmv2-currency-exchange-service:0.0.11-SNAPSHOT

---------------------------------images creating using pom for java -----------------


-------------------------docker compose -------------------------------------
docker-compose up 

----------compose file 

Some terms :

1. environment variable : we can set the environment variable in yaml file to inject the value to the application.properties file of the service.
2. network : for theentire arch to be connected 
3. -ports : to map the port of hostmachine to container pod 
4. -mem_limits : to set the mem limit for the container to run 
5. services : the very first tag for the services/Microservice to be part of 
6. depends_on : we can mention the service on which the patent service depends on 



-------------------------docker compose -------------------------------------



------------------docker images ---------in java microservices -------------------


----------------------Kuberenetes-------------------------------------------------------------------

Kubernetes is a container orchestation tool . Which helps in monitoring and managing the container instances running on a host machine.

The features include : 
	scaling up /down
	load balancing
	Maintain the instances running .

There are three services available in the market : 
	AKS : azure kubernetes service (Azure platform )
	EKS : Elastic kubernetes service(AWS platform)
	GKS : Google Kubernetes service(Google) provided by the google cloud platform (GCP)

We will be using GKS by creating the account that will give us free tier to practice kubernetes .

Small example of :
create a dep
run the dep 
autoscale the dep
delete one pod and get other up immediately
create new release version out of the running dep without bringing current one down.

GCP ACCOUNT  : login to it : https://console.cloud.google.com/kubernetes/deployment/us-central1-c/in28minutes-cluster/default/hello-world-rest-api/overview?project=proud-portfolio-324718

meet14764
Gogi@12345


----------------Kubernetes cluster------------------
Manager : manage the nodes , one or more master nodes are managers  , typically one is there .
Cluster consists of nodes 
K8S is KUBERNETES


Node :  Node is a worker node in Kubernetes. Each node will have a unique
     identifier in the cache (i.e. in etcd).
	 
Pod : Pod is a collection of containers that can run on a host. This resource is
     created by clients and scheduled onto hosts.each pod have its own Ip address
			 
CLUSTER 	contain many  	NODE  	contain many      PODS   	contain many       CONTAINERS
        ----------------->        ----------------->         ----------------->
		
Replica set :
     ReplicaSet ensures that a specified number of pod replicas are running at
     any given time.	
		
		
		
in GCP : we can search for KUBERNETES engine -----> enable -----> clusetr -----> create ----> default (3 nodes)

Cluster IP : This will be a private address and doens't have any external IP or public IP address .


Master node : does not contain any app container running on it .
	a. etcd : distributed DB .
	b. kubernetes api server : We were using kubectl ryt ? that is working as we were communicate with KUBERNETESapi server using it .
	c. Scheduler : Is responsible for assigning the container to a pod . randonmly
	d. controller : manage the overall health of cluster . It make sure state of the cluster.
	
Worker node : 
		Kubelet : monitor whats happening on the pod and reports it to master controller .
		kubeproxy : helps in exposing services .
		container runtime : Docker is th emost common runtime to run the container using image .
		
question : 
	we can only run docker container on kubernetes ? Node
	what happn if master goes down ? The app will keep on running .
	
			

STEPS :  
1. First connect to the cluster  : gcloud container clusters get-credentials in28minutes-cluster --zone us-central1-c --project proud-portfolio-324718
2. kubectl : kube controller is an (CLI)command to interact with the cluster .
	fetaure it does : eployment ,	increase instance  and many other things 
	command : 
			a. create dep : kubectl create deployment hello-world-rest-api --image=in28min/hello-world-rest-api:0.0.1.RELEASE 
			b. expose dep : kubectl expose deployment hello-world-rest-api --type=LoadBalancer --port=8080			
			
----------------kubernetes cluster------------------

	
	
---------------------Commands--------------------------------------------------------------------------------------
docker run -p 8080:8080 in28min/hello-world-rest-api:0.0.1.RELEASE
 
kubectl create deployment hello-world-rest-api --image=in28min/hello-world-rest-api:0.0.1.RELEASE---------------------------------- created pod , deployment .
kubectl expose deployment hello-world-rest-api --type=LoadBalancer --port=8080----------------------------------------------------- created a service 
	And a load balancer is also created which exposed a front end IP and on the back end we have pods .
kubectl scale deployment hello-world-rest-api --replicas=3 ------------------------------------------------------------------------increase the replicaset for deployment to 3 pods (and will make sure 3 keeps in running)
kubectl delete pod hello-world-rest-api-58ff5dd898-62l9d
kubectl autoscale deployment hello-world-rest-api --max=10 --cpu-percent=70
kubectl edit deployment hello-world-rest-api #minReadySeconds: 15
kubectl set image deployment hello-world-rest-api hello-world-rest-api=in28min/hello-world-rest-api:0.0.2.RELEASE
 
gcloud container clusters get-credentials in28minutes-cluster --zone us-central1-a --project solid-course-258105
kubectl create deployment hello-world-rest-api --image=in28min/hello-world-rest-api:0.0.1.RELEASE
kubectl expose deployment hello-world-rest-api --type=LoadBalancer --port=8080
kubectl set image deployment hello-world-rest-api hello-world-rest-api=DUMMY_IMAGE:TEST
kubectl get events --sort-by=.metadata.creationTimestamp
kubectl set image deployment hello-world-rest-api hello-world-rest-api=in28min/hello-world-rest-api:0.0.2.RELEASE
kubectl get events --sort-by=.metadata.creationTimestamp

command : kubectl get componentstatuses

Output : 

NAME                 STATUS    MESSAGE             ERROR
scheduler            Healthy   ok
controller-manager   Healthy   ok
etcd-1               Healthy   {"health":"true"}
etcd-0               Healthy   {"health":"true"}



kubectl get pods --all-namespaces
 
kubectl get events
kubectl get pods
kubectl get replicaset
kubectl get deployment
kubectl get service
 
kubectl get pods -o wide
 
kubectl explain pods
kubectl get pods -o wide
 
kubectl describe pod hello-world-rest-api-58ff5dd898-9trh2
 
kubectl get replicasets
kubectl get replicaset
 
kubectl scale deployment hello-world-rest-api --replicas=3
kubectl get pods
kubectl get replicaset
kubectl get events
kubectl get events --sort.by=.metadata.creationTimestamp
 
kubectl get rs
kubectl get rs -o wide
kubectl set image deployment hello-world-rest-api hello-world-rest-api=DUMMY_IMAGE:TEST
kubectl get rs -o wide
kubectl get pods
kubectl describe pod hello-world-rest-api-85995ddd5c-msjsm
kubectl get events --sort-by=.metadata.creationTimestamp
 
kubectl set image deployment hello-world-rest-api hello-world-rest-api=in28min/hello-world-rest-api:0.0.2.RELEASE
kubectl get events --sort-by=.metadata.creationTimestamp
kubectl get pods -o wide
kubectl delete pod hello-world-rest-api-67c79fd44f-n6c7l
kubectl get pods -o wide
kubectl delete pod hello-world-rest-api-67c79fd44f-8bhdt
 
gcloud container clusters get-credentials in28minutes-cluster --zone us-central1-c --project solid-course-258105
docker login
docker push in28min/mmv2-currency-exchange-service:0.0.11-SNAPSHOT
docker push in28min/mmv2-currency-conversion-service:0.0.11-SNAPSHOT
 
kubectl create deployment currency-exchange --image=in28min/mmv2-currency-exchange-service:0.0.11-SNAPSHOT
kubectl expose deployment currency-exchange --type=LoadBalancer --port=8000
kubectl get svc
kubectl get services
kubectl get pods
kubectl get po
kubectl get replicaset
kubectl get rs
kubectl get all
 
kubectl create deployment currency-conversion --image=in28min/mmv2-currency-conversion-service:0.0.11-SNAPSHOT
kubectl expose deployment currency-conversion --type=LoadBalancer --port=8100
 
kubectl get svc --watch
 
kubectl get deployments
 
kubectl get deployment currency-exchange -o yaml >> deployment.yaml 
kubectl get service currency-exchange -o yaml >> service.yaml 
 
kubectl diff -f deployment.yaml
kubectl apply -f deployment.yaml
 
kubectl delete all -l app=currency-exchange
kubectl delete all -l app=currency-conversion
 
kubectl rollout history deployment currency-conversion
kubectl rollout history deployment currency-exchange
kubectl rollout undo deployment currency-exchange --to-revision=1
 
kubectl logs currency-exchange-9fc6f979b-2gmn8
kubectl logs -f currency-exchange-9fc6f979b-2gmn8 
 
kubectl autoscale deployment currency-exchange --min=1 --max=3 --cpu-percent=5 
kubectl get hpa
 
kubectl top pod
kubectl top nodes
kubectl get hpa
kubectl delete hpa currency-exchange
 
kubectl create configmap currency-conversion --from-literal=CURRENCY_EXCHANGE_URI=http://currency-exchange
kubectl get configmap
 
kubectl get configmap currency-conversion -o yaml >> configmap.yaml
 
watch -n 0.1 curl http://34.66.241.150:8100/currency-conversion-feign/from/USD/to/INR/quantity/10
 
docker push meet14764/mmv2-currency-conversion-service:0.0.11-SNAPSHOT
docker push meet14764/mmv2-currency-exchange-service:0.0.11-SNAPSHOT
---------------------Commands--------------------------------------------------------------------------------------
	
	
We can install below CLI to  practice the kubernete on google cloud.
GCloud 
kubectl 	
	
	
Now after installation we can use GCloud to connect to our kubernetes cluster . By copying the command from Google cloud UI 
command  : gcloud container clusters get-credentials in28minutes-cluster --zone us-central1-c --project proud-portfolio-324718

Now use java Api to deploy to kubernetes :
https://github.com/in28minutes/spring-microservices-v2/tree/main/05.kubernetes


Lab 1 : ------------- create a deploymeny using image of an API -----------
Steps : 
1. We have commented out the spring cloud config , eureka netflix (naming server join ) , zipkin(tracing ui) and rabbit MQ (queue framework )
2. all above features are diabled as these are provided by the kbernetes.
3. Connect to the cluster of GCP using GCloud command .
4. build the images of api using spring-boot-image:builder for docker 
5. then push the images to docker hub using 
	docker login 
	docker push dockerid/imagename:tag
	
3. KUBERNETES commands to pull the images and create a deployment
	kubectl create deployment currency-exchange --image=meet14764/currency-exchange-service:0.0.11-SNAPSHOT
	kubectl expose deployment currency-exchange --type=LoadBalancer --port=8000
	kubectl get svc --watch 
	kubectl get pods
	kubectl get replicasets
	kubectl get services 
	
	kubectl create deployment currency-conversion --image=meet14764/currency-conversion-service:0.0.11-SNAPSHOT
	kubectl expose deployment currency-conversion --type=LoadBalancer --port=8100
	kubectl get svc --watch 
	kubectl get pods
	kubectl get replicasets
	kubectl get services 
	
4. Once it is done 
	use the loadbalancer IP 
	Currency Exchange Service kubernetes
- http://loadbalancerIp:8000/currency-exchange/from/USD/to/INR

Currency Conversion Service kubernetes
- http://loadbalancerIp:8100/currency-conversion-feign/from/USD/to/INR/quantity/10

Lab 1 : ------------- create a deploymeny using image of an API -----------


lab 2 : ------------- Declarative approach : Update the deployment of running dpeloyment --------------------

steps : 
1. get the deployment in a deployment.yaml file 
	kubectl get deployment currency-exchange -o deployment.yml
2. get the service deployment in a service.yml file
	kubectl get service currency-exchange -o service.yml
3. Merge both the yamls in a common file separated by    ---
4. check the diff after changing the replica value for example  ,kubectl diff -f  deployment.yml
5. Then apply the updated yaml : kubeclt apply -f deployment.yml
6. post applying the yaml we will get the new desired state with changed replica for currency-exchange pods.




lab 2 : ------------- Update the deployment of running dpeloyment --------------------	


Lab 3 : ------------- Clean up yaml for kubernetes-----------


Rolling update : one pod update at a time.
Lab 3 : ------------- Clean up yaml for kubernetes-----------

Lab 4 : -------------Tracing logs and api actvation on GCP ----------

steps : 

1. Search for Api and Services on GCP. ------ > Enable apis and services .----> logging ---> cloud logging api ----> enable it .
																	   ----> stackdriver ---> enable all driver api 															   
2. kubectl delete all -l app=hello-world-rest-api
3. kubectl get all : --- to get all the artefacts of the deplyment if any 
4. kubectl apply -f deployment.yml : ------- > create a deployment and srevice using the yaml . As we created using the create and expose command 
5. now change anything in the yaml file and run : kubectl apply -f deployment.yml .

			NICEEEEEEEEEEEEEEEEEEEEEEEEEEEE!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
																   

Lab 4 : -------------Tracing logs and api actvation on GCP ----------
	
	

Lab 5 : -------------Custom Environment variables ---------------------

As we know when the currency-exchange pod comes up kubernete will create some env variables . 
which also include  : CURRENCY_EXCHANGE_SERVICE_HOST  , HOSTNAME(pod name )

The env var is used by the currency-conversion for feign hit .



Lab 5 : -------------Custom Environment variables ---------------------

lab 6 : --------------centralized configuration ------------------
As we are hardcoding the env variable value in yaml file , which results in redeploy the yaml whenever the ENV variable value changes .
So KUBERNETES provides centralized config set up .
steps : 
1. kubectl create configmap hello-world-rest-api --from-literal= HELLOW-WORLD-STRING-MESSAGE="ola bom dia"

apiVersion: v1
data:
  MESSAGE_STRING: BOMDIA
kind: ConfigMap
metadata:
  name: hello-world-rest-api
  namespace: default


lab 6 : --------------centralized configuration ------------------


lab : 7 :------------centralized logging in GKE which is in Google platform -------------
We can aggregate the logs to GKE cluste .

View logs : 
https://console.cloud.google.com/logs/query;query=resource.type%3D%22k8s_container%22%0Aresource.labels.pod_name%3D%22hello-world-rest-api-dcf9cc87d-x67jd%22%0AtextPayload:helloWorld;cursorTimestamp=2021-09-06T18:44:01.429354916Z?project=proud-portfolio-324718

We can also run queries on the pods logs as the logs for all the pods gets accumulated in the KUBERNETES clusters.


View Dashboard : 
This will show all the metrics from services till container level .

lab : 7 :------------centralized logging in GKE which is in Google platform -------------


lab : 8 :------------Microservice Deployment  -------------

1. Rollout(means make present up and running and then bring other pods down) history deployment of kubernetes cluster using deployment .
2. In case we made a deployment change and do a wring deployment like invalid image . Then kubernetes will keep the old pods running untill new one comes up correctly 
command : 
1.  kubectl rollout history deployment hello-world-rest-api ------------------------------------------------------ To check the rollout history for deployment 
2. kubectl rollout undo deployment hello-world-rest-api  --to-revision=1  ---------------------------------------- to bring the deployment to the stable version .
3. While going from one to other deployment while making the chnage , there will be a DOWNTIME .

lab : 8 :------------Microservice Deployment  -------------


lab : 9 :------------ OVERCOME THE DOWNTIME -------------
Probes and readiness provide by kubernetes

Probes : a health check hit to the service 

Two kinds : 
	readiness probes : K8 sends these probes if un-successfull then no traffic will be send to the micro/
	liveliness probes  : K8 sends these probes if un-successfull then pods will be restarted.

Spring boot Actuator : provide these readiness .
		We have been adding these since .
steps : 
			1. Add prop in app.yml of micro which we will deploy .:
				management.endpoint.health.probes.enabled=true
				management.health.livenessStage.enabled=true
				management.health.redinessStage.enabled=true
			2. localhost:8080/actuator/health : 	
					This will give {status  : "up" ,groups : ["liveness","readiness"] }
			3. localhost:8080/actuator/health/liveness
			4. localhost:8080/actuator/health/readiness
			5. We can use above probes to get configured in k8 for health check .
				need to update the deployment.yaml for it :
		readinessProbe:
          httpGet:
            port: 8080
            path: /actuator/health/readiness
        readinessProbe:
          httpGet:
            port: 8080
            path: /actuator/health/liveness 
			
			6. post adding above is we can change the version , then the health probe will overcome the DOWNTIME .
				AND KEEP ON SENDING THE PROBE TO OLD PODS . ONCE NEW POD IS READY TO RECEIVE TRAFFIC IT WILL DELETE OLD PODS.



lab : 9 :------------ OVERCOME THE DOWNTIME -------------


lab : 10 :------------ Auto scaing  -------------
kubectl autoscale deployment currency-exchange --min=1 --max=3 --cpu-percent=5  ------ this will create horizontal pod auto scaler : this will add new pods when the cpu-% is greater tham 5 % .

kubectl delete hpa hello-world-rest-api ---------------- will delete the hpa horizontal pod auto scaler which was sole responsible for scaling the pod.

lab : 10 :------------ Auto scaing  -------------


	
----------------------Kuberenetes-------------------------------------------------------------------	
	