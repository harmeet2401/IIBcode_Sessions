https://yourlearning.ibm.com/channel/CNL_LCB_1618900946000 ------------------- 


ENV setup steps for Labs : 

Git hub  :-----------------------------------------------------------------------

Creds for Git repo : https://github.com/harmeet2401/IIBcode_Sessions
username : harmeet2401
password : Gogi!321

token : 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

Git hub  :-----------------------------------------------------------------------


quay.io : -----------------------------------------------------------------------

username : harmeet_singh4
Password: Narinder@667335424

repo name : testrepo

quay.io : -----------------------------------------------------------------------


lab Environment : ---------------------------------------------------------------

Username	whknkc
Password	RHT_OCP4_DEV_PASSWORD	cad14e5aa9e849e7bc30
API Endpoint	RHT_OCP4_MASTER_API	https://api.ap46a.prod.ole.redhat.com:6443
Console Web Application		https://console-openshift-console.apps.ap46a.prod.ole.redhat.com
Cluster Id		1e69d923-f37c-4eaf-9658-41d317640b71


Workstation : username and password--------------
username : student 
password : student 


lab Environment : ---------------------------------------------------------------





1. Why we need the containerisation technology ?
- In traditional OS where we have a single host machine and single VM on a single machine . The shared libereries and dependencies are entangled with the OS installd on top of the OS of host machine .
- Difficulty arrised in Traditional OS architecture : 
  . Can not update or patch the base OS bcse it might update the shared libs and dependencies which might impact the application running .
  . Shared liberaries are utilized equally among many applications running on the same host which can also impact one app running in case we need update in shared lib for another app.
- Container solutions : 	
	Which includes containerisation and allo each app to be deployed in a separate container have its own OS and Liberaried to be used in the applications.
	Also make isolation for security , storage and network.
	container engines available to manage and execute individual containers, including Rocket, Drawbridge, LXC, Docker, and Podman.
	
****IMP : Podman is available in redhat 7.6x version


2. Image : image is a file-system bundle that contains all dependencies required to execute a process: files in the file system, installed packages, available resources, running processes, and kernel modules.

3. Podman is used for interaction with the container tech . We can build or pull th eimage using podman . Its an opensource and it keeps the images into the local repository which overcome the need of client/server architecture and remove the dependencies of daemon thread running on it .
 It has similar syntax of command as the Docker , so no need to learn new tool 
 
4. Limitations os container : 
	.As the number gross for containers in a system , managing the containers which includes (restarting , starting , killing , updating the liberaries etc ) become difficult .
	.In production env the customer wants to execute :
			- auto renewal of the os or lib in the container which can be done by mean of roll-outs etc
			- each orchestration which include maintaing the desired number of containers running .
			- easy resource management across the containers on the base machines
			-  easy scale up and scale down as per the traffic coming or resource utlization 
5. For above issues : Kubernetes is introduced for orchestration of the containers . We can deploy the container across the multiple nodes of kubernetes and allow kubernetes to maintain the count of the container , rolling out new deployments when a change occurs in source code etc

		K8 features :
			Service discovery and load balancing
			Horizontal scaling
			Self healing 
			Automated rollout
			Operators
Operators are packaged Kubernetes applications that also bring the knowledge of the application's life cycle into the Kubernetes cluster. Applications packaged as Operators use the Kubernetes API to update the cluster's state reacting to changes in the application state.


6. Rootless container : 
	As we know many of the containers are created by running th image as a root user user . Most of the images in docker.io runs through the root users.
	But podman and RedhatOpenshift runs container with root users by default.
	
	Commands : 
		1. First run the container and bash to it using the sudo command to run the container as a root user : 
			here you saw that the bash and run command ran is under root user .
			 [student@workstaion ~]$ sudo podman run --rm --name asroot -ti registry.access.redhat.com/ubi8:latest /bin/bash
			 [root@containerID / ]# whoami
			 root 
			 [root@containerID / ]# sleep 1000
			 [student@workstaion ~]$ sudo ps -ef | grep "sleep 1000"  ------------ > run this in a different terminal
			 root        3137    3117  0 10:18 pts/0    00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1000
		
			 [root@containerID / ]# exit 
			 
		2. Second run the container and bash to it using the normal command to run the container as a normal user : 
			here you saw that the bash and run command ran is under student user . which is the normal user .
			 [student@workstaion ~]$ podman run --rm --name asuser -ti registry.access.redhat.com/ubi8:latest /bin/bash
			 [root@containerID / ]# whoami
			  root 
			 [root@containerID / ]# sleep 1000
			 [student@workstaion ~]$ sudo ps -ef | grep "sleep 2000" | grep -v grep
			student     3345    3325  0 10:24 pts/0    00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 2000
			
			 [root@containerID / ]# exit 
			 	
		Summary : it means the podman and redhat openshift allow user to run the containers with normAL users .
			 
			
*. Fetching container images using Podman

	a. podman searhc rhel ----------------------------------------- Command to search the image in red hat image repository 
	b. podman pull rhel ------------------------------------------- this will download the image on your local and can use it .
		The image names are based on following syntax : 
		registry_name/user_name/image_name:tag
	c.  podman images --------------------------------------------- this will show us the images present on local 	
	d.  podman run ubi8/ubi:8.3 echo 'Hello world!' --------------- this run command to run the container using the image 
	e.  podman run -d -p 8080 registry.redhat.io/rhel8/httpd-24---- to run a container in bakcground using -d .
	f.  podman port -l--------------------------------------------- to see the container port mapped .
	g.  podman run -it ubi8/ubi:8.3 /bin/bash---------------------- this command will create a container and do a bash inside the running container in interactive mode.
	h.  podman run -e GREET=Hello -e NAME=RedHat ubi8/ubi:8.3 printenv GREET NAME--------- this will inject environment variables into container from outside using "-e"
	i.  podman run --name mysql-custom  -e MYSQL_USER=redhat -e MYSQL_PASSWORD=r3dh4t  -e MYSQL_ROOT_PASSWORD=r3dh4t  -d registry.redhat.io/rhel8/mysql-80
	j.  podman login registry.redhat.io------------------------------------------------------ login to rehat image registry 
	k.  podman run --name mysql-basic -e MYSQL_USER=user1 -e MYSQL_PASSWORD=mypa55 -e MYSQL_DATABASE=items -e MYSQL_ROOT_PASSWORD=r00tpa55 -d registry.redhat.io/rhel8/mysql-80:1
	l.  podman ps --format "{{.ID}} {{.Image}} {{.Names}}" ---------------------------------- to see the running containers.
	m.  podman exec -it mysql-basic /bin/bash ----------------------------------------------- To do the bash to a running container  -it says to go bash mode .
		bash-4.2$ mysql -uroot 
				>enter the password 
				mysql > mysql --version 
	n. lab container-create finish ----------------------------------------------------------On workstation, run the lab container-create finish script to complete this lab.

	
	
	Many Podman flags also have an alternative long form; some of these are explained below:

		-t is equivalent to --tty, meaning a pseudo-tty (pseudo-terminal) is to be allocated for the container.
		
		-i is the same as --interactive. When used, standard input is kept open into the container.
		
		-d, or its long form --detach, means the container runs in the background (detached). Podman then prints the container id.			