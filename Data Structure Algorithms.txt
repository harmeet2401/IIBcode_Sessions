
For beginners, it's essential to start with fundamental data structures and algorithms that form the basis of computer science and software development. Here are some common data structures and algorithms suitable for beginners:

Data Structures:

Arrays: A collection of elements stored at contiguous memory locations. Arrays are fundamental and widely used data structures.

Linked Lists: A linear data structure where elements are stored in nodes. Each node points to the next node in the sequence.

Stacks: A linear data structure that follows the Last In, First Out (LIFO) principle. Elements are inserted and removed from one end, called the top.

Queues: A linear data structure that follows the First In, First Out (FIFO) principle. Elements are inserted at the rear end and removed from the front end.

Trees: A hierarchical data structure consisting of nodes connected by edges. Trees have a root node, parent-child relationships, and may have left and right subtrees.

Graphs: A non-linear data structure consisting of nodes (vertices) and edges that connect these nodes. Graphs can be directed or undirected.

Algorithms:

Sorting Algorithms: BISMQ

Bubble Sort
Insertion Sort
Selection Sort
Merge Sort
Quick Sort

Searching Algorithms:

Linear Search
Binary Search (requires a sorted array)
Recursion: A technique in which a function calls itself to solve subproblems.

Graph Traversal Algorithms:

Depth-First Search (DFS)
Breadth-First Search (BFS)
Dynamic Programming: A technique to solve problems by breaking them down into simpler subproblems and storing the results to avoid redundant computations.

Greedy Algorithms: Algorithms that make locally optimal choices at each step with the hope of finding a global optimum.

Divide and Conquer: A problem-solving strategy that involves breaking a problem into smaller subproblems, solving them recursively, and then combining their solutions.

Backtracking: A technique to solve problems incrementally by making choices and backtracking when a solution cannot be found.

----------------------------------------------------------------------------------------------------------------------------------------------------------------
Explaination and practice :

1. Bubble Sort : ----------------- Works on the comparison of two elements at a time and swap
Here's a step-by-step explanation of Bubble Sort:

1. Start from the beginning of the array.
2. Compare the first two elements. If the first element is greater than the second element, swap them.
3. Move to the next pair of elements, and repeat the comparison and swap process until the end of the array.
4. After the first pass, the largest element will be at the end of the array.
5. Repeat the process for the remaining elements, excluding the last sorted element.
6. Continue until no more swaps are needed, indicating that the array is sorted.

the time complexity of Bubble Sort is O(n^2). used only for theoritical purpose
It's called "Bubble" sort because the larger elements bubble up to the end of the array with each iteration.

public class BubbleSort {
    public static void bubbleSort(int[] arr) {
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    // Swap arr[j] and arr[j + 1]
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
    }

    public static void main(String[] args) {
        int[] arr = {64, 34, 25, 12, 22, 11, 90};
        bubbleSort(arr);
        System.out.println("Sorted array:");
        for (int num : arr) {
            System.out.print(num + " ");
        }
    }
}

2. Insertion sort : --------------------- Works on keeping a key value starting from 1st index and swap 

Here's a step-by-step explanation of Bubble Sort:
1. Start from the second element (index 1) and iterate through the entire list.
2. For each element, compare it with the elements to its left in the sorted portion of the array and check if its greater than or not.
3. Insert the element into the correct position in the sorted portion by shifting elements to the right until the correct position is found.
The time complexity of Insertion Sort is O(n^2) in the worst-case scenario, where n is the number of elements in the array.
However, in the best-case scenario (when the array is already sorted), the time complexity is O(n).
Why it is called insertion sort because a key value is inserted to the right position in the array.
public class InsertionSort {
    public static void insertionSort(int[] arr) {
        int n = arr.length;
        for (int i = 1; i < n; i++) {
            int key = arr[i];
            int j = i - 1;
            // Move elements of arr[0..i-1], that are greater than key, to one position ahead of their current position
            while (j >= 0 && arr[j] > key) { -------> key left se choti hai ke nhi 
                arr[j + 1] = arr[j];    -----------> swap
                j = j - 1; -------------------- to iterate back and compare right element to left 
            }
            arr[j + 1] = key;-----------> swap
        }
    }

    public static void main(String[] args) {
        int[] arr = {12, 11, 13, 5, 6};
        insertionSort(arr);
        System.out.println("Sorted array:");
        for (int num : arr) {
            System.out.print(num + " ");
        }
    }
}

3. Selection sort : ---------------- Works on the minimum value and swap the value using it.
Here's how it works:
1. Find the minimum element in the unsorted subarray. -------------- this is immmpppp first sbse chota first 
2. Compare the right side side element to minimum element and if minimum index value is greater then ritgh element then swap it. 

The time complexity of Selection Sort is O(n^2) in all cases, regardless of the input data, because it always compares and swaps elements. Even if the array is already sorted, it still performs the same number of comparisons as in the worst-case scenario. The number of comparisons is approximately (n^2)/2, and the number of swaps is approximately n.

public class SelectionSort {
    public static void selectionSort(int[] arr) {
        int n = arr.length;
        // One by one move boundary of unsorted subarray
        for (int i = 0; i < n - 1; i++) {
            // Find the minimum element in the unsorted array
            int minIndex = i;
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[minIndex]) {
                    minIndex = j;
                }
            }
            // Swap the found minimum element with the first element
            int temp = arr[minIndex];
            arr[minIndex] = arr[i];
            arr[i] = temp;
        }
    }

    public static void main(String[] args) {
        int[] arr = {64, 34, 25, 12, 22, 11, 90};
        selectionSort(arr);
        System.out.println("Sorted array:");
        for (int num : arr) {
            System.out.print(num + " ");
        }
    }
}

4. Merge Sort : 

Here's how Merge Sort works:

1.Divide: Split the array into two halves.
2.Conquer: Recursively sort each half.
3.Merge: Merge the sorted halves to produce the final sorted array.

public class MergeSort {
    public static void mergeSort(int[] arr, int left, int right) {
        if (left < right) {
            int mid = (left + right) / 2;
            mergeSort(arr, left, mid);      // Sort the left half
            mergeSort(arr, mid + 1, right); // Sort the right half
            merge(arr, left, mid, right);   // Merge the sorted halves
        }
    }

    public static void merge(int[] arr, int left, int mid, int right) {
        int n1 = mid - left + 1;
        int n2 = right - mid;
        
        int[] L = new int[n1];
        int[] R = new int[n2];
        
        for (int i = 0; i < n1; i++) {
            L[i] = arr[left + i];
        }
        for (int j = 0; j < n2; j++) {
            R[j] = arr[mid + 1 + j];
        }
        
        int i = 0, j = 0, k = left;
        while (i < n1 && j < n2) {
            if (L[i] <= R[j]) {
                arr[k++] = L[i++];
            } else {
                arr[k++] = R[j++];
            }
        }
        
        while (i < n1) {
            arr[k++] = L[i++];
        }
        
        while (j < n2) {
            arr[k++] = R[j++];
        }
    }

    public static void main(String[] args) {
        int[] arr = {12, 11, 13, 5, 6, 7};
        int n = arr.length;
        System.out.println("Original array:");
        printArray(arr);
        mergeSort(arr, 0, n - 1);
        System.out.println("\nSorted array:");
        printArray(arr);
    }

    public static void printArray(int[] arr) {
        for (int num : arr) {
            System.out.print(num + " ");
        }
    }
}

4. Quick Sort :--------------------  Works on the pivot element and arrange smaller value on left and larger values on right
It works as follows:

1.Choose a Pivot: Choose a pivot element from the array. The pivot element is used to partition the array into two sub-arrays.
2.Partitioning: Rearrange the elements in the array such that all elements less than the pivot are placed before it, and all elements greater than the pivot are placed after it. After this partitioning step, the pivot is in its final sorted position.
3.Recursion: Recursively apply the above steps to the sub-arrays on the left and right of the pivot until the entire array is sorted.

public class QuickSort {
    public static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            int pi = partition(arr, low, high);

            // Recursively sort elements before partition and after partition
            quickSort(arr, low, pi - 1);
            quickSort(arr, pi + 1, high);
        }
    }

    public static int partition(int[] arr, int low, int high) {
        int pivot = arr[high];
        int i = low - 1;
        for (int j = low; j < high; j++) {
            if (arr[j] < pivot) {
                i++;

                // Swap arr[i] and arr[j]
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }

        // Swap arr[i+1] and arr[high] (pivot)
        int temp = arr[i + 1];
        arr[i + 1] = arr[high];
        arr[high] = temp;

        return i + 1;
    }

    public static void main(String[] args) {
        int[] arr = {10, 80, 30, 90, 40, 50, 70};
        int n = arr.length;
        quickSort(arr, 0, n - 1);
        System.out.println("Sorted array:");
        for (int num : arr) {
            System.out.print(num + " ");
        }
    }
}

Searching algos --------------------------------------------------------------------------------------------
1. Binary Search (requires a sorted array) :

Here's how it works:

1.Initialize: Set the left boundary low to 0 and the right boundary high to the length of the array minus one.
2.Midpoint calculation: Calculate the midpoint index mid as (low + high) / 2.
3.Comparison: Compare the target value with the element at the midpoint.
4.If the target value is equal to the element at the midpoint, return the midpoint index.
5.If the target value is less than the element at the midpoint, search the left half of the array (set high = mid - 1).
6.If the target value is greater than the element at the midpoint, search the right half of the array (set low = mid + 1).
7.Repeat: Repeat steps 2-3 until the target value is found or the search interval is empty (low > high).

public class BinarySearch {
    public static int binarySearch(int[] arr, int target) {
        int low = 0;
        int high = arr.length - 1;
        
        while (low <= high) {
            int mid = low + (high - low) / 2;
            
            if (arr[mid] == target) {
                return mid; // Element found
            } else if (arr[mid] < target) {
                low = mid + 1; // Search right half
            } else {
                high = mid - 1; // Search left half
            }
        }
        
        return -1; // Element not found
    }

    public static void main(String[] args) {
        int[] arr = {2, 3, 4, 10, 40};
        int target = 10;
        int result = binarySearch(arr, target);
        if (result != -1) {
            System.out.println("Element found at index " + result);
        } else {
            System.out.println("Element not found");
        }
    }
}

