
For beginners, it's essential to start with fundamental data structures and algorithms that form the basis of computer science and software development. Here are some common data structures and algorithms suitable for beginners:

Data Structures:

Arrays: A collection of elements stored at contiguous memory locations. Arrays are fundamental and widely used data structures.

Linked Lists: A linear data structure where elements are stored in nodes. Each node points to the next node in the sequence.

Stacks: A linear data structure that follows the Last In, First Out (LIFO) principle. Elements are inserted and removed from one end, called the top.

Queues: A linear data structure that follows the First In, First Out (FIFO) principle. Elements are inserted at the rear end and removed from the front end.

Trees: A hierarchical data structure consisting of nodes connected by edges. Trees have a root node, parent-child relationships, and may have left and right subtrees.

Graphs: A non-linear data structure consisting of nodes (vertices) and edges that connect these nodes. Graphs can be directed or undirected.

Algorithms:

Sorting Algorithms: BISMQ

Bubble Sort
Insertion Sort
Selection Sort
Merge Sort
Quick Sort

Searching Algorithms:

Linear Search
Binary Search (requires a sorted array)
Recursion: A technique in which a function calls itself to solve subproblems.

Graph Traversal Algorithms:

Depth-First Search (DFS)
Breadth-First Search (BFS)
Dynamic Programming: A technique to solve problems by breaking them down into simpler subproblems and storing the results to avoid redundant computations.

Greedy Algorithms: Algorithms that make locally optimal choices at each step with the hope of finding a global optimum.

Divide and Conquer: A problem-solving strategy that involves breaking a problem into smaller subproblems, solving them recursively, and then combining their solutions.

Backtracking: A technique to solve problems incrementally by making choices and backtracking when a solution cannot be found.

----------------------------------------------------------------------------------------------------------------------------------------------------------------
Explaination and practice :

1. Bubble Sort : ------------------------------------------
Here's a step-by-step explanation of Bubble Sort:

1. Start from the beginning of the array.
2. Compare the first two elements. If the first element is greater than the second element, swap them.
3. Move to the next pair of elements, and repeat the comparison and swap process until the end of the array.
4. After the first pass, the largest element will be at the end of the array.
5. Repeat the process for the remaining elements, excluding the last sorted element.
6. Continue until no more swaps are needed, indicating that the array is sorted.

the time complexity of Bubble Sort is O(n^2). used only for theoritical purpose
It's called "Bubble" sort because the larger elements bubble up to the end of the array with each iteration.

public class BubbleSort {
    public static void bubbleSort(int[] arr) {
        int n = arr.length;
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    // Swap arr[j] and arr[j + 1]
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
    }

    public static void main(String[] args) {
        int[] arr = {64, 34, 25, 12, 22, 11, 90};
        bubbleSort(arr);
        System.out.println("Sorted array:");
        for (int num : arr) {
            System.out.print(num + " ");
        }
    }
}

2. Insertion sort : ---------------------------------------------

Here's a step-by-step explanation of Bubble Sort:
1. Start from the second element (index 1) and iterate through the entire list.
2. For each element, compare it with the elements to its left in the sorted portion of the array and check if its greater than or not.
3. Insert the element into the correct position in the sorted portion by shifting elements to the right until the correct position is found.
The time complexity of Insertion Sort is O(n^2) in the worst-case scenario, where n is the number of elements in the array.
However, in the best-case scenario (when the array is already sorted), the time complexity is O(n).
Why it is called insertion sort because a key value is inserted to the right position in the array.
public class InsertionSort {
    public static void insertionSort(int[] arr) {
        int n = arr.length;
        for (int i = 1; i < n; i++) {
            int key = arr[i];
            int j = i - 1;
            // Move elements of arr[0..i-1], that are greater than key, to one position ahead of their current position
            while (j >= 0 && arr[j] > key) { -------> key left se bdi hai ke nhi 
                arr[j + 1] = arr[j];    -----------> swap
                j = j - 1; -------------------- to iterate back and compare right element to left 
            }
            arr[j + 1] = key;-----------> swap
        }
    }

    public static void main(String[] args) {
        int[] arr = {12, 11, 13, 5, 6};
        insertionSort(arr);
        System.out.println("Sorted array:");
        for (int num : arr) {
            System.out.print(num + " ");
        }
    }
}

3. Selection sort : ----------------------------------------
Here's how it works:
1. Find the minimum element in the unsorted subarray. -------------- this is immmpppp first sbse chota first 
2. Compare the right side side element to minimum element and if minimum index value is greater then ritgh element then swap it. 

The time complexity of Selection Sort is O(n^2) in all cases, regardless of the input data, because it always compares and swaps elements. Even if the array is already sorted, it still performs the same number of comparisons as in the worst-case scenario. The number of comparisons is approximately (n^2)/2, and the number of swaps is approximately n.

public class SelectionSort {
    public static void selectionSort(int[] arr) {
        int n = arr.length;
        // One by one move boundary of unsorted subarray
        for (int i = 0; i < n - 1; i++) {
            // Find the minimum element in the unsorted array
            int minIndex = i;
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[minIndex]) {
                    minIndex = j;
                }
            }
            // Swap the found minimum element with the first element
            int temp = arr[minIndex];
            arr[minIndex] = arr[i];
            arr[i] = temp;
        }
    }

    public static void main(String[] args) {
        int[] arr = {64, 34, 25, 12, 22, 11, 90};
        selectionSort(arr);
        System.out.println("Sorted array:");
        for (int num : arr) {
            System.out.print(num + " ");
        }
    }
}
