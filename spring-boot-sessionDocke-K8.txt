Spring boot --------------------------------------------------------------------------------------- UDEMY ------------------------------------------------------------------------

Microservices Design Patterns:
    Integration Pattern:
	  Aggregator : 
	  API Gateway
	Chained or Chain of Responsibility
	Asynchronous Messaging
	2. Database or Shared Data
	Event Sourcing
	Branch
	Command Query Responsibility Segregator
	Circuit Breaker 
	Decomposition : breaking the bigger service to smaller pieces . and connecting those using different design pattern 
	
 1. Decomposition Pattern : in which we are de-coupling the services on the basis of the business unit
 2. Integration  : in this case we have to call and connect the de-coupled servuise uing the api -gateway or aggregator technique
 3. Database service pattern : to Distribute the data on multiple instances in case we neeed to scale up and down .
 4. Cross-cutting pattern : This pattern moslt solve the problem of multiple configuration available for different services on different ENV like , dev , QA , UAT , St and prod .
	To overcome that we include external sentralised repo to collate all configurtion and load those configuration at runtime for each region .
 5. Observatory pattern : In which we need to centralsed the logs generated from differnt services called from the api gateway on different machines.
 

START.SPRING.IO ----- TO CREATE PROJECTS 
DOCS.SPRING.IO ----- TO TAKE REFERENCE FOR ANY FEATURE THAT SPRING / SPRING BOOT PROVIDES.

Download spring tool eclipse plugin for cntrl + space feature in application.yml files

Web service app : The app or technique using which we can provide services using internet to allow app to app interaction and make the 
				Service interoperability(platform in-dependent).
				These service we can expose to other application to consumer the response . so a rest full api that is hosted on to a servers 
				with Http protocol is an example of  it.
				
Parts of a web service (rest api)	:
				Service Definition  : It contains the type of request and response required for the api (The format for it) can be a swagger 
				Request  : Will involve the sample request 
				Response : Will involve the sample response 
				Endpoint  : how to call the web service(api)

Service provider : The web service which is exposed to the internet is the service provider.
Service consumer : is the one which hitting that web service to get the response back. 
Transport : Is the medium using which the data (request and response) will be sent example : MQ , kafka , HTTPs , HTTP.
Message exchange format : The format of the request and response which is exchanged between consumer and provider.

SOAP :---------- Its simple object access protocol it works on top of the HTTP protoocol which is more secure and wrapped the message in to a soap envelop and send it along with the soap headers , for soap we need a wsdl to define the defination file which will contains the sample request , response and url at which we need to trigger the request for 

Its a protocol that allow app to communicate using a defined message structure .
		
		--------------------------------
		
				SOAP ENVELOP
				
				-----------
				 SOAP HEDER
				-----------
				
				-----------
				 SOAP BODY 		

			
			
				 SOAP BODY 		
				-----------
				
				
				
				SOAP ENVELOP
		-------------------------------
		

Soap defines does not impose any restriction on the transport , we can use either http and mq 

A WSDL is create web service definition language that  contains : this is in case of the soap service , for rest service swagger definitionsare widely used.

	The End point 																							End point , request , response and format .
	the operation (delete employee , get employee , update employee data )
	The request structure 
	The response structure.

Soap only involve XML as the message format to exchange request and response .  WSDL are all in XML language which is used in soap service only .
These are defined structure .

	
REST : --------- REpresentational State transfer method/methodology. is developed to make best use of the HTTP protocol . Methodology to make best use of HTTP protocol.
CRUD : Create , read , update and delete this is mostly used in Db access layers.
Safe HTTP methods: get and update 
The HTTP protocol is used to transfer HTML data from consumer to service provider or vice versa. HTTP is hyper text transfer language used to tranfer HTML data. means the data which is send across the HTML page using HTTP proocol 
like we hit the url http://www.localhost.com:8080/Users/user/1/ID  ---> on this url we can send the html data which can be any form of data.

rest contains  : rest APIcontains the format of message(request , response) , methods used for each resources : PUT , post , get , patch etc.
	Message format  : The format of the message to exchange in between is Json , XML or any other format  
	Transport : Only HTTP protocol. Where as the soap request can be transported using any  messaging service (MQ , kafka , HTTP., https etc )
	Rest full definition : WADL web application definition language / Swagger that contains the end point , operation  , request structure and response structure .
	
start.sring.io or the STS tool suite   : to initialize your rest-full service by selecting the package and dependencies you need for building an api.	
The dependencies we select is JPA (java persistent api) for sql , H2 is for hybernate , web , devtools . Used to create a project by adding the dep

There are multiple methods for the rest api to send/retrive/update the data .

get , put , post , delete , update , patch : These methods will help in doing that 

Lab 1 ----------------- Create a hello world rest api service to respond as hello world when get method is used for it.
We need two things 

Whats is a bean : 
Serializable object , which has the getter and setter as the properties and also a zero paramter constructor to return the object instance.


Difference between spring boot and sping mvc(Model View controller) : https://www.interviewbit.com/blog/difference-between-spring-mvc-and-spring-boot/#:~:text=Difference%20Between%20Spring%20MVC%20and%20Spring%20Boot%20,the%20applica%20...%20%2012%20more%20rows%20


DispatcherServlet is the one which is sitting on the front receives the input request and sends the control to the desired controller method as per uri.
DispatcherServletAutoConfiguration is the bean getting configured to make dispatcher servlet work.
@Responsebody + jacksonHttpMessageConvertor is the one which helps in converting the java object beans to a json payloads.
ErroMVCAutoconfiguration is the bean which creates the error message in case there is no explicit error mapping done by your apis
Spring mvc , tomcat and json conversion are coming because of the spring-boot-starter-web which is the dependecnies we added.

The @Controller is a common annotation which is used to mark a class as Spring MVC Controller while the @RestController is a special controller used in RESTFul web services and the equivalent of @Controller + @ResponseBody.

	@RestController ---- > to tell the spring mvc that this controller is going to handle the rest http request : that contains all request mapping functions . When you go inside @RestController the interface is annotated as @Component and @ResponseBody. When we say it will handle all rest request means all put , post , get , patch  reqeust send on http url this controller will hanlde .
	@Controller :  this annotation will tell mvc that this class will handles incoming requests . This interface is not annotated as @ResponseBody. @RestController interface is annotated as @ResponseBOdy.
	@RequestMapping --- >  This annotation will allow to mention the method and uri for which the controller will react. 
	@RequestMapping(method='Get/Post/PUT/DELETE/PATCH',Path="/hellow-world"
	getCarddetailsfn()
	
	@GetMapping -- > We can also use this annotation  . no need to mention method as get . @GetMapping(path="/hello")
	@PutMapping -- > We can also use this annotation  . no need to mention method as PUT . @PutMapping(path="/hellow-world")
	@PostMapping -- > We can also use this annotation  . no need to mention method as POST . @POstMapping(path="/hellow-world")
	@RequestParam ---- > to get the value from url which is send like localhost:8080/test?name=harmeet , where harmeet is the requestparms
			Example  :  @GetMapping(path = "/uname")
						public String getUserName( @RequestParam String name)
				when hit the controller with uri http://localhost:8080/uname?name=HarmeeetSingh  . Then HarmeetSingh will be assigned to the variable name
						
    @ResponseBody -------> is inherited by the @RestController which also include jacksonHttpMessageConvertor to convert the mesage to json format for a bean response.						
	@ResponseEntity ----- > to modulate the outgoing response from the controller function. We can use any bean to frmulate the outgoing message . We can also set the http response code as 201(created) , internalservererror(500).
	@RequestBody ----- > to map the incoming request to the bean write .
	@Pathvariables ----- > to bind the value frm url to a variable url like : localhost:8080/test/2/ , so the path = /test/{id} . So 2 will be mapped to id 
	@SpringbootTest --- > Annotation that can be specified on a test class that runs Spring Boot based tests. Which is further annotated as @ExtendWith
	@ExtendWith ------>is a repeatable annotation that is used to register extensions for the annotated test class or test method. Is used for JUNIT test => 5 
	@Runwith  -------- is used for junit test < version junit 5 	
	@SpringBootTest(webEnvironment =  SpringBootTest.WebEnvironment.RANDOM_PORT) -----> in order to test the controller 
	@Autowired : ---- >this annotation is used to inject the class instant (object into the other class and use it ). For this to happen the class to be autowired need to part of the classpath bean list . which can happen by annotating the class as @component which will tell componentscanner during bean creation . we can also annotate it as @Service  , @Repository which in lower stage are @component anootated interfaces.
	@JsonIgnore : --------- to ignore the mapping of the variable in bean . it will not only ignore the incoming value map , but also ignore the outgoing value map in json/xml etc 
	@JsonProperty : ------- to assign the name of the variable when it comes out as json. 
	@Transactional ------- it is used in test class , and it will rollback the trransactions happaned on DB after each @test
	@PersistenceContext ---------- which is the collection of managed beans just like application context. 
	@Scope ----------------------- this annotation is used to specify the component as a singleton or prototype. Same object or diff object , i saw this using hashcode code.
	@GeneratedValue --- this will outogenerate the value for the variable and is mostly used on integer variables.
	@SpringBootApplication class : starter class which inherits the, @SpringBootConfiguration,@EnableAutoConfiguration ,@ComponentScan.
	@Component which we use for service classes to manipulate the data coming from bean , this class can be autowired as it is annotated as a @component or a @Service
	@ResponseStatus ----------> this annotation is used to annotate the class to throw the httpstatus code for an action.like : @ResponseStatus(HttpStatus.NOT_FOUND)
	@EnableConfigServer ------> this annotation is used to config the server to connect with the git hub or any version where we can centralised the config values.
	@Bean -------------------> is a method level annotation and should not be used in any class. And also this annotation tells that it returns a bean that is to be managed by the spring container and registered with spring application context or BeanFactory. This method returns a bean of the Customer.
	@ComponentScan ----------> this annotation will allow the component scanner to scan the entire project to instantiate and build the object for the beans add it to the list of beans in the classpth which will allow the autowiring to work.
	@EnableAutoConfiguration ----> this will allow auto configure some of the bean creation which can be auto-injected at run time for more processing.
	@Value("${key.value}") ------> to load a value from the app.yaml file at runtime. eg key.value = 90	. 
									@Value("${key.value}")
									String value ;
	@ConfigurationProperties ------> to load a value from the property file using the prefix .
										@ConfigurationProperties(prefix = "ticket-booking") this is a class level annotation.

									prop file looks like this : 
										ticket-booking.username=usernameXXX
										ticket-booking.password=passwordXXX
										
									code will look like this 
										@ConfigurationProperties(prefix = "ticket-booking")
										class a {
										
										String username; ---> this will get usernameXXX 
										String password; ----> this will get passwordXXX
										}
	@ControllerAdvice ----> this is a class level annotation which  will keep track of any exception comes from any controller inside the projects .
	@ExceptionHandler(UserNotFoundException.class)	----> this is a method level annotation which will run the run if UserNOtFoundException is thrown from any
	controller.
	@EnableEurekaServer - : The @EnableEurekaServer annotation is used to make your Spring Boot application acts as a Eureka Serve
	@EnableFeignClient ---> 
	

Jdbc Template : So just like RestTemplate we used to access the API to get the response objects , we have JDBCTemplate(to access db) , JMSTemplate(to access message queues) etc

Code for above templates : 
a. 		new RestTemplate.getForEntity("http:localhost:8080/users",user.class)   --- we are calling the api or other webservice.
b.		new JDBCTemplate().queryForObjects("Select * from users", user.class) -- same we can use the jdbc template to make a DB call.
c.		new JmsTemplate.convertAndSend(orderNumber, messagePostProcessor -> {
			message.set(messagePostProcessor);
				return messagePostProcessor;
					});
d.		new KafkaTemplate().send("topicname", message);   ----------- Just like that we can use kafkatemplate to send and consume the message.


We can Autowire in Spring boot instead of creating an object or instantiate its objects .

examples : 
	
1.	JDBCTemplate jdbctemplate
	
	@Autowired
	public constructor (JDBCTemplate jdbctemplate)
	{
	 this.jdbctemplate = jdbctemplate;
	}
	
	
	
		
	

--------------------------------------	
@SpringBootTest
@ExtendWith(SpringExtension.class)
@RunWith(SpringRunner.class)
public class testclas{

}
-------------------------------------


testing uri : http://localhost:8080/hello : because spring boot run contains an inbuilt tomcat server which starts on localhost 8080 port by default .
	http://localhost:8080/hello-employee
	
	
. Spring Data : --- provide solution for  data access 	for example , JDBC , JPA persisttence .
	
Lab 1 ----------------- Create a hello world rest api service to respond as hello world when get method is used for it.

Dependecies needed to create a rest full api , as it is a web service we need below dependencies:
	-spring web  : to tell the spring mvc that the app is for web explosure.
	-spring actuator : to get an inbuilt interface to test the health of the app.  to be used to health check our services,
	-spring devtools : to auto reload the app and get the new code in place.
	
	
Create a controller using start.spring.io to set up the projects for spring boot.
in order to create spring controller mentions @RestController to the class other than the @SpringBootApplication class.

Inside the controller class mention or define a @RequestMapper method that will take the incoming request on a HTTP get / post/  , put etc and return the message hello world.

Lab 1 ----------------- Create a hello world rest api service to respond as hello world when get method is used for it.


Lab 2 ----------------- Create a hello world rest api service to respond as a bean back to the user.
How to return a BEan(A bean is a class with separate attributes(variables)) in which the constructor will require a string parameter and display it as 
JSON (which will be done by spring mvc in the back end)

Spring-boot-Auto-configuration : @EnableAutoConfiguration helps in configuring the dispatcher server and also initialize the Jackson bean that converts the Bean to Json while sending a response back.

We can start the debug the level logs for spring boot started console .

logging.level.org.springframework = debug


Dispatcher servelet is the front end controller for spring mvc frame work who knows which controller to call after looking at the uri . when we hit the uri , the dispatcher servelet will take the uri call the controller run the method get the bean , call the jackson parser convert it to json and send the json response back to the browser or consumer.

DispatcherServletAutoConfiguration is the bean getting configured to make dispatcher servlet work.
@Responsebody + jacksonHttpMessageConvertor is the one which helps in converting the java object beans to a json payloads.
ErroMVCAutoconfiguration is the bean which creates the error message in case there is no explicit error mapping done by your apis
Spring mvc , tomcat and json conversion are coming because of the spring-boot-starter-web which is the dependecnies we added.

Complete uri : http://localhost:8080/hello
in above uri : / is mapped to dispatcher servelet and then it looks at the uri hello and send the control to the controller method which it knows.

Need below classes :
@SpringBootApplication class : starter class 
@Component which we use for service classes to manipulate the data coming from bean , this class can be autowired as it is annotated as a @component or a @Service
@Controller : which will contain the request mapping functions for incoming requests.

Lab 2 ----------------- Create a hello world rest api service to respond as a bean back to the user.


NOte  : Change the log level for the spring boot aapp to debug mode is by adding below line in app.yml
logging.level.org.springframework = debug


Lab 3 ----------------- Create an another GetMapping method that will receive a Path variable and use that path variable to do more operations.
for this lab we created an another GetMapping function in which we map the path to this path=/hellow-world/path-varable/{name}
Now in above path the name variable will contains the value when we will hit the url 

Example : http//:localhost:8080/hellow-world/path-varable/Harmeet 

Then the GetMapping function named x() will receive the 'Harmeet' value in variable name and that can be used anywhere inside the program.

for postmapping function we can map the incoming request to the objectmodel by mentioning @RequestBody
Lab 3 ----------------- Create an another GetMapping method that will receive a Path variable and use that path variable to do more operations.


Lab 4 ----------------- Now create a service that will respond on three operations to get all users , to get specific user and to save user.
For that we need a new Bean User 
							
							--- >id
							--- >name
							--- >date
					Three methods to implement the operations in a service (Spring component)
								findAllUsers() 
								findUser(int id)
								saveUsre(User)
								Delete all users : need to clear the list created
								Delete the specific user , get the id for which the user wants to be deleted. Use Iterator 
										(what is an iterator?):	An Iterator is an object that can be used to loop through collections, like ArrayList and HashSet
								
Note : In order to Autowired the class object in to another class the class should either be annotated as a component or a service 								

IN ORDER TO AUTO GENERATE THE ID VALUE : WE CAN USE @GeneratedValue annotation so that sending null in creating an object will not throw null pointer exception 

When you hit the post request : we will get below error

{
    "timestamp": "2021-04-18T18:03:47.649+00:00",
    "status": 500,
    "error": "Internal Server Error",
    "trace": "org.springframework.http.converter.HttpMessageConversionException: Type definition error: [simple type, class myproject.minlearning.startertestclass.users.Users]; nested exception is com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Cannot construct instance of `myproject.minlearning.startertestclass.users.Users` (no Creators, like default constructor, exist): cannot deserialize from Object value (no delegate- or property-based Creator)\n at [Source: (PushbackInputStream); line: 3, column: 3]\r\n\tat org.springframework.http.converter.json.AbstractJackson2HttpMessageConverter.readJavaType(AbstractJackson2HttpMessageConverter.java:386)\r\n\tat org.springframework.http.converter.json.AbstractJackson2HttpMessageConverter.read(AbstractJackson2HttpMessageConverter.java:342)\r\n\tat org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodArgumentResolver.readWithMessageConverters(AbstractMessageConverterMethodArgumentResolver.java:186)\r\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor.readWithMessageConverters(RequestResponseBodyMethodProcessor.java:158)\r\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor.resolveArgument(RequestResponseBodyMethodProcessor.java:131)\r\n\tat org.springframework.web.method.support.HandlerMethodArgumentResolverComposite.resolveArgument(HandlerMethodArgumentResolverComposite.java:121)\r\n\tat org.springframework.web.method.support.InvocableHandlerMethod.getMethodArgumentValues(InvocableHandlerMethod.java:170)\r\n\tat org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:137)\r\n\tat org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:106)\r\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:894)\r\n\tat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:808)\r\n\tat org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)\r\n\tat org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1060)\r\n\tat org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:962)\r\n\tat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)\r\n\tat org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909)\r\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:652)\r\n\tat org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)\r\n\tat javax.servlet.http.HttpServlet.service(HttpServlet.java:733)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:227)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\r\n\tat org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\r\n\tat org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\r\n\tat org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\r\n\tat org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)\r\n\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\r\n\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)\r\n\tat org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202)\r\n\tat org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:97)\r\n\tat org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:542)\r\n\tat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:143)\r\n\tat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92)\r\n\tat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:78)\r\n\tat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:357)\r\n\tat org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:374)\r\n\tat org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)\r\n\tat org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:893)\r\n\tat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1707)\r\n\tat org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\r\n\tat java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)\r\n\tat java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)\r\n\tat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\r\n\tat java.base/java.lang.Thread.run(Thread.java:834)\r\nCaused by: com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Cannot construct instance of `myproject.minlearning.startertestclass.users.Users` (no Creators, like default constructor, exist): cannot deserialize from Object value (no delegate- or property-based Creator)\n at [Source: (PushbackInputStream); line: 3, column: 3]\r\n\tat com.fasterxml.jackson.databind.exc.InvalidDefinitionException.from(InvalidDefinitionException.java:67)\r\n\tat com.fasterxml.jackson.databind.DeserializationContext.reportBadDefinition(DeserializationContext.java:1615)\r\n\tat com.fasterxml.jackson.databind.DatabindContext.reportBadDefinition(DatabindContext.java:400)\r\n\tat com.fasterxml.jackson.databind.DeserializationContext.handleMissingInstantiator(DeserializationContext.java:1077)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializerBase.deserializeFromObjectUsingNonDefault(BeanDeserializerBase.java:1332)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer.deserializeFromObject(BeanDeserializer.java:331)\r\n\tat com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:164)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:4526)\r\n\tat com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3521)\r\n\tat org.springframework.http.converter.json.AbstractJackson2HttpMessageConverter.readJavaType(AbstractJackson2HttpMessageConverter.java:378)\r\n\t... 51 more\r\n",
    "message": "Type definition error: [simple type, class myproject.minlearning.startertestclass.users.Users]; nested exception is com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Cannot construct instance of `myproject.minlearning.startertestclass.users.Users` (no Creators, like default constructor, exist): cannot deserialize from Object value (no delegate- or property-based Creator)\n at [Source: (PushbackInputStream); line: 3, column: 3]",
    "path": "/users"
}	

This is because in current version of jackson we need a default constructor in the bean we are using .

So add a protected default no arg constructor
								
I have also added the method to delete the user from the list using PUT methods in the controller.		

For best HTTP REST api service : While creating an object you can send the Build uri back to the user in header .
This can be achieved by using ServeletUriComponentbuilder class that helps in creating the uri which we can pass to the user in header 				
			
					----------------ServeletUriComponentbuilder----------------

URI location = ServletUriComponentsBuilder.fromCurrentRequest().path("/{id}").buildAndExpand(users.getId()).toUri();
ResponseEntity.created(location);
		
http status code :  201 : The object created
					200 : get ok 
					404 : not found 
					
Now if we need to handle the not found exceptions we can throw the RuntimeException under a certain conditions . By creating a class exception class 

package myproject.minlearning.startertestclass.users;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.NOT_FOUND)
public class UserNotFouncException extends RuntimeException {
    public UserNotFouncException(String message) {
        super(message);
    }
}

JAVA KA IMPORTANT FUNDA : FOR A BEAN YOU CAN SET ALL THE ATTRIBUTE VALUE USING A PARAMTERISED CONSTRUCTOR AND NO NEED TO ADD SETTER AS WE ARE SETTING IT IN CONSTRUCTOR.

Post that RUntimeexception we start getting exception 500 internal server error 

We can make it more readable htppstatus by adding @ResponseStatus(HttpStatus.NOT_FOUND) to the UserNOtFoundException class.
We can modify the http status code accordingly.

*******NOTE : WHENEVER YOU WANT TO CUSTOMIZE ANY RESPONSE FROM REST API , CREATE A BEAN AND USE THAT BEAN AND THE ATTRIBUTES DEFINED IN IT AS A STRUCTURE FOR YOUR API RESPONSE.
Means you can create a user defined exception bean class and use that and return that bean object structure in response for a dfined error structure.

But for the generic exception response to be sent to the user we need to use ResponseEntityExcpetionHandler class to be extend this class provide various functions to override so 
that we can send an instance of our bean to the user when ever an exception comes around any controller

For that we need to make that class A extend ResponseEntityExcpetionHandler to be a Restcontroller and with annotation @ControllerAdvicer (which is used to share the feature 
across all the controller).

	ThIS IS USED TO SEND THE RESPONSE IN ANY KIND OF EXCEPTION COMES FOR WHICH WE ARE CREATING ResponseEntityExcpetionHandler class  --- REEH
	----------------------------------------------------------------
    THATS COOL , I MEAN YOU JUST HAVE TO DEFINE THE @RestController AND @controllerAdviser to share the feature to all controllers .
				You need to handle the exceptions whether it is generic or it is specific .
				using @ExceptionHandler annotation on a function we can handle any kind of exceptions, whenever you throw an exception from anywhere  of the controllers , 
				This handler will send a response in a generic structure defined in our bean.
Lab 3 ----------------- Now create a service that will respond on three operations to get all users , to get specific user and to save user.


Lab 4 ----------------- now for above created Rest api we are to perform validation 

If you are making use of Spring Boot Release (> 2.3.0) make sure to add the following dependency to your pom.xml (We are going to implement validations in next step):

<dependency>    
    <groupId>org.springframework.boot</groupId>    
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>

For the validation to work on the attributes of the bean , we need to use :
		@valid along with the @RequestBody 
		In bean class for each attibutes for which we need the validation to happen . use validation annotation like , @Size (which says the min or max lenght of the string )
			or @Past to constraints the date to be in past 
		
			Now when you hit the api it will validate and send you bad request , but the respose body will be empty :( .
			So to bring something readable for user to read we need to add one more function in customexceptionresponseentityclass which is the override function of
			ResponseEntityExcpetionHandler class named : handlemethodArgumentnotvalid

public class Validbean {

    @Past(message = "The dob should be greater than present date")
    private Date dob;

    @Max(message = "the max amount permisseable is 1000000", value = 0L)
    private int creditamount;

    @Min(message = "The max amount permissabe is 10000",value = 0l)
    private int debitamount;

    @Email(message = "the email entered is wrong")
    private String email;

    public Validbean() {
    }
}

*********CREATING A CUSTOMIZEEXCEPTIONHANLDER CLASS IS MUST , DON'T FORGET TO ADD THIS CLASS . EXTENDS ResponseEntityExcpetionHandler CLASS.			
Lab 4 ----------------- now for above created Rest api we are to perform validation 


HATEOAS : --------------------------------------------------------

HATEOAS : Hyper media at the engine of application state . this is the feature using which we can provide more information apart from the data we are returning bck to the consumer .
For example: whenever we search for a repo in git , we got whole lot of other informations also , like number of stars , other links also .

Soooooooooooooo in order to add more info or more links to your response you can use HATEOAS .

Add a starter dependencies :

<dependency>    
    <groupId>org.springframework.boot</groupId>    
    <artifactId>spring-boot-starter-hateoas</artifactId>
</dependency>

import static org.
This spring feature treat other infor to be sent back as a response as Resource , so we need to use Resource java class for that . and return along with it 
example : EntityModel<bean class >   resource = new EntityModel<user>();

NOTE : WE ARE RETURNING DATA AS  WELL AS THE LINKS , BOTH ARE PART OF THE RESOURCE FIRST WE CREATED THE DATA RESOURCE USING ENTITY AND THEN LINK THE OTHER INFO TO IT.

HATEOAS : --------------------------------------------------------


INTERNATIONALIAION : ---------------------------------------
This is the feature in which suppose you are getting data request or get request from different country or locale .
So language is a barrier , in order to response with different data as per the locale we internationalize the response using property files.
We can send an header Accept-language = en to send the message response in english or Accept-Language = sp to send the message in spanish


We just need to use MessageSource Class which helps in getting the values from messages.properties file for internationalization to work .



	in the getter method of the controller we have to pass the locale paramter in header .
	
In order to pick the properties value and send that as a resource back we will use 
The Locale value the consumer will send that in the message header and we can get that using @RequestHeader Locale local.

We can save the different language message in messages.properties file and load them up to get the value for the response message.

----------Simplify the internationalization -----------
In order to add @RequestHeader Locale locale as a parameter for multiple get methods it would be a pain 
 To remove that take the locale object from localeContext and change the SessionLocaleResolver to AcceptHeaderLocaleResolver
 And we can also add the setBasename in application.properties.  spring.message.basename=messages

INTERNATIONALIAION : ---------------------------------------


Lab 5 --------------------As we know jackson is doing the conversion from object to json sofar , So in-order to receive the response in XML we can add jackson other dependencies for XMl data format ---------------

Need to add jackson-dataformat-xml dependencies

			<dependency>
                <groupId>com.fasterxml.jackson.dataformat</groupId>
                <artifactId>jackson-dataformat-xml</artifactId>
            </dependency>
and send the header (Accept) explicitly as application\xml to receive the response in xml format 

json : 
[
    {
        "id": 1,
        "name": "Harmeet",
        "birthdate": "2021-04-26T11:37:01.480+00:00"
    },
    {
        "id": 2,
        "name": "Simran",
        "birthdate": "2021-04-26T11:37:01.480+00:00"
    },
    {
        "id": 3,
        "name": "Harpreet",
        "birthdate": "2021-04-26T11:37:01.480+00:00"
    }
]


xml : 
<List>
    <item>
        <id>1</id>
        <name>Harmeet</name>
        <birthdate>2021-04-26T11:37:01.480+00:00</birthdate>
    </item>
    <item>
        <id>2</id>
        <name>Simran</name>
        <birthdate>2021-04-26T11:37:01.480+00:00</birthdate>
    </item>
    <item>
        <id>3</id>
        <name>Harpreet</name>
        <birthdate>2021-04-26T11:37:01.480+00:00</birthdate>
    </item>
</List>

Jackson do all the magic to it  this is called CONTENT NAGOTIATION 



Lab 5 --------------------As we know jackson is doing the conversion from object to json sofar , So inorder to receive the response in XML we can add jackson other dependencies for XMl data format ---------------



Lab 6 ---------------Auto swagger generation ---------------
For rest full service we have swagger and for soap service we have WSDL .

For Auto generate the Swagger for an api we can use below dep 
<dependency>
      <groupId>org.springdoc</groupId>
      <artifactId>springdoc-openapi-ui</artifactId>
      <version>1.5.10</version>
   </dependency>
   
 http://localhost:8081/swagger-ui/index.html is the url we can use to see the ui documentation
 
 http://localhost:8081/v3/api-docs : to get the json file out 
   

below steps are used to modify the swagger as per our needs.


Step 1 : 

Add below dependency instead of above two :

<dependency>
	<groupId>io.springfox</groupId>
	<artifactId>springfox-boot-starter</artifactId>
	<version>3.0.0</version>
</dependency> 	
	
	
Step 2 :	
Now configure swagger : 
	Create a configuration class SwaggerClass2.java use @Configuration  , @EnableSwagger2
	Create a @Bean name Docker , which is part of the springfox documentation 


Step 3 : 
You will see below urls :

		\v2\api-docs : - to get the entire swagger json 
		NEW URL for SWAGGER UI - http://localhost:8080/swagger-ui/ or http://localhost:8080/swagger-ui/index.html

A swagger contains  :
			Swagger version : version 2.0 , 3.0
			info : The info about the api , and the license
			path  : the paths contains the various get-mapping  , put-mapping and post-mapping functions we have created .
			tags 
			definition : will contains the bean definition used .
			host : the server host where it will be run..
			base-path : the base path for the url

Step 4 : To improve some things in swagger documentation like , validations we applied on some fields and Api info description and the consumption format and production format
	For that we can make some changes in swagger config class we created .
	
	We can use class ApiInfo.java by importing it . This class will give the objects to be copied for the modification 
	@ApiModel(Description = "") : to give description about the Api model we have like User.java class on class level we can annotate it.
	@ApiModelProperty(Notes = "") : 	We can also use that on an attribute level .

The docket function bean we have created we can use to modify different property of the swagger documents (NOTE : LOOK AT THE SWAGGER CREATED).
 example :  return new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(DOCKET_API_INFO).produces(produces)
                .consumes(consumes);


Lab 6 ---------------Auto swagger generation ---------------



Lab 7 : ----------- Spring boot actuator -----------

Please add the below dependency instead of spring-data-rest-hal-browser

		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-actuator</artifactId>
		</dependency>
		
		<dependency>
			<groupId>org.springframework.data</groupId>
			<artifactId>spring-data-rest-hal-explorer</artifactId>     ---------------- this will launch a browser at localhost:8080 to hit the api using paths .
		</dependency>
		
		The actuator works around hal : HyperText Application language  : 
		
Why we use Actuator   ?   Now as we know we have documented our application  , now i need some monitoring feature for my api to show if it is up and running or to see the metrics , for that spring boot have provided actuator for it.		

Url launch for hal browser : localhost:8080

Url to launch Actuator : localhost:8080/applications
						 localhost:8080/actuator
{
	"_links": {
		"self": {
			"href": "http://localhost:8080/actuator",
			"templated": false
		},
		"health": {
			"href": "http://localhost:8080/actuator/health",
			"templated": false
		},
		"health-path": {
			"href": "http://localhost:8080/actuator/health/{*path}",
			"templated": true
		},
		"info": {
			"href": "http://localhost:8080/actuator/info",
			"templated": false
		}
	}
}



Lab 7 : ----------- Spring boot actuator -----------



Lab 8 : ----------- Spring boot filtering , in which we can filter out the fields we dont need from a bean ---

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
 
 Jackson provide two annotations for JsonIgnore on a field level that will help in removing the fields don't want to be in the response.
 
 or 
 JsonIgnoreProperties on class level and mention the fields to be removed .




Lab 8 : ----------- Spring boot filtering , in which we can filter out the fields we dont need from a bean ---

Lab :------------------- Dynamic filtering 

We can use mappingjacksonValue is the class that help is sending a filtered bean value back as a response.


In Controller class 1: 

Bean bean = new Bean();	
MappingjacksonValue mapping = new mappingjacksonValue(bean)
SimpleBeanPropertyFilter filter = new SimpleBeanPropertyFilter();
FilterProvider filterprovider = new SimpleFilterPRovider().addFilter("SomeBeanFilter",filter);.filterOutAllExcept("field1");
mapping.setfiltering(filter);
return mapping;

In bean Class 2: 
@JsonFilter("SomeBeanFilter")
class Bean{

}

Verry important point always mention the @JsonFilter on top of the bean class to implement the dynamic filter occuring from controller.



Lab :------------------- Dynamic filtering 

Lab 8.1 :-------------------MultipartFile to upload and download a the file ----------------------

https://www.tutorialspoint.com/spring_boot/spring_boot_file_handling.htm#


We can use @RequestParam("file") MultipartFile file as part of the POstMapping resource function.

@PostMapping(path="/upload",consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
public String upload(@RequestParm(file) MultipartFile mfile)
{
	File file = new File(mfile)
	OutBufferStream

}


To download the file we need to read the file for directory and then use InputStreamResource to deserialize it and make it as part of the ResponseEntity and send it back to the consmer.
@GetMapping(value = "/download")
    public ResponseEntity<Object> downloadFile() throws IOException  {
        String filename = "C://Users//IBMADMIN//Downloads//RestApiFileProcess//run.txt";
        File file = new File(filename);
        InputStreamResource resource = new InputStreamResource(new FileInputStream(file));
        HttpHeaders headers = new HttpHeaders();

        headers.add("Content-Disposition", String.format("attachment; filename=\"%s\"", file.getName()));
        headers.add("Cache-Control", "no-cache, no-store, must-revalidate");
        headers.add("Pragma", "no-cache");
        headers.add("Expires", "0");

        ResponseEntity<Object>
                responseEntity = ResponseEntity.ok().headers(headers).contentLength(
                file.length()).contentType(MediaType.parseMediaType("application/txt")).body(resource);

        return responseEntity;
    }
	
	
	
	
In portman you have to select method : POST 
1. Then in Body select form-data 
2. Then Select file in value field 
3. Browse the file 
4. click on send



Lab 8.1 :-------------------MultipartFile to upload and download a the file ----------------------




Lab 9 : ----------- Version rest api

Example for versioning : The customer may ask to send the name as a single string and also to send name as two string as first name and last name .
for that we can keep two @GetMapping mapped with two different urls and share those urls with customer to hit.

There are four methods to implement versioning for your API : in all below methods we update the path in get/post mapping 

URI versioning : in which we can create two uri's for external user , but this will pollute the uri space .
Param versioning : in which we can send the query parameters in uri , this will also pollute the uri space 
header versioning : in which we can send different header values to be picked up for different version response , header are never meant for versioning.
MIME versioning : in this by sending the Accept header value as different version we can send differnt response .

1.URI Versioning

	V1: http://localhost:8080/v1/person
	
	@GetMapping("/v1/person")
	
	V2: http://localhost:8080/v2/person
	
	@GetMapping("/v2/person")

2.Request Param Versioning

	V1: http://localhost:8080/person?version=1
	
	@GetMapping(path = "/person", params = "version=1")
	
	V2: http://localhost:8080/person?version=2
	
	@GetMapping(path = "/person", params = "version=2")
	
3. Header Versioning

	V1: http://localhost:8080/person/header
	
	HEADER - X-API-VERSION:1
	
	@GetMapping(path = "/person/header", headers = "X-API-VERSION=1")
	
	V2: http://localhost:8080/person/header
	
	HEADER - X-API-VERSION:2
	
	@GetMapping(path = "/person/header", headers = "X-API-VERSION=2")

4. Content Negotiation Versioning

	V1: http://localhost:8080/person/accept
	
	HEADER - Accept:application/vnd.company.app-v1+json
	
	@GetMapping(path = "/person/accept", produces = "application/vnd.company.app-v1+json")
	
	V2: http://localhost:8080/person/accept
	
	HEADER - Accept:application/vnd.company.app-v1+json
	
	@GetMapping(path = "/person/accept", produces = "application/vnd.company.app-v2+json")

Lab 9 : ----------- Version rest api


Lab 10 : ----------- Authentication implement

add below dependency : 
	<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-security</artifactId>
	</dependency>
		
		
This will allow spring to add basic authentication to your rest api .
fire up your api in logs you will get the password in alpha numeric value and default username will be : user

this will add authentication for all controllers  

username : user 
Using generated security password: 0812eff5-00c0-4390-8271-35c6f688512e

Everytim you spun up the rest api it will create a new password to stop that 
we can mention below two properties in application.yml file.
spring.security.user.name=username
spring.security.user.password=Gogi!1234




- Enhancing the basic security authentication in spring boot rest api 
Steps : create an another class below to allow the browser to pop up asking for the username and password.
@Configuration
public class SpringSecurityConfiguration {


    public SecurityFilterChain filterChain(HttpSecurity httpSecurity) throws Exception{

        httpSecurity.authorizeHttpRequests().anyRequest().authenticated();
        httpSecurity.httpBasic(Customizer.withDefaults());
        httpSecurity.csrf().disable();
        return httpSecurity.build();
    }
}




Lab 10 : ----------- Authentication implement

NOTE : Constructor Injection:

It is one of the kinds of Dependency Injection.
Constructor Injection (Spring Container uses the parameterized constructor to create spring bean class object value to that object).
		
Lab 11 :------------  JPA (java persistent api) for sql		
The Java Persistence API (JPA) is a specification of Java. It is used to persist data between Java object and relational database. JPA acts as a bridge between object-oriented domain models and relational database systems. It also include JDBC in int so that we can use JDBCTemplate to access Db other then h2
we can use @Entity for the bean we created to convert that bean into an entity in which the attibutes will be converted to each column and bean will be a table 
1) H2 database name is randomly generated each time you restart the server. You can find the database name and URL from the console log.


Step 1 : add below 
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>
		
		o r 
		We can also add mongo dependencies or the Db2 dependencies for template to use.
			 


Step 2 : add below in app.yml
2) To use data.sql, you need to add this to 
spring.jpa.show-jpa=true
spring.h2.console.enabled=true
spring.datasource.url=jdbc:h2:mem:testdb
spring.data.jpa.repositories.bootstrap-mode=default
spring.jpa.defer-datasource-initialization=true

http://localhost:8080/h2-console
	
Step 3 : create an sql file under src/main/resources and run three insert queries to insert data to h2 in memory db


Step 4 : 
	a. Create a different user(bean) controller and a  User bean anootated as @Entity
	b. create a repository as an interface extending JPArepository<Users(bean) , Integer> , this repository is just like a daoservice that we used to get the value from Bean data.
		Now this repository will get the data from in memory db (h2).
		

Keep track of the function we use for the DAO service while interacting with the h2 database.



Or 

We have an older approach 
1. DAO is the data Access object clas with function defination for the method declared in Interface .
2. Interface containing the function declared 
3. Repository : - Which will implements the interface and defined the function 
4. This repository will be autowired in the controller class or springboottest class to test and run it .

In this approach , the table we created using the schema.sql and insertted the data using data.sql which have insert query.

Where as the other technique we annotated the bean class as the @Entity of javax.persistence which will automatically create the table and then use the data.sql class to insert the data . Also we created only one interface which will extends JPArepository<Customer,long> and we can directly autowired this interface annotaed as @Repository and use all db fucntions . Which is the best approach .


or

we have an another approach ,
1. we will create an entityt class the bean class for which the table and column will be created .
2. in the DAO (annotated as @Repository)class we can inject EntityManager class annotated as @PersistenceContext.
3. Then we can direclt use the functions like entitymanager.persist() , entitymanager.remove(), entitymanager.update() etc which will directly communicate to hibernate inmemory DB to do all the data manipulation stuff.



Lab 11 :------------  JPA (java persistent api) for sql		

Lab 11.1 :------------ IIIIIIIMMMMMMMPPPPPPP Mysql Db connections from spring boot rest api 
Launch MySQL as Docker Container
docker run --detach --env MYSQL_ROOT_PASSWORD=dummypassword --env MYSQL_USER=social-media-user --env MYSQL_PASSWORD=dummypassword --env MYSQL_DATABASE=social-media-database --name mysql --publish 3306:3306 mysql:8-oracle


mysqlsh commands
mysqlsh
\connect social-media-user@localhost:3306
\sql
use social-media-database
select * from user_details;
select * from post;
\quit


/pom.xml Modified
<dependency>
	<groupId>mysql</groupId>
	<artifactId>mysql-connector-java</artifactId>
</dependency> 


/src/main/resources/application.properties Modified
#spring.datasource.url=jdbc:h2:mem:testdb
spring.jpa.show-sql=true
spring.datasource.url=jdbc:mysql://localhost:3306/social-media-database
spring.datasource.username=social-media-user
spring.datasource.password=dummypassword
spring.jpa.hibernate.ddl-auto=update
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect

NOTE : NO code changes are required the same userrepository and postrepository interfaces will be used to insert or get the data .

The data.sql will not be triggered or run to insert the sample data when we are connecting to the real databse like mysql 

Lab 11.1 :------------  Mysql Db connections from spring boot rest api  

Lab 12 ----- Spring cloud-----------------------------------------------------------
challanges  for monolithic approach 
1. cloud config 
2. Elasticity 
3. Failt tolerance 
4. tracebility
5. Bounderies -- this shows what a single microservice is doing.
6. load balancing 


Spring Cloud Config : just like we can save all configs properties in one place in in git repo
Centralized external configuration management backed by a git repository. The configuration resources map directly to Spring Environment but could be used by non-Spring applications if desired.
Which will have Spring cloud client and spring cloud server dependencies to be used .



Spring Cloud Netflix - for load balancing process.
This can be use to add the new instances .
Integration with various Netflix OSS components (Eureka, Hystrix, Zuul, Archaius, etc.).
Eureka(Naming server) : two feature : 
				Registry 
				instance discovery


Spring Cloud Sleuth is used for tracing along with zipkin.
Distributed tracing for Spring Cloud applications, compatible with Zipkin, HTrace and log-based (e.g. ELK) tracing.

spring cloud api gateway : which is used to hold many common fetaure which involved authentication  , logging etc.
 
LAB : ----------Configuration load from app.yml file --------------------

We have two techniques to load properties from app.yml file 

1. Create a class with value which will hold the values from app.yml file.
	and annotate it with @Value("${key.value}")  where key.value =90 is in app.yml file .
	 annotate the class as component as it is to be autowired in function class.

2. Create a class annotate it with @Component and @ConfigirationProperties(prefix= "word.something to load")
		Then autowired and use that .



LAB : ----------Configuration load from app.yml file --------------------

Lab 12 ----- Spring cloud

lab 13 ----------------------Spring cloud config

microservice 1 				microservice 2
Spring 						Spring 
cloud client 			 	cloud client 
    |							|
	|							|
	|							|
	|connects to 				|connect to the 
	|							|spring cloud server
	|server						|
	|--------|			|-------|
			 |	        |
			 |          |
			 |          |
			 |          |
			Sprig cloud server 
			  Microservice 3
					|
                    |
                    |connects to Git repo
                    |
                    |
				Git Repository

Annotate the spring cloud config app  as @EnableConfigServer				
				
@application.yml for spring cloud server app :
spring.application.name = spring-cloud-config-server
server.port = 8888
spring.cloud.config.server.git.uri=https://github.com/harmeet2401/serviceconfigcenter
                                   #https://github.com:harmeet2401/serviceconfigcenter.git
spring.cloud.config.server.git.search-paths=sprincloud-config
spring.cloud.config.server.git.force-pull=true
spring.cloud.config.server.git.username=harmeet2401
spring.cloud.config.server.git.password=Gogi!321
spring.cloud.config.server.git.default-label=main


@application.yml for microservice1 connecting to spring cloud srever
spring.application.name=limits-service
server.port = 8080
spring.config.import=optional:configserver:http://localhost:8888
limits-service.minimum=9
limits-service.maximum=800			

@application.yml for microservice2 connecting to spring cloud srever
server.port=8081
spring.application.name=startertestclass
spring.config.import=optional:configserver:http://localhost:8888/
startertestclass.username=harmeet singh
startertestclass.address= Plot no-988
startertestclass.id= 0023N7744
startertestclass.dept= IT

application.yml for microservice3
spring.application.name=micro-service2
server.port = 8082
spring.config.import=optional:configserver:http://localhost:8888
micro-service2.username=testname
micro-service2.password=testpass
micro-service2.dept=testdept
micro-service2.address=testaddress	
server.port=8082
				
				
Now for the different region and single microservice how we will maintain the config files ?
By adding below two props we can call for the specific file

The applicationu.yaml file will be by the name of application-dev.yaml , application-prod.yaml . Using below two properties we can load one of the profiles in the main application.yaml

spring.profiles.active=dev
spring.cloud.config.profile=dev

Then the complete yaml file will be 
spring.application.name=micro-service2
spring.config.import=optional:configserver:http://localhost:8888
micro-service2.username=testname
micro-service2.password=testpass
micro-service2.dept=testdept
micro-service2.address=testaddress
spring.profile.active=dev
spring.cloud.config.profile=dev
server.port=8081

NOTE********** : ALWAYS BOUNCE THE APP ONCE CHNAGE THE VALUE IN GIT FILE , DON'T BOUNCE THE SPRING CLOUS SERVER .
				
For spring boot  Auto yml assists add below dependencies : 
<!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-configuration-processor -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-configuration-processor</artifactId>
			<optional>true</optional>
		</dependency>				
		
				
lab 13 ----------------------Spring cloud config

lab 14 ----------------------currency conversion/exchange microservices

1. Currency exchange microservice : This microservice will contains the exchange rate for a Dollar to Ruppess .
It means it will send a response in which the value of 1 dollar is given as 65 ruppess.

2. Currency conversion  microservice : This will convert the currency from Dollar to ruppees . Now this MICRO will call the exchange service to get the exchange rate and use that to multiply it will input dollar and send it back as a response.

						call(getexchange value)
Currency Conversion MICRO -------------------------> Currency exchange MICRO 
														|
														|
														|	Call h2 DB to save the values in memory space 
														|
														|
														database to save the value .
											
----------------------------MICRO1-------------
	group id : com.in28minutes.microservices
	artifact id : currency-exchange-service
	dependencies : Actuator , devtools  , spring cloud client , web(to make it as an api)											
	
	URL
	http://localhost:8000/currency-exchange/from/USD/to/INR
	
spring.application.name=currency-exchnage
server.port=8000
spring.config.import=optional:configserver:http://localhost:8888
spring.jpa.show-sql=true # this will show all the sqls running 
spring.datasource.url=jdbc:h2:mem:testdb
h2.console.enabled=true #need to see the details of the data in Data base.
spring.jpa.defer-datasource-initialization=true # this will help in not runing the insert data.sql file before the table is created whenevr the app get started.	
	
	Response Structure
	{
	"id":10001,
	"from":"USD",
	"to":"INR",
	"conversionMultiple":65.00,
	"environment":"8000 instance-id"
	}
	
Now connect it to the in memory data base H2 hibernate using JPA framework 
dependencies : h2 and spring boot starter-data-jpa
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>

		<dependency>
			<groupId>com.h2database</groupId>
			<artifactId>h2</artifactId>
		</dependency>


In the bean below imports are important :

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;


url to chck jpa : http://localhost:8000/h2-console

the bean we  created will be annotated as @Entity  and Id as @Id so that the JPA will create a table out of that .
we know that 'from' is a keyword in sql query so using an attribute in entity as from is a syntax error.
so change those .
Now create a data.sql(specific name) in src.main.resources folder. whenever the app starts it will run this file to insert the data into the table .
	
Now create a iterface  (@repository)	extending jparepository to connect to the h2 database.

NOTE**** : WHENEVR WE WANT ANY QUERY TO BE RUN ON DB USING THE INTERFACE  , WE CAN SIMPLY ADD THE METHOD AND PASS IN THE PARAMETERS , THEN JPA WILL CREATE A SQL QUERY OUT OF IT AND FETCH THE DATA FROM YOU .	
	
	
	
	
	
----------------------------MICRO1-------------
	
----------------------------MICRO2-------------
	
	URL
http://localhost:8100/currency-conversion/from/USD/to/INR/quantity/10



Response Structure
{
  "id": 10001,
  "from": "USD",
  "to": "INR",
  "conversionMultiple": 65.00,
  "quantity": 10,
  "totalCalculatedAmount": 650.00,
  "environment": "8000 instance-id"
}
 
 server.port=8100
spring.application.name=currency-conversion


We will call the currency-exchange-service from currency-conversion using RestTemplate class 
      HashMap<String,String> uriVariables = new HashMap<>();
        uriVariables.put("from",from);
        uriVariables.put("to",to);
            ResponseEntity<CurrencyConversion> forEntity = new RestTemplate().getForEntity("http://localhost:8000/currency-exchange/from/{from}/to/{to}", CurrencyConversion.class,
                    uriVariables);
        CurrencyConversion currencyConversion = forEntity.getBody();
		
		
Now the bean model of currency-exchange-service is subset of bean model of currency-conversion , so the response coming from currency-exchange-service will get mapped to values to bean model of currency-conversion and we used that to create (multiple) whatever to create new currency-conversion object to return .


FEIGN : --- MAKES IT REALLY EASY TO MAKE A REST CALL TO THE API  This is much easier then the resttemplate 

Steps : to do in Currency-conversion service from where the service to be called .

1. Add the dep : 
<!-- https://mvnrepository.com/artifact/org.springframework.cloud/spring-cloud-starter-openfeign -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
    <version>3.0.3</version>
</dependency>

2. Just like we created an interface for the DB using JPA or mongo or any other , we need to create a interface(act as a proxy) Annotating it as @FeignClient(name , url : localhost:8000)
3. Also annotate the Currency-conversion main class as @EnableFeignClient
4. Add the method in the interface for @Getmapping.
		

Convenient alternative of RestTemplate that is suitable for integration tests. TestRestTemplate is fault tolerant. This means that 4xx and 5xx do not result in an exception being thrown and can instead be detected via the response entity and its status code.
		
----------------------------MICRO2-------------

Both of our service is connected where the currency-conversion -----------------. calling ------> currency-exchange-service
																										|
																										|
																										|
																										|
																								Which is calling DB(h2) to get the values .
lab 14 ----------------------currency conversion/exchange microservices
	
	
Lab 15 : -------------- naming srever (Eureka netflix server ) at port 8761-------------	
Eureka naming server is an application that holds information about all client service applications. Each microservice registers itself with the Eureka naming server. The naming server registers the client services with their port numbers and IP addresses.

Steps : 

1. Add dep : Eureak server  , devtools , actuater 
	<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
		</dependency>
2. Annotate main class with @EnableEurekaserver  , this is just like when we created the config server we annotate it as @EnableConfigServer ,
		@EnableFeignClient is annotated the main class from where we are using the proxy .
3.	Add name of the app 
	eureka.client.register-with-eureak = false
	eureka.client.fetch-registry = false


Now just we added the config client dep in all other micro , we will be adding the naming eureka client in all micro which wants to register them to the naming server .



Lab 15 : -------------- naming srever (Eureka netflix server )-------------	

lab16 : -------now connect micro to naming server------------
1. Add client dependencies to all micro to be register

	<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
		</dependency>
		
2. Add prop in app.yml file of all micro.
	eureka.client.servieUrl.defaultZone=http://localhost:871/eureka

lab16 : -------now connect micro to naming server------------
	
	
LAB 17 : ------------- load balancing the currency-exchange-service ----------------- using naming server ----------
Steps : 

1. We will use already set up feign to talk to eureka and for that we need to remove the localhost url we gave in @FeignClient(name , url)
	ex : @FeignClient(name="currency-exchange")   ---- > this is enough for the load balancer to work using naming server .
		Note : we already set up the mandate eureak server for this in above steps .
		The eureka.client jar contains 
			spring - cloud -strater -Load balancer code which is doing the switch. use dby feign

LAB 17 : ------------- load balancing the currency-exchange-service ----------------- using naming server ----------	

LAB 18 : ---------------Api gateway :------ 
1. To contain the common features like authentication , authorization , logging etc.
2. Allow easy routing to the apis by encapsulating the common fetaures line (auth, authorization , loggin etc ).
3. so all the api hit will go through this api gateway containing the common feature .
4. It will act as a proxy . Which will receive a client request and we will do the authentication and send the request to the actual api using the naming server.

Steps : 
1. Add the dep 
		<dependency>
			<groupId>org.springframework.cloud</groupId>
			<artifactId>spring-cloud-starter-gateway</artifactId>
		</dependency>


DevTools
Actuator
Config Client
Eureka Discovery Client.
Gateway (Spring Cloud Routing)

2. now how it works ?
		Apigatewayurl/micro registered name on naming server / url of the micro to hit .
		
		example : http://localhost:8765/CURRENCY-EXCHANGE/currency-exchange/from/{from}/to/{to}
		
		This will tell the api gateway to talk to eureka client with name CURRENCY-EXCHANGE find it and hit it with currency-exchange/from/{from}/to/{to} url
		
			for that add :  spring.cloud.gateway.discovery.locator.enabled=true
							spring.cloud.gateway.discovery.locator.lowerCaseServiceID=true # to make the CURRENCY-EXCHANGE in lowercase 
	

3. app.yml 
spring.application.name=api-gateway
server.port=8765
spring.config.import=optional:configserver:http://localhost:8888/
eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka
spring.cloud.gateway.discovery.locator.enabled=true
eureka.instance.hostname=localhost
spring.cloud.discovery.enabled=true
spring.cloud.gateway.discovery.locator.lowerCaseServiceId=true


VERRRY VERRRY IMPORTANT 
	eureka.instance.hostname=localhost	  ADDD THIS TO ALL THE MICRO WHICH ARE REGISTERED TO EUREKA 
---------------------ROUTING THING IT --- uRLS ------------------------	
	Initial

- http://localhost:8765/CURRENCY-EXCHANGE/currency-exchange/from/USD/to/INR

- http://localhost:8765/CURRENCY-CONVERSION/currency-conversion/from/USD/to/INR/quantity/10

- http://localhost:8765/CURRENCY-CONVERSION/currency-conversion-feign/from/USD/to/INR/quantity/10



Lower Case  : BCSE OF spring.cloud.gateway.discovery.locator.lowerCaseServiceId=true

- http://localhost:8765/currency-exchange/currency-exchange/from/USD/to/INR

- http://localhost:8765/currency-conversion/currency-conversion/from/USD/to/INR/quantity/10

- http://localhost:8765/currency-conversion/currency-conversion-feign/from/USD/to/INR/quantity/10




LAB 18 : ---------------Api gateway :------ 



LAB 18 : ---------------Api gateway CUSTOM ROUTES MEANS USE URL AS PER YOUR NEED . THE API GATEWAY WILL MAPP IT TO THE RIGHT ONE IN BACK END  :------ 

@Configuration
public class ApiRouteConfiguration {

    /**
     * this function will help us to map a url for path parameter.
     * @param routeLocatorBuilder
     * @return
     */
    @Bean
    public RouteLocator gatewayRouter(RouteLocatorBuilder routeLocatorBuilder)
    {
        return routeLocatorBuilder.routes().
                route(p -> p.path("/get")
                        .filters(f -> f.addRequestHeader("MYheadre","Header")
                                .addRequestParameter("FirstParm","myparam"))
                                .uri("http://httpbin.org:80"))
                .route(p -> p.path("/currency-exchange/**")
                .uri("lb://currency-exchange"))
                .route(p -> p.path("/currency-conversion/**")
                        .uri("lb://currency-conversion"))
                .route(p -> p.path("/currency-conversion-feign/**")
                        .uri("lb://currency-conversion"))
                .route(p -> p.path("/currency-conversion-new/**")
                        .filters(f ->f.rewritePath("/currency-conversion-new/(?<segment>.*)",
                                "/currency-conversion-feign/${segment}"))
                        .uri("lb://currency-conversion"))
                .build();
    }
}

Custom Routes

- http://localhost:8765/currency-exchange/from/USD/to/INR

- http://localhost:8765/currency-conversion/from/USD/to/INR/quantity/10

- http://localhost:8765/currency-conversion-feign/from/USD/to/INR/quantity/10

- http://localhost:8765/currency-conversion-new/from/USD/to/INR/quantity/10


LAB 18 : ---------------Api gateway CUSTOM ROUTES MEANS USE URL AS PER YOUR NEED . THE API GATEWAY WILL MAPP IT TO THE RIGHT ONE IN BACK END  :------ 

LAB 19 : ------------------Spring boot interceptor -------------------------------------
This interceptor will be calld for each request that comes to the rest api .
In most programming paradigms, interceptors are an essential part that enables programmers to control the execution by intercepting it. Spring framework also supports a variety of interceptors for different purposes.

Spring RestTemplate allows us to add interceptors that implement ClientHttpRequestInterceptor interface. The intercept(HttpRequest, byte[], ClientHttpRequestExecution) method of this interface will intercept the given request and return the response by giving us access to the request, body and execution objects.

https://www.baeldung.com/spring-rest-template-interceptor#:~:text=Spring%20RestTemplate%20allows%20us%20to%20add%20interceptors%20that,access%20to%20the%20request%2C%20body%20and%20execution%20objects.

ClientHttpRequestInterceptor.java is the interface we an used to intercept each incoming request .

public class RestTemplateHeaderModifierInterceptor
  implements ClientHttpRequestInterceptor {

    @Override
    public ClientHttpResponse intercept(
      HttpRequest request, 
      byte[] body, 
      ClientHttpRequestExecution execution) throws IOException {
 
        ClientHttpResponse response = execution.execute(request, body);
        response.getHeaders().add("Foo", "bar");
        return response;
    }
}

LAB 19 : ------------------Spring boot interceptor -------------------------------------

LAB 19 : --------------------------------------Global filters :
Logging framework

LAB 19 : --------------------------------------Global filters :

LAB 20 : -----------Circuit breaker/failover/retry/rate limit  ----------------

		M1-----------> M2----------> M3-----------> M4-------------> M5
		
		
resilience4j.bulkhead.instances.default.maxConcurrentCall=10

resilience4j.ratelimiter.instances.default.limitForPeriod=2
resilience4j.ratelimiter.instances.default.limitRefreshedPeriod=10s

resilience4j.retry.instances.sample-api.maxRetryAttempts=4
resilience4j.retry.instances.sample-api.waitDuration=1s
resilience4j.retry.instances.sample-api.enableExponentialBackoff=true		

1. Resilience4j is the tool for circuit break and failover condition to recover from.
It is an open-source resilience library by Netflix. It provides latency and fault tolerance in a distributed system. It improves the overall resilience of the system by isolating the failing services and stopping the cascading effect of failures. It provides features like circuit break and fallback.

steps : 
1. dep to add 
	AOP 
	resilience4j
	<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-aop</artifactId>
		</dependency>
		<dependency>
			<groupId>io.github.resilience4j</groupId>
			<artifactId>resilience4j-spring-boot2</artifactId>
		</dependency>
2. Create a controller which have a get mapping function 
		write a failed restTemplate call in that get method of controller to a wrong uri.
3. We can use @Retry (name="sample-api",fallBackMethod="methodname") , @Retry is provided by resilience
4. Add below prop in app.yml


retry ---------------------------

@Retry (name="sample-api",fallBackMethod="methodname")

# will go for max retry of 4 the default is 3 
resilience4j.retry.instances.sample-api.maxRetryAttempts=4  
# The wait time between each retry 
resilience4j.retry.instances.sample-api.waitDuration=1s
# the wait time increase exponentially .
resilience4j.retry.instances.sample-api.enableExponentialBackoff=true
retry ---------------------------

Circuit breaker : ----------------
IF the M4 IS DOWN then the resilience circuit breaker feature will know that oops M4 is down so why loading more request to it .
Lets break the circuit and send a default response back .

@CiscuitBreaker(name="sample-api",fallBackMethod="methodname")

There are three states of circuit breaker 

		closed(will send all requests to Micro) ----------------------> open (will not send any request to dead Micro)
						   /\														|
							|                                                       |
							|                                                       |
							|                                                       |
							-----------------half_open (kuch % req will send)<-------


Circuit breaker : ----------------


		
Rate limiter : ----------------

To limit the number of calls to come in 
resilience4j.ratelimiter.instances.default.limitForPeriod=2

resilience4j.ratelimiter.instances.default.limitRefreshedPeriod=10s

@RateLimiter(name="default")



Rate limiter : ----------------

Bulkhead: ----------------

@Bulkhead(name="default")

resilience4j.bulkhead.instances.default.maxConcurrentCall=10

Bulkhead : ----------------

LAB 20 : -----------Circuit breaker/failover/retry/rate limit  ----------------


------------------Lab 21------------------------------------------------------ VVVVVVIIIIIIIMMMMMMMPPPPPPP

We we load the value from the app.yaml file and make it production ready 

Technique 1 : 
	case 1 : using the main app.yaml file 
		- To use @ConfigirationProperties and use prefix = "ticket-booking".
		- then in app.yaml file mention the properties to get value for like this 
				ticket-booking.url = http://localhost:8080/ticket/book/id
				ticket-booking.username = defaultusername
				ticket-booking.key = defaultkey
		- To load the value create a class annotated as @ConfigirationProperties(prefix="ticket-booking") and @Component(to be managed by the spring boot).
			mention three attributes or variable with getter and setter. 
				private String url;
				private String username;
				private String key;
				
		- Create a controller for testing the values getting loaded.

	case 2 : to overrid the these values in app.yaml file from app-dev.yaml file we can make use of the profile active to dev and mention above three in app-dev.yaml
			app.yaml --- to allow dev values to override the value in here 
				logging.level.org.springframework=debug
				#spring.profiles.active=prod
				spring.profiles.active=dev
				ticket-booking.url = http://localhost:8080/ticket/book/id
				ticket-booking.username = defaultusername
				ticket-booking.key = defaultkey
				
			app-dev.yaml 
				ticket-booking.url = http://localhost:8080/PNRvalue/book/id
				ticket-booking.username = IRCTC
				ticket-booking.key = 88wiins77j

				

------------------Lab 21------------------------------------------------------

------------------Lab 22------------------------------------------------------
This lab will help in creating rest api connecting using JDBC and JPA to hibernate(H2 database) which is an in memory database.

Step1 : Dependecies required : 
	Spring web 
	Spring data JPA 
	Spring JDBC 
	Spring hibernate (h2)

Step2 : app.yaml file 

spring.h2.console.enabled=true
spring.datasource.url=jdbc:h2:mem:testdb

Step3 : create schema.sql (file name specific name) and data.sql (to insert the data . file name specfic). I know we can create table using @Entity for a bean but here is the approach to create table using schema.sql.

Step 3 : 
	Approach 1: when we execute query using jdbc we write lot of java code to do that.
	Approach 2 : when we execute query using spring jdbc we will write small LOC.
	Approach 3 : when we execute query using spring JPA we do creation of table using @EntityManager and run query using interface A (interface) extending JPArepository<>.
	Approach 3 : when we execute query using spring DATA JPA we do creation of table using @Entity and run query using interface A (interface) extending JPArepository<>.
	
	We will work using two approaches , Approach 2 and Approach 3 
	
	Approach 2 : will execute the query using Spring jdbc
	
			Step 1 : create a class annotated as @Repository and using JDBCtemplate to call the function to update , insert and delete the data from Db
					  write the insert query to a string variable.
			Step 2 : create a class annotated as a @component so that it can be scanned by the spring boot which auto confoguration. and implements CommandLineRunner interface which is used to run an another fn of any class at springboot context start up.
	
	Approach 3 : Using the usual approach of EntityManager using JPA
	
			Step 1 : create a class annotated as @Repository and using JPArepository to call the function to update , insert and delete the data from Db
					  write the insert query to a string variable.
			Step 2 : create a class annotated as a @component so that it can be scanned by the spring boot which auto confoguration. and implements CommandLineRunner interface which is used to run an another fn of any class at springboot context start up.
	
	Approach 3 : Using the usual approach of EntityManager using Spring data JPA
	
			Step 1 : create a class annotated as @Repository and using JPArepository to call the function to update , insert and delete the data from Db
					  write the insert query to a string variable.
			Step 2 : create a class annotated as a @component so that it can be scanned by the spring boot which auto confoguration. and implements CommandLineRunner interface which is used to run an another fn of any class at springboot context start up.
			
			Spring data JPA , : in this we can not only make use of the functin in the JPArepository but we can also create custom function in the interface which is extending JPArepository 
			
			@Repository
			public interface UserDetailsRepository extends JpaRepository<User_details, Integer> {

				List<User_details> findByName(String name);
			}



------------------Lab 22------------------------------------------------------
Note : CommandLineRunner Interface class is used to run any code function at the start of the spring boot application start up .
-----------------Docker -------------------------------
1. container : an isolated space or a process which runs your application which is dynamic version
2. image : that contain the jar file for a java code , the runtime (jdk ) and run on top of the os stack . its a set of bytes .
3. registry container hub.docker.com 
4. docker engine : manage the images , registry and running containers and also help in cretaing the images and pushing it to docker registry.. It receives the command from docker client for all these activities.
		when we run docker run , the engine check the images availability on system and then go forward for run or to download from registry .

commands : 
1. docker run -p 5000:5000 in28min/todo-rest-api-h2:1.0.0.RELEASE : ------------------ to run the image to create a container .
	When you run the image , its a separate system(isolated from base machine) so you need to map the port to access it.
	-p is the argumemt to map the port of base machine to the port of container which is a seperate isolated system .
		-p (hostport/basemachine):containerport
sudo service docker status ----------------------------------------------------- after installation  will tell the running docker engine service status 
sudo service docker stop
sudo service docker start
sudo service docker restart
docker events ------------------------------------------------------------------ will shw the events (create stop etc )
docker stats : ---------------------------------------------------------------- will show the mem use
docker system df  : ------------------------------------------------------------ how much container , volumens et 
docker info -------------------------------------------------------------------- will give permission denied . the ubuntu user is not in docker group
sudo docker info --------------------------------------------------------------- will give docker installation info
sudo usermod -aG docker ubuntu  ------------------------------------------------ Add ubuntu user id in docker group and reconnect linux 
docker images ------------------------------------------------------------------ to see the images
docker pull ubuntu ------------------------------------------------------------- will pull image ubuntu latest version(official image) .
docker run --name myubuntu ubuntu----------------------------------------------- you can specify the name of the container
docker pull ubuntu:16.04 ------------------------------------------------------- will pull ubuntu 16.04 version where 16.04 is a tag
docker run hello-world --------------------------------------------------------- helloworld is an image and command will create a container on docker engine
docker logs -f imageid : -------------------------------------------------------- to tail te logs of the container app
docker client told ---- docker daemon/engine ---- downloaded image hello-world ---- creates a container --- docker daemon sends the output of running container to ------ docker client (shows message)
docker run ubuntu -------------------------------------------------------------- ran the container and creats the container and existed by not showing  the container(empty container os / only bash program).
docker 
docker ps(docker container ls) ---------------------------------------------------------------------- will show you the list of running container
docker ps -a (docker container ls -a )------------------------------------------------------------------- will show all container (stopped , running).
docker run -it centos ---------------------------------------------------------- you will go into container in interactive mode(start and make connection).
cat /etc/system-release -------------------------------------------------------- will open a file system-release shows the os (output : CentOS Linux release 7.6.1810 (Core))
uname -a ----------------------------------------------------------------------- to see the kernel (centos container uses : Linux 7003536d015c 4.15.0-1044-aws #46-Ubuntu SMP Thu Jul 4 13:38:28 UTC 2019 x86_64 x86_64 x86_64).
exit --------------------------------------------------------------------------- after -it if you exit the container stops
docker run -itd centos---------------------------------------------------------- will send the running container to background and your cursor will on the base VM.
docker run -p 5000:5000 -d -restart=always imagename : ------------------------- This will restart the container once the engine restart 
docker run -p 5000:5000 -d -restart=always  -m 512m imagename : ------------------------- -m how much of mem to allow  
docker run -p 5000:5000 -d -restart=always -m 512m --cpu-quota 5000 imagename : ------------------------- --cpu-quota how much cpu 

docker exec -it container-id ls ------------------------------------------------ exec and -it will create an interactive tunnel to run shell command on container
docker exec -it container-id bash----------------------------------------------- it will lead you to inside the container (container-id you will get after running image docker ps(will give container-Id) )
apt install apache2 ------------------------------------------------------------ once you go inside of container using exec bash install apache2
service apache2 status---------------------------------------------------------- get the status
service apache2 start----------------------------------------------------------- start the apache service
docker commit container-id New-Name -------------------------------------------- will create a new image out of running container. Not ideal way to create image . USE DOCKER FILE
docker stop container-id-------------------------------------------------------- Its stop state but is not removed.
docker kill container-id :------------------------------------------------------ it will kill the container at once .
docker start container-id------------------------------------------------------- It will start the same container which is in stop state
docker run -it New-Nameimage---------------------------------------------------- it will create a container with apace2 installed already 
docker rm container-id---------------------------------------------------------- it will remove the container but first stop it using docker ps -- > then docker stop container-id
docker rm -f  $(docker ps -a -q)------------------------------------------------ it will remove all running container 
docker container prune---------------------------------------------------------- will remove all container in stopped state
docker  image prune -a --------------------------------------------------------- will remove all images 
docker rmi image-id ------------------------------------------------------------ will remove the image with that image id.
docker image history imagename-------------------------------------------------- to check the layer COPY , CMD command level .
docker inspect imagename : -----------------------------------------------------json view of images (env , java home  all that stuff , folder strc)
docker login ------------------------------------------------------------------- login to docker hub (user defined images always starts with username/imagename . docker push image-id will not work)
docker tag imagename dockerhub-username/imagename ------------------------------ rename the image to preferred one
docker push dockerhub-userid or dockerid/repo:imagename---------------------------------------- push the image to docker hub(docker push harmeet24011992/myrepo:imagename)
example : docker image push harmeet24011992/myrepo:firstimage_1.0.2.RELEASE   
docker cotainer unpause/pause containerid :------------------------------------------------------------------------- will pause/unpause the app.
docker container inspect :------------------------------------------------------------------------------------------ info about the container (status , port binding , volume )
docker pull reponame/imagename
docker file:-------------------------------------------------------------------- all steps we did , we can write line by line in docker file and just run the yaml file(best way to create image)
FROM ubuntu---------- -----------------------------------------------------------means we need base image
RUN apt-get update
RUN apt-get install apache2 ----------------------------------------------------- to run command on base image on which we will be installing apache2
ADD . /var/www/Html ------------------------------------------------------------- to add a file. there is a dot(.) which shows current folder files will be add to html
ENTRYPOINT apachectl -D FOREGROUND  or CMD apachectl -D FOREGROUND--------------- Run command on container initialize or  Run command on container starts
ENV DEVOPS INTELLIPAAT----------------------------------------------------------- Create ENV variable
copy / export ------------------------------------------------------------------- check what is it
docker build -t harmeet2401/myimagefromdockerfile .  ---------------------------- command to run docker file to create image
docker push harmeet2401/myimagefromdockerfile
docker run -itd -p 80:80 harmeet2401/myimagefromdockerfile  --------------------- 80:80(host machine-port : container-port)
docker create volume demo-vol---------------------------------------------------- create a volume (pendrive).
docker volume ls ---------------------------------------------------------------- to check the number of pendrives(volumes)
docker run -it --mount source=demo-vol,destination=/app/myspace/ -d unbuntu------ to attach the volume (pendrive) to you container . this command will creates a volume and attached to a folder /app/myspace/ inside new container
docker exec -it container-id bash ----------------------------------------------- go inside new container to run commands do [ls] you will found /app/yspace folder create and file and share it with other container
docker run -it --mount source=demo-vol,destination=/demo/ -d unbuntu------------- launch a new container mounted same volume(pendrive) attached to /demo/ folder 
docker exec -it container-id bash -----------------------------------------------go inside of the container and do [ls] you will find demo folder containing same file present in old container folder /app/myspace/ 
docker run -it -v /home/ubuntu/mount/:/app/ -d ubuntu --------------------------- this will mount the folder on you host machine [BIND MOUNT] be specific of your folder
docker run -it -v /home/ubuntu/mount/:/myspace/ -d ubuntu ----------------------- this is another container (above and this conatiner will get the file present in /home/ubuntu/mount)[BIND MOUNT] be specfic of your folderdo
docker volume rm demo-vol-------------------------------------------------------- to remove the volume
sudo curl -L "https://github.com/docker/compose/releases/download/1.23.1/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose----------- to install docker compose (used to deploy application with multiple container(microservices))
sudo chmod +x /usr/local/bin/docker-compose ------------------------------------- to make its access to execute 
docker-compose version ---------------------------------------------------------- to get the version of docker compose (LEARN ABOUT YAML FILES WHICH CONSISTS OF (MAP AND LISTS))
docker-compose.yml :
version: '3'
services:
  sample1:
    image: 'centos'
  sample2:
    image: 'ubuntu'
  sample2:
    image:  httpd
    ports:
      - "80:80"
docker-compose up -d ------------------------------------------------------------- will download images run multiple containers	  
docker-compose down  ------------------------------------------------------------- it will shutdown the service 
docker run -it --name container1 -d ubuntu --------------------------------------- set the name of the container for linking the containers
docker run -it --name container2 --link container1 -d ubuntu---------------------- linked with container1 on network
docker exec -it container2-id bash ----------------------------------------------- do cat etc/hosts/ , you will find new entry of container1's IP
root ==   apt-get update 
		  apt-get install iputils-ping-------------------------------------------- install ping on container 2 for pinging container1 after linkage
		  ping container1 -------------------------------------------------------- will send you reposne
docker run -it --name container3 --link container2 -d ubuntu --------------------- linking 3rd to 2nd

docker swarm init --advertise-addr=13.233.111.89 --------------------------------- launches a docker swarm master (if your node already part of swarm : docker swarm leave --force).
docker swarm join --token SWMTKN-1-5tyc8iih06c97qflvt0x7pozvuda755ft514gykil7v3p00ctr-1bn8yczjl8n1zmyqfdq3oxmwc 13.233.111.89:2377 ----------------- go to any node , install docker and run this command . take an image of your AWS instance(docker swarm leave --force) to leave a swarm
sudo apt-get install docker.io---------------------------------------------------- launch a new instance and install docker on slave instance
docker node ls ------------------------------------------------------------------- will list the nodes with star or something run this on manager
docker service create --name nam-of-service --replicas nummber-of-replicas 	-p (for port)  image-name ---------------------------------- creates a service
docker service create --name nginx --replicas 3 -p 80:80 nginx
docker service ls ----------------------------------------------------------------- list the service
docker ps  ------------------------------------------------------------------------ on master you will see 1 or 2 containers of nginx
docker ps ------------------------------------------------------------------------- on slave you will see one container of nginx
docker stop container-id	------------------------------------------------------- on master , it will create a new container auto in other slave. thats what swram is
docker network -------------------------------------------------------------------- now above swarm kept containers on different computers.. then we use docker network
docker nework create -d overlay my-overlay----------------------------------------- create a netwrokd
docker service create --name website --replicas 3 --network my-overlay --publish 80:80 hshar/webapp------------------- publishing network
docker service rm service id  ----------------------------------------------------- docker service  ls to get the id 
docker service create --name db --replicas 1 --network my-overlay hshar/mysql:5.6
mysql -u root -p intelli

-------------------docker command -----------------------------------

------------------docker images ---------in java microservices -------------------


steps 

------------------------zipkin distributed tracing system  server using docker ------------------
1. docker run -p 9411:9411 openzipkin/zipkin:2.23




2.  connect all micro to zipkin 
	Add dep 
		sleuth : to generate a unique id for a single transaction 
		sleuth-zipkin
		spring rabbit MQ : to get the message in Queue its a queing framework 
3. sample configuration : to sample small % of request , sampling all req will be performance issue .
	spring.sleuth.sampler.probability=1.0
4. run ur app post that and run a get req and refresh zipkin and run query 

------------------------zipkin db server------------------

	




---------------------------------images creating using pom for java -----------------https://github.com/in28minutes/spring-microservices-v2/tree/main/04.docker
steps : 

1. use maven plugin alrady in pom of yours spring >2.3

			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
				<!--this config below help in creating the image for this app  -->
				<configuration>
					<image>
						<name>harmeet24011992/mmv2-${project.artifactId}:${project.version}</name>
					</image>
					<pullPolicy>IF_NOT_PRESENT</pullPolicy>
				</configuration>
				<!--this config below help in creating the image for this app  -->
			</plugin>

2. Now right click on project -------> maven build -----> goal = spring-boot:build-image -dskipTests
		In intellij you can directly run from plugin and run spring-boot:build-image 

3. do above steps for all 4 apps 
	a. docker run -p 8000:8000 meet14764/mmv2-currency-exchange-service:0.0.1-SNAPSHOT
	b. docker run -p 8100:8100 meet14764/mmv2-currency-conversion-service:0.0.1-SNAPSHOT
	c. docker run -p 8765:8765 meet14764/mmv2-api-gateway:0.0.1-SNAPSHOT
	d. docker run -p 8761:8761 meet14764/mmv2-naming-server:0.0.1-SNAPSHOT
	
	meet14764 is the docker id , need to create that as old images are not getting updated.

4. We can directly push the image to docke hub 

	docker login 
	docker push meet14764/mmv2-currency-exchange-service:0.0.11-SNAPSHOT

---------------------------------images creating using pom for java -----------------


-------------------------docker compose -------------------------------------
docker-compose up 

----------compose file 

Some terms :

1. environment variable : we can set the environment variable in yaml file to inject the value to the application.properties file of the service.
2. network : for theentire arch to be connected 
3. -ports : to map the port of hostmachine to container pod 
4. -mem_limits : to set the mem limit for the container to run 
5. services : the very first tag for the services/Microservice to be part of 
6. depends_on : we can mention the service on which the patent service depends on 



-------------------------docker compose -------------------------------------



------------------docker images ---------in java microservices -------------------


----------------------Kuberenetes-------------------------------------------------------------------

Kubernetes is a container orchestation tool . Which helps in monitoring and managing the container instances running on a host machine.

The features include : 
	scaling up /down
	load balancing
	Maintain the instances running .

There are three services available in the market : 
	AKS : azure kubernetes service (Azure platform )
	EKS : Elastic kubernetes service(AWS platform)
	GKS : Google Kubernetes service(Google) provided by the google cloud platform (GCP)

We will be using GKS by creating the account that will give us free tier to practice kubernetes .

Small example of :
create a dep
run the dep 
autoscale the dep
delete one pod and get other up immediately
create new release version out of the running dep without bringing current one down.

GCP ACCOUNT  : login to it : https://console.cloud.google.com/kubernetes/deployment/us-central1-c/in28minutes-cluster/default/hello-world-rest-api/overview?project=proud-portfolio-324718

meet14764
Gogi@12345


----------------Kubernetes cluster------------------
Manager : manage the nodes , one or more master nodes are managers  , typically one is there .
Cluster consists of nodes 
K8S is KUBERNETES


Node :  Node is a worker node in Kubernetes. Each node will have a unique
     identifier in the cache (i.e. in etcd).
	 
Pod : Pod is a collection of containers that can run on a host. This resource is
     created by clients and scheduled onto hosts.each pod have its own Ip address
			 
CLUSTER 	contain many  	NODE  	contain many      PODS   	contain many       CONTAINERS
        ----------------->        ----------------->         ----------------->
		
Replica set :
     ReplicaSet ensures that a specified number of pod replicas are running at
     any given time.	
		
		
		
in GCP : we can search for KUBERNETES engine -----> enable -----> clusetr -----> create ----> default (3 nodes)

Cluster IP : This will be a private address and doens't have any external IP or public IP address .


Master node : does not contain any app container running on it .
	a. etcd : distributed DB .
	b. kubernetes api server : We were using kubectl ryt ? that is working as we were communicate with KUBERNETESapi server using it .
	c. Scheduler : Is responsible for assigning the container to a pod . randonmly
	d. controller : manage the overall health of cluster . It make sure state of the cluster.
	
Worker node : 
		Kubelet : monitor whats happening on the pod and reports it to master controller .
		kubeproxy : helps in exposing services .
		container runtime : Docker is th emost common runtime to run the container using image .
		
question : 
	we can only run docker container on kubernetes ? Node
	what happn if master goes down ? The app will keep on running .
	
			

STEPS :  
1. First connect to the cluster  : gcloud container clusters get-credentials in28minutes-cluster --zone us-central1-c --project proud-portfolio-324718
2. kubectl : kube controller is an (CLI)command to interact with the cluster .
	fetaure it does : eployment ,	increase instance  and many other things 
	command : 
			a. create dep : kubectl create deployment hello-world-rest-api --image=in28min/hello-world-rest-api:0.0.1.RELEASE 
			b. expose dep : kubectl expose deployment hello-world-rest-api --type=LoadBalancer --port=8080			
			
----------------kubernetes cluster------------------

	
	
---------------------Commands--------------------------------------------------------------------------------------
docker run -p 8080:8080 in28min/hello-world-rest-api:0.0.1.RELEASE
 
kubectl create deployment hello-world-rest-api --image=in28min/hello-world-rest-api:0.0.1.RELEASE---------------------------------- created pod , deployment .
kubectl expose deployment hello-world-rest-api --type=LoadBalancer --port=8080----------------------------------------------------- created a service 
	And a load balancer is also created which exposed a front end IP and on the back end we have pods .
kubectl scale deployment hello-world-rest-api --replicas=3 ------------------------------------------------------------------------increase the replicaset for deployment to 3 pods (and will make sure 3 keeps in running)
kubectl delete pod hello-world-rest-api-58ff5dd898-62l9d
kubectl autoscale deployment hello-world-rest-api --max=10 --cpu-percent=70
kubectl edit deployment hello-world-rest-api #minReadySeconds: 15
kubectl set image deployment hello-world-rest-api hello-world-rest-api=in28min/hello-world-rest-api:0.0.2.RELEASE
 
gcloud container clusters get-credentials in28minutes-cluster --zone us-central1-a --project solid-course-258105
kubectl create deployment hello-world-rest-api --image=in28min/hello-world-rest-api:0.0.1.RELEASE
kubectl expose deployment hello-world-rest-api --type=LoadBalancer --port=8080
kubectl set image deployment hello-world-rest-api hello-world-rest-api=DUMMY_IMAGE:TEST
kubectl get events --sort-by=.metadata.creationTimestamp
kubectl set image deployment hello-world-rest-api hello-world-rest-api=in28min/hello-world-rest-api:0.0.2.RELEASE
kubectl get events --sort-by=.metadata.creationTimestamp

command : kubectl get componentstatuses

Output : 

NAME                 STATUS    MESSAGE             ERROR
scheduler            Healthy   ok
controller-manager   Healthy   ok
etcd-1               Healthy   {"health":"true"}
etcd-0               Healthy   {"health":"true"}



kubectl get pods --all-namespaces
 
kubectl get events
kubectl get pods
kubectl get replicaset
kubectl get deployment
kubectl get service
 
kubectl get pods -o wide
 
kubectl explain pods
kubectl get pods -o wide
 
kubectl describe pod hello-world-rest-api-58ff5dd898-9trh2
 
kubectl get replicasets
kubectl get replicaset
 
kubectl scale deployment hello-world-rest-api --replicas=3
kubectl get pods
kubectl get replicaset
kubectl get events
kubectl get events --sort.by=.metadata.creationTimestamp
 
kubectl get rs
kubectl get rs -o wide
kubectl set image deployment hello-world-rest-api hello-world-rest-api=DUMMY_IMAGE:TEST
kubectl get rs -o wide
kubectl get pods
kubectl describe pod hello-world-rest-api-85995ddd5c-msjsm
kubectl get events --sort-by=.metadata.creationTimestamp
 
kubectl set image deployment hello-world-rest-api hello-world-rest-api=in28min/hello-world-rest-api:0.0.2.RELEASE
kubectl get events --sort-by=.metadata.creationTimestamp
kubectl get pods -o wide
kubectl delete pod hello-world-rest-api-67c79fd44f-n6c7l
kubectl get pods -o wide
kubectl delete pod hello-world-rest-api-67c79fd44f-8bhdt
 
gcloud container clusters get-credentials in28minutes-cluster --zone us-central1-c --project solid-course-258105
docker login
docker push in28min/mmv2-currency-exchange-service:0.0.11-SNAPSHOT
docker push in28min/mmv2-currency-conversion-service:0.0.11-SNAPSHOT
 
kubectl create deployment currency-exchange --image=in28min/mmv2-currency-exchange-service:0.0.11-SNAPSHOT
kubectl expose deployment currency-exchange --type=LoadBalancer --port=8000
kubectl get svc
kubectl get services
kubectl get pods
kubectl get po
kubectl get replicaset
kubectl get rs
kubectl get all
 
kubectl create deployment currency-conversion --image=in28min/mmv2-currency-conversion-service:0.0.11-SNAPSHOT
kubectl expose deployment currency-conversion --type=LoadBalancer --port=8100
 
kubectl get svc --watch
 
kubectl get deployments
 
kubectl get deployment currency-exchange -o yaml >> deployment.yaml 
kubectl get service currency-exchange -o yaml >> service.yaml 
 
kubectl diff -f deployment.yaml
kubectl apply -f deployment.yaml
 
kubectl delete all -l app=currency-exchange
kubectl delete all -l app=currency-conversion
 
kubectl rollout history deployment currency-conversion
kubectl rollout history deployment currency-exchange
kubectl rollout undo deployment currency-exchange --to-revision=1
 
kubectl logs currency-exchange-9fc6f979b-2gmn8
kubectl logs -f currency-exchange-9fc6f979b-2gmn8 
 
kubectl autoscale deployment currency-exchange --min=1 --max=3 --cpu-percent=5 
kubectl get hpa
 
kubectl top pod
kubectl top nodes
kubectl get hpa
kubectl delete hpa currency-exchange
 
kubectl create configmap currency-conversion --from-literal=CURRENCY_EXCHANGE_URI=http://currency-exchange
kubectl get configmap
 
kubectl get configmap currency-conversion -o yaml >> configmap.yaml
 
watch -n 0.1 curl http://34.66.241.150:8100/currency-conversion-feign/from/USD/to/INR/quantity/10
 
docker push meet14764/mmv2-currency-conversion-service:0.0.11-SNAPSHOT
docker push meet14764/mmv2-currency-exchange-service:0.0.11-SNAPSHOT
---------------------Commands--------------------------------------------------------------------------------------
	
	
We can install below CLI to  practice the kubernete on google cloud.
GCloud 
kubectl 	
	
	
Now after installation we can use GCloud to connect to our kubernetes cluster . By copying the command from Google cloud UI 
command  : gcloud container clusters get-credentials in28minutes-cluster --zone us-central1-c --project proud-portfolio-324718

Now use java Api to deploy to kubernetes :
https://github.com/in28minutes/spring-microservices-v2/tree/main/05.kubernetes


Lab 1 : ------------- create a deploymeny using image of an API -----------
Steps : 
1. We have commented out the spring cloud config , eureka netflix (naming server join ) , zipkin(tracing ui) and rabbit MQ (queue framework )
2. all above features are diabled as these are provided by the kbernetes.
3. Connect to the cluster of GCP using GCloud command .
4. build the images of api using spring-boot-image:builder for docker 
5. then push the images to docker hub using 
	docker login 
	docker push dockerid/imagename:tag
	
3. KUBERNETES commands to pull the images and create a deployment
	kubectl create deployment currency-exchange --image=meet14764/currency-exchange-service:0.0.11-SNAPSHOT
	kubectl expose deployment currency-exchange --type=LoadBalancer --port=8000
	kubectl get svc --watch 
	kubectl get pods
	kubectl get replicasets
	kubectl get services 
	
	kubectl create deployment currency-conversion --image=meet14764/currency-conversion-service:0.0.11-SNAPSHOT
	kubectl expose deployment currency-conversion --type=LoadBalancer --port=8100
	kubectl get svc --watch 
	kubectl get pods
	kubectl get replicasets
	kubectl get services 
	
4. Once it is done 
	use the loadbalancer IP 
	Currency Exchange Service kubernetes
- http://loadbalancerIp:8000/currency-exchange/from/USD/to/INR

Currency Conversion Service kubernetes
- http://loadbalancerIp:8100/currency-conversion-feign/from/USD/to/INR/quantity/10

Lab 1 : ------------- create a deploymeny using image of an API -----------


lab 2 : ------------- Declarative approach : Update the deployment of running dpeloyment --------------------

steps : 
1. get the deployment in a deployment.yaml file 
	kubectl get deployment currency-exchange -o deployment.yml
2. get the service deployment in a service.yml file
	kubectl get service currency-exchange -o service.yml
3. Merge both the yamls in a common file separated by    ---
4. check the diff after changing the replica value for example  ,kubectl diff -f  deployment.yml
5. Then apply the updated yaml : kubeclt apply -f deployment.yml
6. post applying the yaml we will get the new desired state with changed replica for currency-exchange pods.




lab 2 : ------------- Update the deployment of running dpeloyment --------------------	


Lab 3 : ------------- Clean up yaml for kubernetes-----------


Rolling update : one pod update at a time.
Lab 3 : ------------- Clean up yaml for kubernetes-----------

Lab 4 : -------------Tracing logs and api actvation on GCP ----------

steps : 

1. Search for Api and Services on GCP. ------ > Enable apis and services .----> logging ---> cloud logging api ----> enable it .
																	   ----> stackdriver ---> enable all driver api 															   
2. kubectl delete all -l app=hello-world-rest-api
3. kubectl get all : --- to get all the artefacts of the deplyment if any 
4. kubectl apply -f deployment.yml : ------- > create a deployment and srevice using the yaml . As we created using the create and expose command 
5. now change anything in the yaml file and run : kubectl apply -f deployment.yml .

			NICEEEEEEEEEEEEEEEEEEEEEEEEEEEE!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
																   

Lab 4 : -------------Tracing logs and api actvation on GCP ----------
	
	

Lab 5 : -------------Custom Environment variables ---------------------

As we know when the currency-exchange pod comes up kubernete will create some env variables . 
which also include  : CURRENCY_EXCHANGE_SERVICE_HOST  , HOSTNAME(pod name )

The env var is used by the currency-conversion for feign hit .



Lab 5 : -------------Custom Environment variables ---------------------

lab 6 : --------------centralized configuration ------------------
As we are hardcoding the env variable value in yaml file , which results in redeploy the yaml whenever the ENV variable value changes .
So KUBERNETES provides centralized config set up .
steps : 
1. kubectl create configmap hello-world-rest-api --from-literal= HELLOW-WORLD-STRING-MESSAGE="ola bom dia"

apiVersion: v1
data:
  MESSAGE_STRING: BOMDIA
kind: ConfigMap
metadata:
  name: hello-world-rest-api
  namespace: default


lab 6 : --------------centralized configuration ------------------


lab : 7 :------------centralized logging in GKE which is in Google platform -------------
We can aggregate the logs to GKE cluste .

View logs : 
https://console.cloud.google.com/logs/query;query=resource.type%3D%22k8s_container%22%0Aresource.labels.pod_name%3D%22hello-world-rest-api-dcf9cc87d-x67jd%22%0AtextPayload:helloWorld;cursorTimestamp=2021-09-06T18:44:01.429354916Z?project=proud-portfolio-324718

We can also run queries on the pods logs as the logs for all the pods gets accumulated in the KUBERNETES clusters.


View Dashboard : 
This will show all the metrics from services till container level .

lab : 7 :------------centralized logging in GKE which is in Google platform -------------


lab : 8 :------------Microservice Deployment  -------------

1. Rollout(means make present up and running and then bring other pods down) history deployment of kubernetes cluster using deployment .
2. In case we made a deployment change and do a wring deployment like invalid image . Then kubernetes will keep the old pods running untill new one comes up correctly 
command : 
1.  kubectl rollout history deployment hello-world-rest-api ------------------------------------------------------ To check the rollout history for deployment 
2. kubectl rollout undo deployment hello-world-rest-api  --to-revision=1  ---------------------------------------- to bring the deployment to the stable version .
3. While going from one to other deployment while making the chnage , there will be a DOWNTIME .

lab : 8 :------------Microservice Deployment  -------------


lab : 9 :------------ OVERCOME THE DOWNTIME -------------
Probes and readiness provide by kubernetes

Probes : a health check hit to the service 

Two kinds : 
	readiness probes : K8 sends these probes if un-successfull then no traffic will be send to the micro/
	liveliness probes  : K8 sends these probes if un-successfull then pods will be restarted.

Spring boot Actuator : provide these readiness .
		We have been adding these since .
steps : 
			1. Add prop in app.yml of micro which we will deploy .:
				management.endpoint.health.probes.enabled=true
				management.health.livenessStage.enabled=true
				management.health.redinessStage.enabled=true
			2. localhost:8080/actuator/health : 	
					This will give {status  : "up" ,groups : ["liveness","readiness"] }
			3. localhost:8080/actuator/health/liveness
			4. localhost:8080/actuator/health/readiness
			5. We can use above probes to get configured in k8 for health check .
				need to update the deployment.yaml for it :
		readinessProbe:
          httpGet:
            port: 8080
            path: /actuator/health/readiness
        readinessProbe:
          httpGet:
            port: 8080
            path: /actuator/health/liveness 
			
			6. post adding above is we can change the version , then the health probe will overcome the DOWNTIME .
				AND KEEP ON SENDING THE PROBE TO OLD PODS . ONCE NEW POD IS READY TO RECEIVE TRAFFIC IT WILL DELETE OLD PODS.



lab : 9 :------------ OVERCOME THE DOWNTIME -------------


lab : 10 :------------ Auto scaing  -------------
kubectl autoscale deployment currency-exchange --min=1 --max=3 --cpu-percent=5  ------ this will create horizontal pod auto scaler : this will add new pods when the cpu-% is greater tham 5 % .

kubectl delete hpa hello-world-rest-api ---------------- will delete the hpa horizontal pod auto scaler which was sole responsible for scaling the pod.

lab : 10 :------------ Auto scaing  -------------


	
----------------------Kuberenetes-------------------------------------------------------------------	
	