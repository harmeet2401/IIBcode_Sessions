⁸ {

id 
name
category  : 

HashCode (){

}



}


find all the 

list.stream().filter(p -> p.getcategory().eqaual("elec")).collect(Collectors.toList())

list.stream().collect(Collectors.toMap(product::id,product->product))

Map<String , List<Product>> map = list.stream().collect(Collectors.groupingBY(product::getca`tegory)) 

list.stream().MaptoObject(product::getcategory).collect(Collectors.groupingBy(Object::new))

String a = "aba" ;
StringBuilder str = new StringBuilder();
for (int i = a.length()-1 ; i >= 0  ; i--){
	str.append(s.charAt(i));
}
if(a.equalsIgnore(str.toString())){ 
 System.out.print("its a palidrome")
}

O(2n)
Zookeeper
Kafka cluster --- > node ---> topics(). 

Revise kafka logics.

Db questions.

----------------------------

Q. Check string is anagram ?

import java.util.Arrays;

public class AnagramChecker {
    public static boolean areAnagrams(String str1, String str2) {
        // Remove spaces and convert strings to lowercase
        str1 = str1.replaceAll("\\s", "").toLowerCase();
        str2 = str2.replaceAll("\\s", "").toLowerCase();

        // Check if lengths are equal
        if (str1.length() != str2.length()) {
            return false;
        }

        // Convert strings to char arrays and sort them
        char[] charArray1 = str1.toCharArray();
        char[] charArray2 = str2.toCharArray();
        Arrays.sort(charArray1);
        Arrays.sort(charArray2);

        // Compare sorted char arrays
        return Arrays.equals(charArray1, charArray2);
    }

    public static void main(String[] args) {
        String str1 = "listen";
        String str2 = "silent";

        if (areAnagrams(str1, str2)) {
            System.out.println(str1 + " and " + str2 + " are anagrams.");
        } else {
            System.out.println(str1 + " and " + str2 + " are not anagrams.");
        }
    }
}

Q. Reverse a string ?
public class ReverseString {
    public static String reverse(String str) {
        StringBuilder reversed = new StringBuilder();
        for (int i = str.length() - 1; i >= 0; i--) {
            reversed.append(str.charAt(i));
        }
        return reversed.toString();
    }

    public static void main(String[] args) {
        String original = "hello";
        System.out.println("Original string: " + original);
        System.out.println("Reversed string: " + reverse(original));
    }
}

Q. Write a program to check for palidrome ?

public class PalindromeCheck {
    public static boolean isPalindrome(String str) {
        int left = 0;
        int right = str.length() - 1;
        while (left < right) {
            if (str.charAt(left++) != str.charAt(right--)) {
                return false;
            }
        }
        return true;
    }

    public static void main(String[] args) {
        String palindrome = "radar";
        System.out.println("Is \"" + palindrome + "\" a palindrome? " + isPalindrome(palindrome));
    }
}

Q. Fibonacci series ?

public class FibonacciSeries {
    public static void printFibonacci(int n) {
        int prev = 0, next = 1;
        System.out.print(prev + " " + next + " ");
        for (int i = 2; i < n; i++) {
            int sum = prev + next;
            System.out.print(sum + " ");
            prev = next;
            next = sum;
        }
    }

    public static void main(String[] args) {
        int count = 10; // Number of terms in the series
        System.out.println("Fibonacci series up to " + count + " terms:");
        printFibonacci(count);
    }
}

Q. Anagram check using java code ?
An two strings are anagram only if all chars are used to create a new words and each char is used exactly once .

import java.util.Arrays;

public class AnagramChecker {
    public static boolean areAnagrams(String str1, String str2) {
        char[] charArray1 = str1.toCharArray();
        char[] charArray2 = str2.toCharArray();
        Arrays.sort(charArray1);
        Arrays.sort(charArray2);
        return Arrays.equals(charArray1, charArray2);
    }

    public static void main(String[] args) {
        String str1 = "listen";
        String str2 = "silent";
        if (areAnagrams(str1, str2)) {
            System.out.println(str1 + " and " + str2 + " are anagrams.");
        } else {
            System.out.println(str1 + " and " + str2 + " are not anagrams.");
        }
    }
}

Q. As you are going to explain about the scribe project ? using spring scheduler and the rest api?

import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

@Component
public class MyScheduledTask {

    @Scheduled(fixedRate = 5000) // Executes every 5 seconds
    public void executeTask() {
        System.out.println("Executing scheduled task...");
        // Your task logic goes here
    }

    @Scheduled(cron = "0 0 12 * * ?") // Executes every day at 12:00 PM
    public void executeDailyTask() {
        System.out.println("Executing daily scheduled task...");
        // Your task logic goes here
    }
}


Q. Read about interceptor and how to fetch the value from the JWT tokem from it.?

There are two ways by which we can intercept the request coming from consumer on internet and allow a better authentication and authorization process : 

	1. Filters intercept requests before they reach the DispatcherServlet, making them ideal for coarse-grained tasks such as:
		Steps : 
			1. Create a class which implements either javax.servlet.Fiter or jakarta.servlet.Filter and overide the doFilter(req , res , chain ) and it 
				return the chain.doFilter(req,res)
			2. Then register the ABC class implented Filter interface  by creating a configuration class annotated as @configuration , iss class which assi 				kissi vi class da bean 	create kr skde han which need explicit instantiation and add it to classpath.

		Uses : 
		Authentication
		Logging and auditing
		Image and data compression
		Any functionality we want to be decoupled from Spring MVC
	
	
	2. HandlerIntercepors, on the other hand, intercepts requests between the DispatcherServlet and our Controllers. This is done within the Spring MVC framework, 		providing access to the Handler and ModelAndView objects. This reduces duplication and allows for more fine-grained functionality such as:

		Steps :
			1. Create a class which implements either HandlerInterceptor and overide the prehandle(),posthandle() and afterCompletion and it 
				return the chain.doFilter(req,res)
			2.  Then register the ABC class implented HandlerInterceptor interface  by creating a configuration class annotated as @configuration , iss class 			which assi kissi vi class da bean 	create kr skde han which need explicit instantiation and add it to classpath.
		Uses :
		Handling cross-cutting concerns such as application logging
		Detailed authorization checks
		Manipulating the Spring context or model



Q. HashCode and equal contract principle?
The hashCode() and equals() methods in Java are fundamental to working with objects, particularly when dealing with collections like HashMap, HashSet, etc. Understanding the contract between these methods is crucial for correctly using these collections.

hashCode() Method:
The hashCode() method returns an integer hash code value for the object. This value is typically used to improve the performance of hash-based collections like HashMap, HashSet, etc.
The general contract of hashCode() method is:
If two objects are equal according to the equals() method, then they must return the same hash code value.
It is not required that if two objects have different hash code values, then they must be unequal.which occurs when hash collision occurs due to finite hashcode (32 bits) available. sometime has ode fn for two unequal object generate same hashindex and results in collision However, it is generally desirable for performance reasons.
The hashCode() method should be overridden in a class whenever equals() is overridden.

equals() Method:
The equals() method is used to compare two objects for equality. It returns true if the objects are considered equal, and false otherwise.
The general contract of equals() method is:
It is reflexive: For any non-null reference value x, x.equals(x) should return true.
It is symmetric: For any non-null reference values x and y, x.equals(y) should return true if and only if y.equals(x) returns true.
It is transitive: For any non-null reference values x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true.
It is consistent: For any non-null reference values x and y, multiple invocations of x.equals(y) consistently return true or consistently return false, provided no information used in equals() comparison on the objects is modified.
For any non-null reference value x, x.equals(null) should return false.

Q1.How are Kubernetes and Docker related?
Kubernetes and Docker are both technologies that are widely used in modern software development and deployment, especially in the context of containerization.

Docker is a platform and a set of tools designed to make it easier to create, deploy, and run applications using containers. Containers allow developers to package an application and its dependencies into a standardized unit that can run virtually anywhere, providing consistency across environments. Docker Engine was one of the first container runtimes supported by Kubernetes, and it is still widely used with Kubernetes clusters.

Kubernetes : Kubernetes, often abbreviated as K8s, is an open-source container orchestration platform that automates the deployment, scaling, and management of containerized applications. It provides features such as automatic scaling, self-healing, service discovery, and load balancing, making it easier to manage and scale containerized applications in production environments.


Q2.What is the difference between deploying applications on hosts and containers?

Environment Isolation:

Hosts: Traditional deployment on hosts involves running applications directly on physical or virtual machines (hosts). Each application typically runs within its own environment on a dedicated host, isolated from other applications.

Containers: Containers provide lightweight and isolated runtime environments for applications. Multiple containers can run on the same host, each with its own filesystem, process space, and network stack. Containers offer stronger isolation compared to traditional processes running on a host, but they share the same underlying operating system kernel.

Resource Utilization:

Hosts: Deploying applications on hosts can lead to underutilization of resources, as each application typically requires dedicated resources on the host machine, even if it doesn't fully utilize them.

Containers: Containers allow for better resource utilization, as multiple containers can share the same underlying host resources. Container orchestration platforms like Kubernetes can automatically schedule and manage containers across a cluster of hosts, optimizing resource allocation based on application requirements.

Deployment Consistency:

Hosts: Deploying applications on hosts can lead to deployment inconsistencies, as different hosts may have different configurations, dependencies, or environments, potentially leading to issues with portability and scalability.

Containers: Containers provide consistency in deployment, as they encapsulate the application and its dependencies into a single unit that can be deployed across different environments without modification. Containers ensure that the application runs consistently regardless of the underlying host environment.

Isolation and Security:

Hosts: Deploying applications on hosts provides strong isolation between applications, as each application runs on its own host. However, managing security updates, vulnerabilities, and access control on individual hosts can be challenging.

Containers: Containers offer isolation between applications using lightweight virtualization. Each container has its own isolated filesystem and runtime environment, reducing the risk of interference between applications. However, containers share the same underlying kernel, which may pose security risks if not properly configured or managed.

Scalability and Agility:

Hosts: Scaling applications deployed on hosts may require provisioning and configuring additional hosts, which can be time-consuming and complex.

Containers: Containers enable rapid scaling and agility, as new instances of containers can be spun up or down dynamically based on workload demands. Container orchestration platforms like Kubernetes provide automated scaling and management capabilities, allowing applications to scale seamlessly in response to changes in demand.


Q3.Explain the working of the master node in Kubernetes?
In Kubernetes, the master node, also known as the control plane, is responsible for managing the cluster and coordinating its components.
Components : 
Api server :
The API server is the central management point of the Kubernetes control plane.
It exposes the Kubernetes API, which allows users and external components to interact with the cluster.
All administrative tasks, such as creating, updating, and deleting resources (pods, services, deployments, etc.), are performed through the API server.

ETCD:
tcd is a distributed key-value store used by Kubernetes to store all cluster configuration data and state.
It serves as the source of truth for the entire cluster and maintains a consistent and reliable representation of the cluster's state.
The master node interacts with etcd to read/write cluster configuration, store operational data, and maintain consensus among cluster members.

Kube scheduler :
The scheduler is responsible for scheduling pods onto nodes in the cluster.
It evaluates various factors such as resource requirements, node capacity, and affinity/anti-affinity rules to determine the optimal placement of pods.
The scheduler continuously monitors the cluster state and schedules pods as needed to maintain the desired workload distribution.

Contoller manager :
The controller manager is a collection of controllers that monitor the cluster state and perform automated tasks to maintain the desired state.
Controllers include the Node Controller (manages nodes), ReplicaSet Controller (ensures desired pod replicas), Deployment Controller (manages deployments), Service Controller (manages services), and others.
Each controller watches specific resources and takes corrective actions to reconcile the current state with the desired state.
Cloud controller manager

Q4.Situation based question on Kubernetes

Q5. DB Question like join , groupingBY and partition. Query.


Certainly! Here are some questions along with sample SQL queries to illustrate the concepts of database joins, grouping by, and partition by:

1. **Database Joins:**
   - *Question*: What are the different types of database joins?
     *Answer*: There are four main types of database joins:
       - INNER JOIN: Returns rows when there is a match in both tables.
       - LEFT JOIN (or LEFT OUTER JOIN): Returns all rows from the left table and matching rows from the right table.
       - RIGHT JOIN (or RIGHT OUTER JOIN): Returns all rows from the right table and matching rows from the left table.
       - FULL OUTER JOIN: Returns all rows when there is a match in either table.

   - *Question*: How would you optimize a query involving multiple joins for performance?
     *Answer*: Some optimization techniques for queries involving multiple joins include:
       - Ensuring proper indexing on join columns.
       - Using selective WHERE clauses to filter data early in the query execution.
       - Limiting the number of columns selected to only those needed.
       - Considering denormalization if appropriate to reduce the number of joins.

   - *Question*: Can you provide an example of a self-join?
     *Answer*: Sure! Here's an example of a self-join to find employees who share the same manager:
       ```sql
       SELECT e1.Name AS Employee, e2.Name AS Manager
       FROM Employees e1
       JOIN Employees e2 ON e1.ManagerId = e2.EmployeeId;
       ```

2. **Grouping By:**
   - *Question*: How do you use the GROUP BY clause along with aggregate functions like SUM, AVG, COUNT, etc.?
     *Answer*: Here's an example of using GROUP BY with SUM to find the total sales amount for each product category:
       ```sql
       SELECT ProductCategory, SUM(SalesAmount) AS TotalSales
       FROM Sales
       GROUP BY ProductCategory;
       ```

   - *Question*: What is the purpose of the HAVING clause?
     *Answer*: The HAVING clause is used in combination with the GROUP BY clause to filter groups based on aggregate conditions. Here's an example:
       ```sql
       SELECT ProductCategory, SUM(SalesAmount) AS TotalSales
       FROM Sales
       GROUP BY ProductCategory
       HAVING SUM(SalesAmount) > 10000;
       ```

3. **Partition By:**
   - *Question*: What is database partitioning, and why is it used?
     *Answer*: Database partitioning involves dividing a large table or index into smaller, more manageable parts. It's used for performance optimization, data management, and scalability.

   - *Question*: Can you explain the concept of range partitioning and provide an example?
     *Answer*: Range partitioning divides data based on a range of values. Here's an example of creating a range partitioned table:
       ```sql
       CREATE TABLE Orders (
           OrderId INT,
           OrderDate DATE,
           ...
       ) PARTITION BY RANGE (YEAR(OrderDate)) (
           PARTITION p0 VALUES LESS THAN (2010),
           PARTITION p1 VALUES LESS THAN (2011),
           PARTITION p2 VALUES LESS THAN (2012),
           ...
       );
       ```

These queries and explanations should help illustrate how to use joins, grouping by, and partition by in SQL databases.

Q. What is an anagram and java code for it ?
twonstrijgs are anagram of each other if each character is used exactly once and all

import java.util.Arrays;

public class AnagramChecker {
    public static boolean areAnagrams(String str1, String str2) {
        // Remove spaces and convert strings to lowercase
        str1 = str1.replaceAll("\\s", "").toLowerCase();
        str2 = str2.replaceAll("\\s", "").toLowerCase();
        
        // If lengths are different, they can't be anagrams
        if (str1.length() != str2.length()) {
            return false;
        }
        
        // Convert strings to char arrays and sort them
        char[] charArray1 = str1.toCharArray();
        char[] charArray2 = str2.toCharArray();
        Arrays.sort(charArray1);
        Arrays.sort(charArray2);
        
        // Compare sorted arrays
        return Arrays.equals(charArray1, charArray2);
    }
    
    public static void main(String[] args) {
        String str1 = "listen";
        String str2 = "silent";
        
        if (areAnagrams(str1, str2)) {
            System.out.println(str1 + " and " + str2 + " are anagrams.");
        } else {
            System.out.println(str1 + " and " + str2 + " are not anagrams.");
        }
    }
}



Q7. Read about kafka. done 

Q8. How to calculate the time complexity of java code.

Q8. What is cognitive and cyclometric complexity  in java code?

Cyclomatic Complexity is a software metric used to measure the complexity of a program by counting the number of linearly independent paths through the program's source code.
It is based on the control flow of the program and is calculated using a graph-based approach, where the nodes represent the decision points in the code (such as if statements, loops, and switch statements) and the edges represent the possible transitions between decision points.
The formula to calculate cyclomatic complexity is: M = E - N + 2P, where E is the number of edges, N is the number of nodes, and P is the number of connected components (regions) of the graph.
A higher cyclomatic complexity value indicates a higher degree of complexity and suggests that the code may be more difficult to understand, test, and maintain.
Cognitive Complexity:

Cognitive Complexity is a software metric introduced by SonarQube to measure the complexity of code based on how difficult it is for a human to understand the code.
Unlike Cyclomatic Complexity, which is purely based on the control flow of the program, Cognitive Complexity considers additional factors such as nesting depth, logical operators, and the presence of complex structures that may increase the cognitive load on developers.
Cognitive Complexity aims to provide a more accurate reflection of the mental effort required to comprehend the code and make it more maintainable and readable.
It is not directly calculated from the source code like Cyclomatic Complexity, but rather is assessed based on a set of rules and heuristics that evaluate various aspects of the code structure and organization.

Best Practices:
Keep methods short and focused, with a single responsibility.
Refactor complex logic into smaller, more modular components.
Avoid excessive nesting and deeply nested control structures.
Use descriptive variable names and comments to clarify intent.
Simplify boolean expressions and refactor complex conditions.
Use meaningful abstractions and design patterns to improve code readability and maintainability.

Q9. What Spring Boot features help develop Microservices Applications?

Spring boot dependency injection feature and integrated web server names tomcat allow it to help develop microservice architecture.
Spring bootable capability will allow to create a microservice which needs to run on a continuous basis
Some of these are listed below :
Emebedded server
Spring data jpa
Spring cloud 
spring security
spring actuator
Externalized app properties 
Autoconfiguration.

5.Why Spring Boot is preferred over any other framework?
Emebedded server
Spring data jpa
Spring cloud 
spring security
spring actuator
Externalized app properties 
Autoconfiguration.

6.Situation based question on Spring boot

7.Situation based question on AWS

8.Situation based question on Angular

8. difference between java 8 and java 11 ?

-HTTP CLIENT :
Java 11 introduced a new HttpClient API in the java.net.http package for making HTTP requests.

-  String methods addes :
 Java 11 introduced several new methods to the String class like isBlank(), strip(), stripLeading(), and stripTrailing() for improved string manipulation.

String str = "  Hello World  ";
System.out.println(str.isBlank());  // Output: false
System.out.println(str.strip());   // Output: Hello World

- TLS1.3 support :
Java 11 adds support for TLS 1.3, the latest version of the Transport Layer Security protocol, for improved security.

- Epsilon Garbage Collector :
Java 11 introduced the Epsilon garbage collector, a no-op garbage collector useful for performance testing and zero-overhead scenarios.

- Flight Recorder :
Java 11 includes Java Flight Recorder (JFR) in the OpenJDK, enabling low-overhead performance monitoring and profiling.



9. What is difference java 11 and 17 

Below added in java 17:

- SEALED CLASSES :
Sealed classes restrict which other classes or interfaces may extend or implement them.

public sealed class Shape permits Circle, Square, Triangle {
    // Common properties and methods
}

final class Circle extends Shape {
    private final double radius;

    public Circle(double radius) {
        this.radius = radius;
    }

    // Circle-specific methods
}

final class Square extends Shape {
    private final double sideLength;

    public Square(double sideLength) {
        this.sideLength = sideLength;
    }

    // Square-specific methods
}

final class Triangle extends Shape {
    private final double base;
    private final double height;

    public Triangle(double base, double height) {
        this.base = base;
        this.height = height;
    }

    // Triangle-specific methods
}

- PATTERN MATCHIMG FOR SWITCH :
Enhances the switch statement to use pattern matching for more concise and readable code.

String result = switch (obj) {
    case String s -> "String: " + s;
    case Integer i -> "Integer: " + i;
    default -> "Unknown object";
};

- FOREIGN FUNCTION AND MEMORY API :
Introduces an API for interacting with native code and memory, including foreign function handles, function pointers, and direct memory access.

var functionHandle = FunctionHandle.ofAddress(handle, MethodType.methodType(int.class, int.class));
int result = (int) functionHandle.invokeExact(42);

- STRONG ENCAPSULATION JDK INTERNALS :
Enhances encapsulation of JDK internals by enforcing stronger encapsulation for critical internal APIs.

- NEW MACOS RENDERING PIPELINE :
Introduces a new rendering pipeline for macOS, replacing the deprecated CGL-based pipeline with a Metal-based pipeline

- DEPRECATION OF RMI ACTIVATION FOR REMOVAL :
Deprecates RMI Activation for removal in a future release, marking it as a deprecated module.

- REMOVAL OF EXPERIMENTAL AOT AND JIT :

Removes the experimental AOT and JIT compiler Graal as well as the jdk.aot and jdk.internal.vm.compiler modules.



10. what is switch function? The new switch function in 177

In java 17 the old switch function is enhanced to provide more readability and concise code.

String result = Switch(dayofweek)
       {
         case 1 -> "first week";
         case 2 -> "second week";
         default -> "last week";
        }

10. Kafka - how many topic in Kafka, consumer side, how will you handle production and the Kafka report You have to find out if any file is missing.

15 to 20 Min questions in Kafka side only, other spring boot and JAVA
1) can we override static method and explain?
ans :
 No we cannot override the static method.
When you declare a static method in a class, it's tied directly to the class's definition in memory. As a result, it doesn't make sense to override a static method in a subclass because the method belongs to the class, not to any instance of the class.

a) Inheritance vs hiding : when a subclass declares a static method with the same signature as a static method in the superclass, it doesn't override the superclass's static method. Instead, it hides it. This means that the subclass's static method is only associated with the subclass itself, and the superclass's static method remains unaffected.

b) Method lookup : In java, method resolution (determining which method to call) is based on the type of the reference variable, not on the runtime type of the object. Since static methods are associated with the class, not with the object, there's no polymorphic behavior to override.

c) Compile time binding :
Method overriding in Java relies on dynamic (runtime) binding, where the appropriate method implementation is determined at runtime based on the actual type of the object. However, static methods are bound at compile time based on the reference type, so there's no dynamic dispatch involved.

example :
class Parent {
    static void static Method() {
        System.out.println("Parent's static method");
    }
}

class Child extends Parent {
    static void static Method() {
        System.out.println("Child's static method");
    }
}

public class Main {
    public static void main(String[] args) {
        Parent.staticMethod(); // Calls Parent's static method
        Child.staticMethod();  // Calls Child's static method
        Parent obj = new Child();
        obj.staticMethod();    // Calls Parent's static method
    }
}
example above, even though the object obj is of type Child, the call obj.staticMethod() still invokes the Parent class's static method because static methods are bound at compile time based on the reference type (Parent), not on the runtime type of the object (Child).

2) related marker interface one question?
ans : Marker interfaces are also known as "tagging interfaces" or "empty interfaces." They provide a way to categorize or classify classes based on certain characteristics without adding any additional methods or fields.

public interface SerializableMarker {
    // This interface doesn't contain any methods or fields
    // It's used solely for marking purposes
}



3) shallow copy and deep copy
Its used in prototype pattern. When we tried to make a clone of the object we use either copy constructur or cloneable interface to do that.

Shallow copy : Will restrict the copy nested objects for easy fetch gives higher perf .
Deep copy . Will fetch all the objects from the chilc objects as well.

4) some questions related to spring boot
 
 
Microservice Architecture Pattern --> Explain the same in the project : done 

Kafka Architecture --> producer / Consumer : done

Q. if there are two microservice with different consumer if one consumer consumes messages and other not what can be the issue in production ?

ans : there is a possibility that the 2nd consumer application is down and the consumer which is bound to read messages from the partition is not working.

To resolve this we can use the orchestration tool to maintain the desired state and keep the consumption of message in progress.


Q. Lagging in Kafka how will you handle ?

- Increase consumer parallelism :
If a single consumer instance is unable to keep up with the message throughput, you can increase consumer parallelism by adding more consumer instances within the consumer group. This allows for better distribution of message processing across multiple consumers.

- Adjust consumer comfigurartion :
fetch.max.bytes, fetch.max.wait.ms, max.poll.records, and max.partition.fetch.bytes based on your application's requirements and the expected message throughput.

- Increase partition :
Increasing the number of partitions for a Kafka topic allows for better parallelism and distribution of messages across consumers. However, this should be done with caution, as changing the number of partitions can have implications for message ordering and data retention.

- Scale Kafka cluster :
if the Kafka cluster itself is the bottleneck, consider scaling it horizontally by adding more brokers or vertically by upgrading hardware resources such as CPU, memory, and storage.


Benefits of microservice architecture --> why you used different schemas in database of architecture.

CI/CD piple jenkins pattern build questions.

AWS project related questions --> where you used ? how and architecture?


2 coding questions : done 

Product list --> group by type and list : done

remove duplicates from List of products without using hashset ; done 
 
 
introduction : done 

describe past project : done 

Overall tech stack details : done java , spring boot, aws , kafka 

soap vs rest : op protocol vs methodology (architecture)

how do you authenticate in your existing application : using interceptor and basic authentication . Interceptor ke liye read kro. : done 

authentication vs authorization : done 
	1. authentication using the interceptor which urls are widelisted . We can also use spring security for the same. We can also intercept the request get the token 			coming in the header which can contain the user ID assigned to each consumer and then we can extract the from the token and hit the external api to get 		the details.
	2. authorization is the process in which which resource the api or service uri is allowed to acess.  @PostAuthorize("returnObject.owner == authentication.name").
		below code will allow only owner whose name is authentiction.name ye property hai kuch naam hogga . Isko class level pr bhi set kr skte hai 
		import org.springframework.security.access.prepost.PostAuthorize;
		public class MyService {
		    @PostAuthorize("returnObject.owner == authentication.name")
		    public MyObject findObjectById(Long id) {
		        // Implementation to fetch MyObject by id
		        return myObject;
		    }
		}


- oauth vs jwt :
OAuth (Open Authorization) and JWT (JSON Web Token) are both commonly used in authentication and authorization systems.
1. JWT(Json Web token) : JWT is a compact, self-contained way of transmitting information between parties as a JSON object. It is commonly used for authentication and as a way to securely transmit information between parties.
2. OAuth : It is typically used for delegated authorization scenarios, such as when you want to allow a third-party application (like a mobile app) to access certain resources (like user data) on your behalf without sharing your credentials.


how to logs the exception in spring/springboot application : log4j or slf4J 
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class MyClass {
    private static final Logger logger = LoggerFactory.getLogger(MyClass.class);

    public void myMethod() {
        logger.info("This is an info message");
        logger.error("This is an error message");
    }
}


Transaction, propagation & isolation : @Transaction(isolation , propgation and rollbackfor.)

Q. Describe advice concept in spring:
		There are several types of advice in Spring AOP:
		
		- Before Advice:
		
		Before advice is executed before a join point, typically before the method is invoked. It can be used, for example, for logging or security checks before a method is called.
		- After Returning Advice:
		
		After returning advice is executed after a join point completes successfully (i.e., without throwing an exception). It can be used, for example, to log the return value of a method.
		- After Throwing Advice:
		
		After throwing advice is executed if a join point throws an exception. It can be used, for example, to handle exceptions or log error messages.
		- After (Finally) Advice:
		
		  After (finally) advice is executed regardless of the outcome of the join point (i.e., whether it completes successfully or throws an exception). It can be used for clean-up tasks, such as closing resources.

		- Around Advice:
		
		Around advice is the most powerful type of advice, as it can intercept the join point and control the behavior before, after, or instead of the method invocation. It can be used to implement custom behavior, such as performance monitoring or caching.


For Monetary applications, which one to prefer soap or rest?and why?
Introduction

2. Describe past project : done 

3. Overall tech stack details : done 

4. JPMC project tech stack : no

5. What do mean by String Immutability  and tell me output of below code . done .

              Ex:

                             String name = "Dilip"

                                    name = "Kumar";

                             System.out.println (name);

6. What is the contract between equals() and hashCode() ? : done 

7. Internal functionality of HashMap ? : done

8. How to handle Transaction. What are the attributes of Transactional ? : done 

    Could you please explain all attributes and what is the use of those attributes .

9.  What is Normalization. How you can de-normalize the data/table . : 
Normalization typically involves dividing a database into multiple tables and defining relationships between them using foreign keys. There are several normal forms, each with its own set of rules.

First Normal Form (1NF): Ensures that each column contains atomic (indivisible) values, and there are no repeating groups of columns.
Second Normal Form (2NF): Ensures that non-key attributes are fully functionally dependent on the primary key.
Third Normal Form (3NF): Ensures that non-key attributes are not transitively dependent on the primary key.


10. Did you worked on Function and Procedure. If worked, Then how we can trigger Procedures from Java ?  
yes i worked on it and to call a procedure form java utility 
we need 
	- Driver connection to the database 
	- prepare a execute statement using 
import java.sql.*;

public class DatabaseProcedureCallExample {

    public static void main(String[] args) {
        // JDBC URL, username, and password of the database
        String url = "jdbc:mysql://localhost:3306/mydatabase";
        String user = "username";
        String password = "password";

        // JDBC variables for managing connection and executing SQL queries
        Connection connection = null;
        CallableStatement callableStatement = null;
        ResultSet resultSet = null;

        try {
            // Establishing connection to the database
            connection = DriverManager.getConnection(url, user, password);

            // Prepare the call to the stored procedure
            callableStatement = connection.prepareCall("{call getEmployeeDetails(?)}");

            // Set the parameter value for the stored procedure
            callableStatement.setInt(1, 123); // Assuming employee ID is 123

            // Execute the stored procedure
            resultSet = callableStatement.executeQuery();

            // Process the results
            while (resultSet.next()) {
                // Retrieve data from the result set
                String employeeName = resultSet.getString("employee_name");
                int employeeAge = resultSet.getInt("employee_age");

                // Process the retrieved data as needed
                System.out.println("Employee Name: " + employeeName);
                System.out.println("Employee Age: " + employeeAge);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            // Close JDBC resources in finally block to ensure they're released
            try {
                if (resultSet != null) resultSet.close();
                if (callableStatement != null) callableStatement.close();
                if (connection != null) connection.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }
}


Note :- Most of the questions from Transaction and DB quires .

1)How to use Swagger to convert application.yml to a Object class : done about it
We can create java classes using swagger codegen after setting up the swagger of your api.
So  Swagger Codegen from its GitHub repository: https://github.com/swagger-api/swagger-codegen

We can create the swagger document using the swagger openapi document dep
		<dependency>
			<groupId>org.springdoc</groupId>
			<artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
			<version>2.2.0</version>
		</dependency>

hit http://localhost:8080/swagger-ui.html ----> to get the ui of the api swagger 
hit http://localhost:8080/v3/api-docs -----> tp get the yaml out showing the contracts.


2)In case you have written a function for authentication filter, how does it get called before invoking a service call. : Using interceptor done

Ans: The authentication filter class should implement javax.servlet.Filter 

3)spring boot actuator implementation and how to check health of the application using this. done 

4)Resource Id, client Id JPMC ADFS authentication process.Process of on boarding FID. no 

5) Worked on any JPMC automation projects no

6) Asked about micro service experience. good 

7 ) Asked about deployment process ,service now process and how we coordinate with L2 team
 
[Yesterday 8:19 PM] Sachdev, Raunak
Questions
[Yesterday 8:21 PM] Sachdev, Raunak
1)find employee with role / Make use of optional KeyWord to deal with exceptions : done 

Employee

id

name

role
 
Employee A(1, Empl, Associate2)

Employee B(2, Emp2, Associate)

Employee C(3, Emp3, Associate2)
 
2)Replace the employee with Role-Associate to SDE

2 inputs, old role and new
 
3)How @Transactional will behave if save() of parent is caliing 2 children and one of child method fails. Can you achieve Isolation? : chat gpt one more time
 
Q. Overall, when invoking save() methods of multiple child objects within the same transactional method, Spring ensures that the entire set of database operations is treated as a single unit of work. If any operation fails, the entire transaction is rolled back to maintain data consistency and integrity.
answer : 
When using `@Transactional` in Spring, the behavior depends on the transaction propagation and isolation level configured. By default, the propagation is `REQUIRED`, which means that if a method with `@Transactional` annotation is called within another method with an existing transaction, it will join that transaction. 

Regarding isolation, Spring offers several isolation levels such as `READ_UNCOMMITTED`, `READ_COMMITTED`, `REPEATABLE_READ`, and `SERIALIZABLE`. The isolation level determines the degree to which one transaction must be isolated from the effects of concurrently running transactions.

Now, let's address your scenario where the `save()` method of a parent class is calling two children, and one of the child methods fails. Here's how it can be handled:

1. **Rollback behavior**: If one of the child methods fails and an exception is thrown, the transaction will be marked for rollback by default. This means that any changes made by the parent or the successfully executed child method will be rolled back.

2. **Isolation level**: You can configure the isolation level of the transaction to achieve the desired level of isolation. For example, if you want to achieve `SERIALIZABLE` isolation, you can set it as follows:

   ```java
   import org.springframework.transaction.annotation.Transactional;
   import org.springframework.transaction.annotation.Isolation;
   
   @Transactional(isolation = Isolation.SERIALIZABLE)
   public void save() {
       // Logic to save parent and call children
   }
   ```

   With `SERIALIZABLE` isolation, transactions are executed serially, meaning that the effects of concurrent transactions are not visible to each other. This can prevent certain concurrency issues, but it may also lead to performance implications due to increased locking.

In summary, by using `@Transactional` with appropriate propagation and isolation settings, you can control the transactional behavior to achieve the desired level of data consistency and isolation in your application.


4)Write class A having HAS A relation with Class B

In Java, a "HAS A" relationship typically refers to composition, where one class contains an instance of another class as a member variable. Here's how you can write a class A that has a composition relationship with class B:

class A {
private int value;

	private A(int value){
		this.value = value;
	}

	public int getValue()
	{
		return value;
	}

}
-------------------------------
class B
{
	private A a ; 
	private B()
	{
		a = new A(10);
	}

	public static printValue(){
			sout("Value of "- + a.getValue())
		}
		psvm (){
			B b = new B();
			b.printValue();
		}
}

Then write JUNIT w.r.t B : done 

import org.junit.Test;
import static org.junit.Assert.*;

public class TestClassB {
    @Test
    public void testGetValue() {
        A a = new A(5);
        assertEquals(5, a.getValue());
    }
}

 
5)find student who are passed in all subject : done 

Result Table

Student, Subject, Pass/Fail

Student1, Sub1, F

Student1, Sub2, P

Student2, Sub1, P

Student2, Sub2, F

Student1, Sub3, F

Student3, Sub1, P
 
 
CAP theorem and discussion, possibilites around it.
 
 
Record class
 
java 8 to 17. issues faced and how resolved

why upgraded
 
question on java 17.. google
 
kafka and microservice architecture.. thouroughly
