List of questions :
Array:

1. Find the maximum and minimum elements in an array.
 public static int maxNumber(int[] nums){
        int maxNum = 0;
        for (int i = 0; i < nums.length-1; i++) {
            if(nums[i]>nums[i+1]){
                maxNum = nums[i];
            }else{
                maxNum = nums[i+1];
            }
        }
        return maxNum;
    }


2. Rotate an array to the right by a given number of steps.
    Steps : 
        1. First revered the entire array (nums[],0,n-1)
        2. Reverse the k elements (nums[],0,k-1)
        3. Reverse the rest elemenst (nums[],k,n-1)
public class RotateArray {
    public static void rotateArray(int[] nums, int k) {
        int n = nums.length;
        k = k % n; // Normalize k if it's larger than the array length
        
        // Reverse the entire array
        reverse(nums, 0, n - 1);
        
        // Reverse the first k elements
        reverse(nums, 0, k - 1);
        
        // Reverse the remaining elements
        reverse(nums, k, n - 1);
    }
    
    public static void reverse(int[] nums, int start, int end) {
        while (start < end) {
            int temp = nums[start];
            nums[start] = nums[end];
            nums[end] = temp;
            start++;
            end--;
        }
    }

    public static void main(String[] args) {
        int[] nums = {1, 2, 3, 4, 5};
        int k = 2;
        rotateArray(nums, k);
        
        System.out.println("Rotated array:");
        for (int num : nums) {
            System.out.print(num + " ");
        }
    }
}


3. Merge two sorted arrays into a single sorted array.
public static void MergeTwoSortedArr(int[] arr1,int[] arr2)
    {

        int arrout[] = new int[arr1.length+arr2.length];
        // merge both the arrays and sort it.
        for (int i = 0; i < arr1.length; i++) {
           arrout[i] = arr1[i];
        }
        int j = arrout.length/2;
        for (int i1 = 0; i1 < arr1.length; i1++) {
            arrout[j] = arr2[i1];
            j++;
        }
        Arrays.stream(arrout).sorted().forEach(n->System.out.print(n+" "));

    }

4.Find the majority element in an array (element that appears more than n/2 times).
   public static void findEleNby2Times(int[] args) {
        int occ = args.length/2;
        Map<Integer,Integer> map = new LinkedHashMap<>();
        for (int i = 0; i < args.length; i++) {
            if(map.get(args[i])!=null){
                map.put(args[i],map.get(args[i])+1);
            }else{
                map.put(args[i],1);
            }
        }
        System.out.println("\n");
        map.entrySet().stream().forEach(System.out::println);
        System.out.println("\n");
        map.entrySet().stream().filter(e->e.getValue()==occ).collect(Collectors.toList());      
        
    }

4. Find the subarray with the maximum sum (Kadane's algorithm).
Kadane's Algorithm  for maximum sum of subarray
Steps : 
    - First maXEndingHere and maxSoFar ko first element ko lo
    - iterate through each element starting from second element(index 1) 
        - Update maxEndingHere = Maximum of element iterated and sum of maxEnding and element iterated
        - update maxSofar = Maximum of maxEndingHere and maxSoFar


public class MaximumSubarraySum {
    int[] nums = {5,5,1,1,2,22};
    public static int maxSubarraySum(int[] nums) {
        int maxEndingHere = nums[0];
        int maxSoFar = nums[0];
        
        for (int i = 1; i < nums.length; i++) {
            maxEndingHere = Math.max(nums[i], maxEndingHere + nums[i]);
            maxSoFar = Math.max(maxSoFar, maxEndingHere);
        }
        
        return maxSoFar;
    }

    public static void main(String[] args) {
        int[] nums = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
        int maxSum = maxSubarraySum(nums);
        System.out.println("Maximum subarray sum: " + maxSum);
    }
}

Linked List:
head ("1") | current.next -----> ("2") | current.next.next -----> ("3") | current.next.next.next -----> ("4") | current.next.next.next.next -----> null

output wll :  ("1") | current.next <---- ("2") | current.next.next <----- ("3") | current.next.next.next <----- head ("4") | current.next.next.next.next 
 
Iterate through the list:
Start from the head of the linked list and traverse through each node.

Change next pointers:
For each node, change its next pointer to point to the previous node instead of the next node.

Update pointers:
Maintain references to the previous node, current node, and next node to keep track of the nodes while traversing the list.

Set new head:
Once the end of the list is reached, set the new head of the reversed list to the last node (previous node).

1.Reverse a linked list.
LinkedList<Integer> list = new LinkedList<>();
        list.add(5);
        list.add(2);
        list.add(1);
        list.add(4);
        System.out.println(list.stream().sorted(Comparator.reverseOrder()).collect(Collectors.toList()));

OR 

class ListNode {
    int val;
    ListNode next;

    ListNode(int val) {
        this.val = val;
    }
}

public class ReverseLinkedList {
    public static ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode current = head;
        ListNode nextNode = null;

        while (current != null) {
            nextNode = current.next;
            current.next = prev;
            prev = current;
            current = nextNode;
        }

        return prev; // New head of the reversed list
    }

    public static void printList(ListNode head) {
        ListNode current = head;
        while (current != null) {
            System.out.print(current.val + " ");
            current = current.next;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        // Create a sample linked list: 1 -> 2 -> 3 -> 4 -> 5
        ListNode head = new ListNode(1);
        head.next = new ListNode(2);
        head.next.next = new ListNode(3);
        head.next.next.next = new ListNode(4);
        head.next.next.next.next = new ListNode(5);

        System.out.println("Original list:");
        printList(head);

        // Reverse the linked list
        ListNode reversedHead = reverseList(head);

        System.out.println("Reversed list:");
        printList(reversedHead);
    }
}


2.Detect a cycle in a linked list.
if the last node of the list pointing to the head then its a cycle
Floyd's cycle detection algorithm :

class ListNode {
    int val;
    ListNode next;

    ListNode(int val) {
        this.val = val;
        this.next = null;
    }
}

public class CycleDetection {
    public static boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) {
            return false; // If the list is empty or has only one node, there's no cycle
        }

        ListNode slow = head;
        ListNode fast = head.next; // Start fast pointer one step ahead

        while (fast != null && fast.next != null) {
            if (slow == fast) {
                return true; // If slow and fast pointers meet, there's a cycle
            }
            slow = slow.next; // Move slow pointer one step forward
            fast = fast.next.next; // Move fast pointer two steps forward
        }

        return false; // If fast pointer reaches the end of the list, there's no cycle
    }

    public static void main(String[] args) {
        // Create a sample linked list with a cycle: 1 -> 2 -> 3 -> 4 -> 5 -> 3 (cycle)
        ListNode head = new ListNode(1);
        head.next = new ListNode(2);
        head.next.next = new ListNode(3);
        head.next.next.next = new ListNode(4);
        head.next.next.next.next = new ListNode(5);
        head.next.next.next.next.next = head.next.next; // Create cycle

        // Check if the linked list has a cycle
        boolean hasCycle = hasCycle(head);
        if (hasCycle) {
            System.out.println("The linked list has a cycle.");
        } else {
            System.out.println("The linked list does not have a cycle.");
        }
    }
}


3.Find the middle element of a linked list.
4.Merge two sorted linked lists.
5.Remove duplicates from a sorted linked list.

Stacks and Queues:
1.Implement a stack using an array and its basic operations.
2.Implement a queue using two stacks.
3.Evaluate a postfix expression using a stack.
4.Implement a min stack that supports push, pop, top, and retrieving the minimum element in constant time.
5.Implement a circular queue.

Trees:

1.Implement a binary search tree (BST) and its basic operations (insertion, deletion, searching).
2.Find the height of a binary tree.
3.Traverse a binary tree in preorder, inorder, and postorder.
4.Check if a binary tree is balanced.
5.Find the lowest common ancestor (LCA) of two nodes in a binary tree.

Graphs:

1.Implement depth-first search (DFS) and breadth-first search (BFS) traversal algorithms.
2.Detect a cycle in a directed and undirected graph.
3.Find the shortest path between two nodes in a weighted graph (Dijkstra's algorithm).
4.Find the connected components in an undirected graph.
5.Check if a graph is bipartite.

Sorting and Searching: done

1.Implement various sorting algorithms like bubble sort, selection sort, insertion sort, merge sort, and quick sort.
2.Search for an element in a sorted array using binary search.
3.Find the kth smallest/largest element in an array.

Dynamic Programming:

1.Calculate the Fibonacci sequence using dynamic programming.
Funda : Next element is the sum of two elements before it.
public static int fibonacci(int n) {
        // Create an array to store Fibonacci numbers
        int[] fib = new int[n + 1];

        // Base cases
        fib[0] = 0;
        fib[1] = 1;

        // Calculate Fibonacci numbers using dynamic programming
        for (int i = 2; i <= n; i++) {
            fib[i] = fib[i - 1] + fib[i - 2];  -----> sum of two element before it.
        }
        for (int i : fib) {
            System.out.print(" " + i);
        }

        // Return the nth Fibonacci number
        return fib[n];
    }

2.Find the longest common subsequence (LCS) of two strings.
3.Compute the edit distance (minimum number of operations) to transform one string into another.
4.Calculate the minimum path sum in a grid (dynamic programming approach).

Miscellaneous:

1.Find all permutations of a string.
import java.util.ArrayList;
import java.util.List;

public class StringPermutations {
    public static List<String> findPermutations(String str) {
        List<String> permutations = new ArrayList<>();
        backtrack(permutations, "", str);
        return permutations;
    }

    private static void backtrack(List<String> permutations, String currentPerm, String remainingChars) {
        if (remainingChars.length() == 0) {
            permutations.add(currentPerm);
            return;
        }

        for (int i = 0; i < remainingChars.length(); i++) {
            char ch = remainingChars.charAt(i);
            String newPerm = currentPerm + ch;
            String newRemaining = remainingChars.substring(0, i) + remainingChars.substring(i + 1);
            backtrack(permutations, newPerm, newRemaining);
        }
    }

    public static void main(String[] args) {
        String str = "abc";
        List<String> allPermutations = findPermutations(str);

        System.out.println("All permutations of \"" + str + "\":");
        for (String permutation : allPermutations) {
            System.out.println(permutation);
        }
    }
}


