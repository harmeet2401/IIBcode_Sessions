OCP CLI commands --------------------------------------------------------------
oc login -u username -p password ---------------------------------------------- to login to OCP cluster
oc get pods ------------------------------------------------------------------- To get the pods running on current project selected in OCP cluster node.
oc project nameofproject ------------------------------------------------------ to switch to a new project and start using it.
oc get projects --------------------------------------------------------------- to get to know which projects are there in ocp cluster.
oc project -------------------------------------------------------------------- to get to which project currently using .
oc delete all --ll ------------------------------------------------------------ this will delete all the resources (Deployment ,deployment config , services , route , image stream , buld config , build )
oc delete secret --all --------------------------------------------------------  this will delete all the secrets 
oc new-app jenkins-ephemeral(this is the image name) --------------------------  this will create a deployement config and run a pod for jenkins server .
	Will create below resources : 
		1. DC 
		2. Route 
		3. 2 Services 
		4. Config map 
oc delete all -l app=hello-world ---------------------------------------------- this will delete all the resources connected to app= hello-world		
oc status --------------------------------------------------------------------- this will show you all the Dc , bc , route ,services and other configuration done apps in the current project. using this command you can check the exposed url as well.
output of oc status :                								
				svc/hello-world - 172.30.180.208:8080							--------- Service
					dc/hello-world deploys istag/hello-world:latest             --------- Deployement config
						deployment #1 deployed 8 minutes ago - 1 pod			---------1 pod
oc explain pod :---------------------------------------------------------------- to get the description of the pod
oc explain pod.spec :----------------------------------------------------------- spec is one of the field in pod
oc explain pod.spec.containers :------------------------------------------------ containers is a field inside spec.
oc create -f pod.yaml ---------------------------------------------------------- this will create the pod on ocp 
oc delete pod/nameofthepod ----------------------------------------------------- this will delete the pod
oc get pods --watch ------------------------------------------------------------ this will keep a watch on the pod list . on the other terminal you can create an another pod and see it getting creating in earlier one . real time changes.
oc explain pod.spec.containers.env----------------------------------------------- this will show the inbult documentation for resource pod.spec.contaiers.env
oc new-app quay.io/practicalopenshift/hello-world --as-deployment-config  : oc new-app imagetagname --as-deployment-config ------- used to create a deployment config.
oc status ----------------------------------------------------------------------- this will show you all the resource and check your app 
oc expose svc/hello-world ------------------------------------------------------- this will expose the service(load balancer) to outside world and creates a route for it.
oc get svc				--------------------------------------------------------- will give service
oc get dc 			  ----------------------------------------------------------- will give deploymentconfig
oc get istag          ----------------------------------------------------------- image stream tag		
oc get is             ----------------------------------------------------------- image stream 		
oc delete svc/hello-world ------------------------------------------------------- dleete the service
oc delete dc/hello-world  ------------------------------------------------------- delete deployment config.
oc delete is/hello-world  ------------------------------------------------------- delete image stream.
oc describe dc/hello-world ------------------------------------------------------ describe the dc with label will give you description of the props it has 
oc describe bc/hello-world ------------------------------------------------------ describe the bc with label will give you description of the props it has 
oc describe svc/hello-world ------------------------------------------------------ describe the svc with label will give you description of the props it has 
oc describe route/hello-world ------------------------------------------------------ describe the ruote with label will give you description of the props it has 
oc describe pod/hello-world ------------------------------------------------------ describe the pods with label will give you description of the props it has 
oc delete all -l app=hello-world ------------------------------------------------ then use -l and mention the label got from describe command and delete the resources.
oc new-app quay.io/practicalopenshift/hello-world --name demo-app --as-deployment-config ---------------- this will create a deployment config with label name as demo-app		
oc new-app https://gitlab.com/practical-openshift/hello-world.git --as-deployment-config----------------- Similar to above command just we are giving the git repository url to create a DC using the Dockerfile present in the git repository.
oc new-app meet14764-dev/hello-world --as-deployment-config-------------------------------------------- Another way to create DC using image from the image stream imported
oc logs -f  bc/hello-world  :---------------------------------------------------------------------------- to get the logs of bc : which will sho you the steps took to buld the image by cloning.
oc logs -f  pod/hello-world  :---------------------------------------------------------------------------- to get the logs of pods : which will sho you the steps took to buld the image by cloning.
oc get pods -n projectname/namespacename ----------------------------------------------------------------- this command will get the pods running in your OCP project or namespace.
oc get rc  :--------------------------------------------------------------------------------------------- get the replication controller.
oc get -o yaml bc/hello-world >> bc.yaml ---------------------------------------------------------------- to export the yaml to a file for build config 
oc get -o yaml dc/hello-world >> dc.yaml ---------------------------------------------------------------- to export the yaml to a file for deployment-config  
oc get -o yaml svc/hello-world >> svc.yaml ---------------------------------------------------------------- to export the yaml to a file for service 
oc get -o yaml route/hello-world >> route.yaml ---------------------------------------------------------------- to export the yaml to a file for service 
oc new-app https://github.com/harmeet2401/MyApi.git --as-deployment-config--------------------------------- to create DC for my app 
oc rollout latest dc/hello-world   :-------------------------------------------------------------------------- this will create a new deployemnt while keeping the old one up untill the new one comes up , 0 downtine.
oc rollback dc/hello-world :---------------------------------------------------------------------------------- this will roll back the deployment to the old version we terminated 
oc expose --port 8080 pod/hello-world-pod -------------------------------------------------------------------- this will expose a pod and create a service 
oc expose svc/hello-world------------------------------------------------------------------------------------- this will expose the service and create a route 				
oc expose svc/hello-world --hostname=mysqltestapptesturl.com ------------------------------------------------------------------------------------- this will expose the service and create a route 	and also assign a hostname of our choice		
env ---------------------------------------------------------------------------------------------------------- show all env inside pod terminal 
oc cp mytestfile.txt podname:/temp/--------------------------------------------------------------------------- this will copy the mytestfile.txt from host machine to the runing pod os the application . just like uploading a file to a pod.
oc explain configmaps ---------------------------------------------------------------------------------------- to get the inbuild OCP documentation for configmaps.
oc create configmap message-map --from-literal MESSAGE="HELLO FROM CONFIGMAPS" ------------------------------- to create a config maps
oc get configmaps--------------------------------------------------------------------------------------------- to get the configmaps
oc get -o yaml cm/message-map--------------------------------------------------------------------------------- get the yaml forconfig maps 
oc set env dc/hello-world  --from cm/message-map -------------------------------------------------------------- to apply the config map to a DC which will start using the MESSAGE key and its value 
oc create configmap file-map --from-file=MESSAGE.txt ---------------------------------------------------------- pods is the folder that contains the files
oc create configmap file-map-2 --from-file=MESSAGE=MESSAGE.txt  ----------------------------------------------- this will update the key value to only MESSAGE
oc create configmap pod-example --from-file pods -------------------------------------------------------------- this will create config maps using directory name "pods" this directory contains 3 yaml files pod.yaml , pod2.yaml and service.yaml which will be added as a key value pair .where filename as a key and yaml contenet as a value
oc create secret generic message-secrets --from-literal MESSAGE="SECRET MESSAGE"------------------------------- will create a secrets just like the config maps ,but will save the value of message as Base 64 encoded.
oc set env dc/hello-world --from secret/message-secrets ---------------------------------------------------------- aplying the secrete message to env variable to a DC
oc import-image --confirm quay.io/practicalopenshift/hello-world  ------------------------------------------------ just like oc new-app oc import-image will helpin creating imagestreamfrom the image provided in command without creating any BC , DC , service or route 
oc new-app meet14764-stage/hello-world --as-deployment-config ---------------------------------------------------- to create a deployment config using the image imported to the imagestream
oc tag quay.io/practicalopenshift/hello-world:update-message hello-world:update-message--------------------------- command to create a imagestreamtag for an imagestream.
syntax : oc tag <original><destination> Command will create a new tag for the imagestream with update-message name .
oc new-build https://gitlab.com/practical-openshift/hello-world.git ---------------------------------------------- command to buld a BC using the docker file in case of git url 
oc start-build bc/hello-world  ----------------------------------------------------------------------------------- this will trigger the build config  to create a build which will create an image or in open shift language image stream .
oc cancel-build bc/hello-world ----------------------------------------------------------------------------------- to cancel the build 

----For webhooks -------------
oc get -o yaml bc/hello-world ------------------------------------------------------------------------------------ copy the secret under trigger tag ----> Generic 
oc describe bc/hello-world --------------------------------------------------------------------------------------- copy the generic url from the describe output.
Mention that in you git repo ----> settings -----> webhook------> add
----For webhooks -------------

oc new-build https://gitlab.com/practical-openshift/hello-world.git#update-message ------------------------------- to create a BC using hello-world git from branch update-message.
oc new-build https://gitlab.com/practical-openshift/labs.git  --context-dir hello-world -------------------------- hello-world is the folder in it .
oc set build-hook bc/hello-world --post-commit --script="echo hello from post build hook"------------------------- it will run a script in this case a echo command to print something in build config to check if the build is running or not .
oc new-app ruby~https://gitlab.com/practical-openshift/labs.git --context-dir s2i/ruby --as-deployment-config----- used ruby keyword with ~ tilda to specifically tell the ocp to use the ruby S2I scripts to build the ruby app.
oc new-app python~https://gitlab.com/practical-openshift/labs.git --context-dir s2i/ruby --as-deployment-config---- used python keyword with ~ tilda this fails for a ruby project as usualan dto specify builder image for python 
oc set volumes dc/myapi --add --type emptyDir --mount-path /empty-dir-demo ----------------------------------------- to mount the empty volume to the Dc. this is not persistent it will be destroyed once pod died.
oc set volumes dc/myapi --add --type persistentVolumeClaim --claim-name pv1 --mount-path /data --------------------- to mount the persistentVolumeClaim to the DC
oc create configmap cm-volumes --from-literal file.txt=file="this config is for volumes"  -------------------------- file.txt is the key you can mention anytin .
oc set volumes dc/myapi --add --configmap-name cm-volumes --mount-path /cm-dir         ----------------------------- to mount the configmap as a volume in DC
oc set triggers dc/hello-world ------------------------------------------------------------------------------------- to get the trigger list 
oc set triggers dc/hello-world --remove --from-config -------------------------------------------------------------- to remove the triggers . this will make the Auto flag as false.
oc set triggers dc/hello-world  --from-config ---------------------------------------------------------------------- to read the config change trigger.
oc set triggers dc/hello-world --remove --from-image hello-world:latest -------------------------------------------- this will remove the trigger for image change. Then no deployment will be rolled when an image is changed 
oc set triggers dc/hello-world  --from-image hello-world:latest  -c hello-world ------------------------------------ this will add the image change trigger.
oc rollout latest dc/hello-world------------------------------------------------------------------------------------ this will rollout a DC with strategy to bring down the pod one ata time and bring other ups.
oc set deployment-hook dc/myapi --pre -c myapi -- /bin/echo Hello from pre-deploy hook----------------------------- Its for pre deploymet hook 
oc set deployment-hook dc/myapi --mid -c myapi -- /bin/echo Hello from mid-deploy hook------------------ Its for mid deploymet hook .for this first set the DC strategy to recreate bcse 
this mid dep hook can be set to recreate strategy 
oc edit dc/myapi --------------------------------------------------------------------------------------------- its used to edit the DC and we can change the strategy 
oc rollout latest dc/myapi  
oc set probe dc/hello-world --liveness --open-tcp=8080   :-------------------------------------------------- tcp-socket :8080 delay=0s timeout=1s period=10s #success=1 #failure=3
oc set probe dc/hello-world --liveness --open-tcp=8081 --------------------------------------------------- this will bring container in crashimageloopback bcse of wrong set up pg port to the liveness probe .
oc scale dc/hello-world --replicas=3---------------------------------------------------------------------- to scale up 
oc autoscale dc/hello-world --min 1 --max 10 --cpu-percent=80--------------------------------------------- for horizontal scaling setup 
oc get hpa  --------------------------------------------------------------------------------------------- will show you the targets 0%80% minpods and maxpods ,replicas and AGE
oc delete hpa ------------------------------------------------------------------------------------------- will delete the HPA
oc export all --as-template=myapi_template ------------------------------------------------------------- to  export the existing project in a template form .
oc create -f hello-world-template.yaml------------------------------------------------------------------- upload to OCP servers . once this is uploaded we can update or use it to create deplpments , bc , svc , route etc . this command creats the template and upload it to OCP
oc get template ----------------------------------------------------------------------------------------- to get the template created 
oc new-app templatenamecreated--------------------------------------------------------------------------- to cretae an app(dc,bc,service , route etc )
oc create -f process.yaml  ------------------------------------------------------------------------------ to create an app using the template file without uploading it to ocp
oc new-app hello-world  -p MESSAGE="HELLO FROM OTHER PARMS2 !!!!!! "------------------------------------- we are passing parameter value for variable/paramter named MESSAGE . hello-world is the template name 
oc process hello-world  : -------------------------------------------------------------------------------this will show the template as a json  ,hello-world is the template name 
Processing a file presnt locally without uploading the file to ocp server.	
oc process hello-world -o yaml -p MESSAGE="processing the yaml file ">> hello-world-template.yaml
oc create -f process.yaml ------------------------------------------------------------------------------- to create and app using a yaml file on OCP 
	
oc get -o yaml dc,bc,is,svc,route >> complete_arch_template_app.yaml    ---------------------------------> now once you export this to a file it contains list so you have to convert it to a template 
which need some changes to the yaml file exported out  , item to and remove the status object , annotations , , create datetime , UID etc 
		
oc new-app --docker-image=registry.access.redhat.com/rhscl/mysql-57-rhel7 --name=mysql-app -e MYSQL_USER=user1 -e MYSQL_PASSWORD=password -e MYSQL_DATABASE=books -e MSYSQL_ROOT_PASSWORD=password -l app=mydbapp   ---------------------------------------------------------- to run a musql db app 

oc new-app --docker-image=registry.access.redhat.com/rhscl/mysql-57-rhel7 --name=mysql-app --as-deployment-config -e MYSQL_USER=user1 -e MYSQL_PASSWORD=password -e MYSQL_DATABASE=books -e MSYSQL_ROOT_PASSWORD=password -l app=mydbapp

oc get all ---------------------------------------------------------------------------------------------- will show all the resources created 
oc get all -o wide --------------------------------------------------------------------------------------- this will shows the selectors as well .
oc rsh podname ------------------------------------------------------------------------------------------- to login in or go in shell mode into the pod 
	$:// mysql --version 
	$:// mysql -u user1 -p 
		enter the pass as password 
		mysql> SELECT VERSION ();
		
		VERSION : 5.7.12


"oc process -f mysql.yaml -p MYSQL_USER=user1 -p MYSQL_PASSWORD=password -p MYSQL_DATABASE=books  | oc create -f -" ------ to create a mysql app using a yamls file 
oc create -f mysql.yaml -------------------------------------------------------------------------------------------------- creats a template 
"oc process mysql-persistent -p MYSQL_USER=user1 -p MYSQL_PASSWORD=password -p MYSQL_DATABASE=books  | oc create -f -" ------ to create a mysql app using a tempate created by above command  
oc get quota -n meet14764-dev --------------------------------------------------------------------------------- this will give you the list  of  resource quota assigned to the project .
oc describe quota core-object-counts -n meet14764-dev  ----------------------------------------------------------- this will give youthe list of core-objec count quota assigned to the project 

oc policy--------------------------------------------------------------------------------------------------------- is used again, but this time roles are added to groups. Note that the service account name "jenkins" is never used. Only the service account group is used.

oc logs -f buildconfig/cotd2 -n pipeline-${GUID}-dev ------------------------------------------------------------- is used to watch the logs for the BC on project/namespace : pipeline-${GUID}-dev


---------------------------------------------Podman command as similar as the docker commands.-------------------------------------------------------------------------------------------------------------------

podman searhc rhel ----------------------------------------- Command to search the image in red hat image repository 
podman pull rhel ------------------------------------------- this will download the image on your local and can use it .
The image names are based on following syntax : 
registry_name/user_name/image_name:tag
podman images --------------------------------------------- this will show us the images present on local 	
podman run ubi8/ubi:8.3 echo 'Hello world!' --------------- this run command to run the container using the image 
podman run -d -p 8080:80 registry.redhat.io/rhel8/httpd-24---- to run a container in bakcground using -d .
podman port -l--------------------------------------------- to see the container port mapped .
podman run -it ubi8/ubi:8.3 /bin/bash---------------------- this command will create a container and do a bash inside the running container in interactive mode.
podman run -e GREET=Hello -e NAME=RedHat ubi8/ubi:8.3 printenv GREET NAME--------- this will inject environment variables into container from outside using "-e"
podman run --name mysql-custom  -e MYSQL_USER=redhat -e MYSQL_PASSWORD=r3dh4t  -e MYSQL_ROOT_PASSWORD=r3dh4t  -d registry.redhat.io/rhel8/mysql-80
podman login registry.redhat.io------------------------------------------------------ login to redhat image registry 
podman run --name mysql-basic -e MYSQL_USER=user1 -e MYSQL_PASSWORD=mypa55 -e MYSQL_DATABASE=items -e MYSQL_ROOT_PASSWORD=r00tpa55 -d registry.redhat.io/rhel8/mysql-80:1
podman ps --format "{{.ID}} {{.Image}} {{.Names}}" ---------------------------------- to see the cotainer runs correctly or not .
podman exec -it mysql-basic /bin/bash ----------------------------------------------- To do the bash to a running container  -it says to go bash mode .
bash-4.2$ mysql -uroot 
		>enter the password 
		mysql > mysql --version 
		
podman run --name mysql-db  registry.redhat.io/rhel8/mysql-80:1	---------------------- it will run the container will name mysql-db 
podman run --name mysql  -d -e MYSQL_USER=user1 -e MYSQL_PASSWORD=mypa55  -e MYSQL_DATABASE=items -e MYSQL_ROOT_PASSWORD=r00tpa55  registry.redhat.io/rhel8/mysql-80:1---------- to run the mysql container and setting the mysql username and password by sending environment variable value in the command .
podman cp /home/student/DO180/labs/manage-lifecycle/db.sql mysql:/ ------------------- this will copy the file from host machine to container(mysql) root directory and gave mysql as the users.
podman exec mysql /bin/bash -c 'mysql -uuser1 -pmypa55 items < /db.sql'--------------- this command is used to run the sql file which will create the table and insert the row into it.
podman exec mysql /bin/bash -c 'mysql -uuser1 -pmypa55 -e "select * from items.Projects;"'-------------------------- this will send the select query as the env variable value and run it inside container.
podman logs mysql-db ----------------------------------------------------------------- it is used to get the logs out.
podman images : ---------------------------------------------------------------------- it will show all the images .
podman run --name my-httpd-container registry.redhat.io/rhel8/httpd-24 -------------------------------------------------------- thiswill create a cotainer using the image and container name will be http-server.
podman stop containr-d/container name : ------------------------------------------------------------- it will stp the container as per the container id .
podman kill container-id/container-name : ----------------------------------------------------------- it will kill the main container processs forcefully .
podman restart container-id/container-name ---------------------------------------------------------- it will restart thestopped container.
podman rm container-id : ---------------------------------------------------------------------------- it will remoeve the stopped container as per the container id given .
podman rmi image-nme/image-id ----------------------------------------------------------------------- it will remove the images from the local registry 
podman stop -a :------------------------------------------------------------------------------------- it will stop all the running container.
podman rm -a : -------------------------------------------------------------------------------------- it will remove all stopped containers.




Many Podman flags also have an alternative long form; some of these are explained below:
		-t is equivalent to --tty, meaning a pseudo-tty (pseudo-terminal) is to be allocated for the container.		
		-i is the same as --interactive. When used, standard input is kept open into the container.		
		-d, or its long form --detach, means the container runs in the background (detached). Podman then prints the container id.			

---------------------------------------------Podman command -------------------------------------------------------------------------------------------------------------------
