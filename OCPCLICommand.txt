OCP CLI commands --------------------------------------------------------------
oc login -u username -p password ---------------------------------------------- to login to OCP cluster
oc get pods ------------------------------------------------------------------- To get the pods running on current project selected in OCP cluster node.
oc project nameofproject ------------------------------------------------------ to switch to a new project and start using it.
oc get projects --------------------------------------------------------------- to get to know which projects are there in ocp cluster.
oc project -------------------------------------------------------------------- to get to which project currently using .
oc delete all --ll ------------------------------------------------------------ this will delete all the resources (Deployment ,deployment config , services , route , image stream , buld config , build )
oc delete secret --all --------------------------------------------------------  this will delete all the secrets 
oc new-app jenkins-ephemeral(this is the image name) --------------------------  this will create a deployement config and run a pod for jenkins server .
	Will create below resources : 
		1. DC 
		2. Route 
		3. 2 Services 
		4. Config map 
oc delete all -l app=hello-world ---------------------------------------------- this will delete all the resources connected to app= hello-world		
oc status --------------------------------------------------------------------- this will show you all the Dc , bc , route ,services and other configuration done apps in the current project. using this command you can check the exposed url as well.
output of oc status :                								
				svc/hello-world - 172.30.180.208:8080							--------- Service
					dc/hello-world deploys istag/hello-world:latest             --------- Deployement config
						deployment #1 deployed 8 minutes ago - 1 pod			---------1 pod
oc explain pod :---------------------------------------------------------------- to get the description of the pod
oc explain pod.spec :----------------------------------------------------------- spec is one of the field in pod
oc explain pod.spec.containers :------------------------------------------------ containers is a field inside spec.
oc create -f pod.yaml ---------------------------------------------------------- this will create the pod on ocp 
oc delete pod/nameofthepod ----------------------------------------------------- this will delete the pod
oc get pods --watch ------------------------------------------------------------ this will keep a watch on the pod list . on the other terminal you can create an another pod and see it getting creating in earlier one . real time changes.
oc explain pod.spec.containers.env----------------------------------------------- this will show the inbult documentation for resource pod.spec.contaiers.env
oc new-app quay.io/practicalopenshift/hello-world --as-deployment-config  : oc new-app imagetagname --as-deployment-config ------- used to create a deployment config.
oc status ----------------------------------------------------------------------- this will show you all the resource and check your app 
oc expose svc/hello-world ------------------------------------------------------- this will expose the service(load balancer) to outside world and creates a route for it.
oc get svc				--------------------------------------------------------- will give service
oc get dc 			  ----------------------------------------------------------- will give deploymentconfig
oc get istag          ----------------------------------------------------------- image stream tag		
oc get is             ----------------------------------------------------------- image stream 		
oc delete svc/hello-world ------------------------------------------------------- dleete the service
oc delete dc/hello-world  ------------------------------------------------------- delete deployment config.
oc delete is/hello-world  ------------------------------------------------------- delete image stream.
oc describe dc/hello-world ------------------------------------------------------ describe the dc with label will give you description of the props it has 
oc describe bc/hello-world ------------------------------------------------------ describe the bc with label will give you description of the props it has 
oc describe svc/hello-world ------------------------------------------------------ describe the svc with label will give you description of the props it has 
oc describe route/hello-world ------------------------------------------------------ describe the ruote with label will give you description of the props it has 
oc describe pod/hello-world ------------------------------------------------------ describe the pods with label will give you description of the props it has 
oc delete all -l app=hello-world ------------------------------------------------ then use -l and mention the label got from describe command and delete the resources.
oc new-app quay.io/practicalopenshift/hello-world --name demo-app --as-deployment-config ---------------- this will create a deployment config with label name as demo-app		
oc new-app https://gitlab.com/practical-openshift/hello-world.git --as-deployment-config----------------- Similar to above command just we are giving the git repository url to create a DC using the Dockerfile present in the git repository.
oc new-app meet14764-dev/hello-world --as-deployment-config-------------------------------------------- Another way to create DC using image from the image stream imported
oc logs -f  bc/hello-world  :---------------------------------------------------------------------------- to get the logs of bc : which will sho you the steps took to buld the image by cloning.
oc logs -f  pod/hello-world  :---------------------------------------------------------------------------- to get the logs of pods : which will sho you the steps took to buld the image by cloning.
oc get pods -n projectname/namespacename ----------------------------------------------------------------- this command will get the pods running in your OCP project or namespace.
oc get rc  :--------------------------------------------------------------------------------------------- get the replication controller.
oc get pv ----------------------------------------------------------------------------------------------- get the persistent volume available
oc get -o yaml bc/hello-world >> bc.yaml ---------------------------------------------------------------- to export the yaml to a file for build config 
oc get -o yaml dc/hello-world >> dc.yaml ---------------------------------------------------------------- to export the yaml to a file for deployment-config  
oc get -o yaml svc/hello-world >> svc.yaml ---------------------------------------------------------------- to export the yaml to a file for service 
oc get -o yaml route/hello-world >> route.yaml ---------------------------------------------------------------- to export the yaml to a file for service 
oc get -o yaml pv/pvaname >> py.yaml ------------------------------------------------------------------------------- to export the PV in a yaml format 
oc create -f pv.yaml ------------------------------------------------------------------------------------------ this will create the pv using the yaml file we exported from above command 
oc get -o pvc/pvcname >> pvc.yaml ----------------------------------------------------------------------------- to export the pvc in a yaml file 
oc create -f pvc.yaml : --------------------------------------------------------------------------------------- to create a persistent volume claim using the yaml and changing it to create new PVC
oc new-app https://github.com/harmeet2401/MyApi.git --as-deployment-config--------------------------------- to create DC for my app 
oc rollout latest dc/hello-world   :-------------------------------------------------------------------------- this will create a new deployemnt while keeping the old one up untill the new one comes up , 0 downtine.
oc rollback dc/hello-world :---------------------------------------------------------------------------------- this will roll back the deployment to the old version we terminated 
oc expose --port 8080 pod/hello-world-pod -------------------------------------------------------------------- this will expose a pod and create a service 
oc expose svc/hello-world------------------------------------------------------------------------------------- this will expose the service and create a route 				
oc expose svc/hello-world --hostname=mysqltestapptesturl.com ------------------------------------------------------------------------------------- this will expose the service and create a route 	and also assign a hostname of our choice		
env ---------------------------------------------------------------------------------------------------------- show all env inside pod terminal 
oc exec container_id  bash ----------------------------------------------------------------------------------- to run bash command inside the container 

oc cp mytestfile.txt podname:/temp/--------------------------------------------------------------------------- this will copy the mytestfile.txt from host machine to the runing pod os the application . just like uploading a file to a pod.
oc explain configmaps ---------------------------------------------------------------------------------------- to get the inbuild OCP documentation for configmaps.
oc create configmap message-map --from-literal MESSAGE="HELLO FROM CONFIGMAPS" ------------------------------- to create a config maps
oc get configmaps--------------------------------------------------------------------------------------------- to get the configmaps
oc get -o yaml cm/message-map--------------------------------------------------------------------------------- get the yaml forconfig maps 
oc set env dc/hello-world  --from cm/message-map -------------------------------------------------------------- to apply the config map to a DC which will start using the MESSAGE key and its value 
oc create configmap file-map --from-file=MESSAGE.txt ---------------------------------------------------------- pods is the folder that contains the files
oc create configmap file-map-2 --from-file=MESSAGE=MESSAGE.txt  ----------------------------------------------- this will update the key value to only MESSAGE
oc create configmap pod-example --from-file pods -------------------------------------------------------------- this will create config maps using directory name "pods" this directory contains 3 yaml files pod.yaml , pod2.yaml and service.yaml which will be added as a key value pair .where filename as a key and yaml contenet as a value
oc create secret generic message-secrets --from-literal MESSAGE="SECRET MESSAGE"------------------------------- will create a secrets just like the config maps ,but will save the value of message as Base 64 encoded.
oc set env dc/hello-world --from secret/message-secrets ---------------------------------------------------------- aplying the secrete message to env variable to a DC
oc import-image --confirm quay.io/practicalopenshift/hello-world  ------------------------------------------------ just like oc new-app oc import-image will helpin creating imagestreamfrom the image provided in command without creating any BC , DC , service or route 
oc new-app meet14764-stage/hello-world --as-deployment-config ---------------------------------------------------- to create a deployment config using the image imported to the imagestream
oc tag quay.io/practicalopenshift/hello-world:update-message hello-world:update-message--------------------------- command to create a imagestreamtag for an imagestream.
syntax : oc tag <original><destination> Command will create a new tag for the imagestream with update-message name .
oc new-build https://gitlab.com/practical-openshift/hello-world.git ---------------------------------------------- command to buld a BC using the docker file in case of git url 
oc start-build bc/hello-world  ----------------------------------------------------------------------------------- this will trigger the build config  to create a build which will create an image or in open shift language image stream .
oc cancel-build bc/hello-world ----------------------------------------------------------------------------------- to cancel the build 
oc port-forward podname/podid 3306:3306 ---------------------------------------------------------------- to forward the local port to the port of a single pod.
exmaple : 
[user@host ~]$ oc port-forward mysql-openshift-1-glqrp 3306:3306
The command forwards port 3306 from the developer machine to port 3306 on the db pod, where a MySQL server (inside a container) accepts network connections.
----For webhooks -------------
oc get -o yaml bc/hello-world ------------------------------------------------------------------------------------ copy the secret under trigger tag ----> Generic 
oc describe bc/hello-world --------------------------------------------------------------------------------------- copy the generic url from the describe output.
Mention that in you git repo ----> settings -----> webhook------> add
----For webhooks -------------

oc new-build https://gitlab.com/practical-openshift/hello-world.git#update-message ------------------------------- to create a BC using hello-world git from branch update-message.
oc new-build https://gitlab.com/practical-openshift/labs.git  --context-dir hello-world -------------------------- hello-world is the folder in it .
oc new-app . ----------------------------------------------------------------------------------------------------- this will create an application using the source code in current directory 
oc set build-hook bc/hello-world --post-commit --script="echo hello from post build hook"------------------------- it will run a script in this case a echo command to print something in build config to check if the build is running or not .
oc new-app ruby~https://gitlab.com/practical-openshift/labs.git --context-dir s2i/ruby --as-deployment-config----- used ruby keyword with ~ tilda to specifically tell the ocp to use the ruby S2I scripts to build the ruby app.
oc new-app -i ruby https://gitlab.com/practical-openshift/labs.git --context-dir s2i/ruby --as-deployment-config----- used ruby keyword with ~ tilda to specifically tell the ocp to use the ruby S2I scripts to build the ruby app.
oc new-app python~https://gitlab.com/practical-openshift/labs.git --context-dir s2i/ruby --as-deployment-config---- used python keyword with ~ tilda this fails for a ruby project as usualan dto specify builder image for python 
oc new-app -i python https://gitlab.com/practical-openshift/labs.git --context-dir s2i/ruby --as-deployment-config---- used python keyword with ~ tilda this fails for a ruby project as usualan dto specify builder image for python 
--------------------------------- is S2I is not mentioned using the -i or ~(tilda)
new-app attempts to determine which language builder to use based on the presence of certain files in the root of the repository:

Language	Files
Ruby	Rakefile Gemfile config.ru
Java EE	pom.xml
Node.js	app.json package.json
PHP	index.php composer.json
Python	requirements.txt config.py
Perl	index.pl cpanfile

---------------------------------
oc new-app https://gitlab.com/practical-openshift/hello-world.git#update-message ------------------------------------this will create an app using the source code from update-message branch .
oc set volumes dc/myapi --add --type emptyDir --mount-path /empty-dir-demo ----------------------------------------- to mount the empty volume to the Dc. this is not persistent it will be destroyed once pod died.
oc set volumes dc/myapi --add --type persistentVolumeClaim --claim-name pv1 --mount-path /data --------------------- to mount the persistentVolumeClaim to the DC
oc create configmap cm-volumes --from-literal file.txt=file="this config is for volumes"  -------------------------- file.txt is the key you can mention anytin .
oc set volumes dc/myapi --add --configmap-name cm-volumes --mount-path /cm-dir         ----------------------------- to mount the configmap as a volume in DC
oc set triggers dc/hello-world ------------------------------------------------------------------------------------- to get the trigger list 
oc set triggers dc/hello-world --remove --from-config -------------------------------------------------------------- to remove the triggers . this will make the Auto flag as false.
oc set triggers dc/hello-world  --from-config ---------------------------------------------------------------------- to read the config change trigger.
oc set triggers dc/hello-world --remove --from-image hello-world:latest -------------------------------------------- this will remove the trigger for image change. Then no deployment will be rolled when an image is changed 
oc set triggers dc/hello-world  --from-image hello-world:latest  -c hello-world ------------------------------------ this will add the image change trigger.
oc rollout latest dc/hello-world------------------------------------------------------------------------------------ this will rollout a DC with strategy to bring down the pod one ata time and bring other ups.
oc set deployment-hook dc/myapi --pre -c myapi -- /bin/echo Hello from pre-deploy hook----------------------------- Its for pre deploymet hook 
oc set deployment-hook dc/myapi --mid -c myapi -- /bin/echo Hello from mid-deploy hook------------------ Its for mid deploymet hook .for this first set the DC strategy to recreate bcse 
this mid dep hook can be set to recreate strategy 
oc edit dc/myapi --------------------------------------------------------------------------------------------- its used to edit the DC and we can change the strategy 
oc rollout latest dc/myapi  
oc set probe dc/hello-world --liveness --open-tcp=8080   :-------------------------------------------------- tcp-socket :8080 delay=0s timeout=1s period=10s #success=1 #failure=3
oc set probe dc/hello-world --liveness --open-tcp=8081 --------------------------------------------------- this will bring container in crashimageloopback bcse of wrong set up pg port to the liveness probe .
oc scale dc/hello-world --replicas=3---------------------------------------------------------------------- to scale up 
oc autoscale dc/hello-world --min 1 --max 10 --cpu-percent=80--------------------------------------------- for horizontal scaling setup 
oc get hpa  --------------------------------------------------------------------------------------------- will show you the targets 0%80% minpods and maxpods ,replicas and AGE
oc delete hpa ------------------------------------------------------------------------------------------- will delete the HPA
oc export all --as-template=myapi_template ------------------------------------------------------------- to  export the existing project in a template form .
oc create -f hello-world-template.yaml------------------------------------------------------------------- upload to OCP servers . once this is uploaded we can update or use it to create deplpments , bc , svc , route etc . this command creats the template and upload it to OCP and you use (oc process templatename)
VVimp ******* read this NOTE : Template is an another resource we can create it using a yaml and then we can use that template on ocp to create an app . OR we can also use the yaml file with -f to create app and its resources.
oc get template ----------------------------------------------------------------------------------------- to get the template created 
oc new-app templatenamecreated--------------------------------------------------------------------------- to cretae an app(dc,bc,service , route etc )
oc new-app hello-world  -p MESSAGE="HELLO FROM OTHER PARMS2 !!!!!! "------------------------------------- we are passing parameter value for variable/paramter named MESSAGE . hello-world is the template name 
oc process hello-world  : -------------------------------------------------------------------------------this will show the template as a json  ,hello-world is the template name 
Processing a file presnt locally without uploading the file to ocp server.	
oc process hello-world -o yaml -p MESSAGE="processing the yaml file ">> hello-world-template.yaml
oc process -f <filename> -------------------------------------------------------------------------------- to create the resources using the file . in this command shows the filename as a JSON or a YAML.
oc process -o yaml -f <filename> ------------------------------------------------------------------------ to create the resources using the file . in this command shows the filename is  YAML.
oc process -o yaml -f filename  > myapp.yaml ------------------------------------------------------------ this command will create the resources and write the output resources printed on console to a file myapp.yaml 
oc get -o yaml dc,bc,is,svc,route >> complete_arch_template_app.yaml    ---------------------------------> now once you export this to a file it contains list so you have to convert it to a template 
which need some changes to the yaml file exported out  , item to and remove the status object , annotations , , create datetime , UID etc 
		
oc new-app --docker-image=registry.access.redhat.com/rhscl/mysql-57-rhel7 --name=mysql-app -e MYSQL_USER=user1 -e MYSQL_PASSWORD=password -e MYSQL_DATABASE=books -e MSYSQL_ROOT_PASSWORD=password -l app=mydbapp   ---------------------------------------------------------- to run a musql db app 

oc new-app --docker-image=registry.access.redhat.com/rhscl/mysql-57-rhel7 --name=mysql-app --as-deployment-config -e MYSQL_USER=user1 -e MYSQL_PASSWORD=password -e MYSQL_DATABASE=books -e MSYSQL_ROOT_PASSWORD=password -l app=mydbapp

oc get all ---------------------------------------------------------------------------------------------- will show all the resources created 
oc get all -o wide --------------------------------------------------------------------------------------- this will shows the selectors as well .
oc rsh podname ------------------------------------------------------------------------------------------- to login in or go in shell mode into the pod 
	$:// mysql --version 
	$:// mysql -u user1 -p 
		enter the pass as password 
		mysql> SELECT VERSION ();
		
		VERSION : 5.7.12


oc process -f mysql.yaml -p MYSQL_USER=user1 -p MYSQL_PASSWORD=password -p MYSQL_DATABASE=books  | oc create -f - ------ to create a mysql app using a yamls file and push the parameter value fro outside using command 
oc process openshift//mysql-persistent -p MYSQL_USER=dev -p MYSQL_PASSWORD=$P4SSD -p MYSQL_DATABASE=bank -p VOLUME_CAPACITY=10Gi | oc create -f - ------------------ to create the resources using template : mysql-persistent and namespace : openshift separated by double slash(//)
oc create -f mysql.yaml -------------------------------------------------------------------------------------------------- to publish the application template to oc  
oc process mysql-persistent -p MYSQL_USER=user1 -p MYSQL_PASSWORD=password -p MYSQL_DATABASE=books  | oc create -f - ------ to create a mysql app using a tempate created by above command  
oc get quota -n meet14764-dev --------------------------------------------------------------------------------- this will give you the list  of  resource quota assigned to the project .
oc describe quota core-object-counts -n meet14764-dev  ----------------------------------------------------------- this will give youthe list of core-objec count quota assigned to the project 

oc policy--------------------------------------------------------------------------------------------------------- is used again, but this time roles are added to groups. Note that the service account name "jenkins" is never used. Only the service account group is used.

oc logs -f buildconfig/cotd2 -n pipeline-${GUID}-dev ------------------------------------------------------------- is used to watch the logs for the BC on project/namespace : pipeline-${GUID}-dev


---------------------------------------------Podman command as similar as the docker commands.-------------------------------------------------------------------------------------------------------------------

podman logs mysql-db ----------------------------------------------------------------- it is used to get the logs out.
podman images : ---------------------------------------------------------------------- it will show all the images .
podman search --list-tags httpd------------------------------------------------------- used to list all available image tags for the httpd container image
podman run --name my-httpd-container registry.redhat.io/rhel8/httpd-24 -------------------------------------------------------- thiswill create a cotainer using the image and container name will be http-server.
podman stop containr-d/container name : ------------------------------------------------------------- it will stp the container as per the container id .
podman kill container-id/container-name : ----------------------------------------------------------- it will kill the main container processs forcefully .
podman restart container-id/container-name ---------------------------------------------------------- it will restart thestopped container.
podman rm container-id : ---------------------------------------------------------------------------- it will remoeve the stopped container as per the container id given .
podman rmi image-nme/image-id ----------------------------------------------------------------------- it will remove the images from the local registry 
podman stop -a :------------------------------------------------------------------------------------- it will stop all the running container.
podman rm -a : -------------------------------------------------------------------------------------- it will remove all stopped containers.
podman pull registry.redhat.io/rhel8/mysql-80:1 ----------------------------------------------------- this will download the mysql image mysql-80:1.
podman save -o mysql_image.tar registry.redhat.io/rhel8/mysql-80:tag(any tag which is available)------------------------------------- this save command will wrap the metadat and the image layer into a tar file ready to be pshed to the registry.
podman rmi -a ---------------------------------------------------------------------------------------- remove all the local images .
podman load -i mysql_image.tar ---------------------------------------------------------------------- this will unload or extract the images from the tar file. its the apposite of the load command 
podman diff mysql-basic------------------------------------------------------------------------------The diff subcommand tags any added file with an A, any changed ones with a C, and any deleted file with a D.
podman inspect -f "{{range .Mounts}}{{println .Destination}}{{end}}" CONTAINER_NAME/ID--------------- to inspect the mounted volume of the container we can use inspect command.
podman commit mysql-basic(container Name running )  mysql-custom(new container image)------------------ to commit the changes to a new container. VVVVIMP
podman tag [OPTIONS] IMAGE[:TAG] [REGISTRYHOST/][USERNAME/]NAME[:TAG] example  : podman tag mysql-custom devops/mysql  or podman tag mysql-custom devops/hsingh/mysql:2.0 ---------------- To assign the tag to it.
podman push devops/hsingh/mysql:2.0 ----------------------------------------------------------------- push images to the repository.

Many Podman flags also have an alternative long form; some of these are explained below:
		-t is equivalent to --tty, meaning a pseudo-tty (pseudo-terminal) is to be allocated for the container.		
		-i is the same as --interactive. When used, standard input is kept open into the container.		
		-d, or its long form --detach, means the container runs in the background (detached). Podman then prints the container id.			

podman searhc rhel ----------------------------------------- Command to search the image in red hat image repository 
podman pull rhel ------------------------------------------- this will download the image on your local and can use it .
The image names are based on following syntax : 
registry_name/user_name/image_name:tag
podman images --------------------------------------------- this will show us the images present on local 	
podman run ubi8/ubi:8.3 echo 'Hello world!' --------------- this run command to run the container using the image 
podman run -d -p 8080:80 registry.redhat.io/rhel8/httpd-24---- to run a container in bakcground using -d .
podman port -l--------------------------------------------- to see the container port mapped .
podman run -it ubi8/ubi:8.3 /bin/bash---------------------- this command will create a container and do a bash inside the running container in interactive mode.
podman run -e GREET=Hello -e NAME=RedHat ubi8/ubi:8.3 printenv GREET NAME--------- this will inject environment variables into container from outside using "-e"
podman run --name mysql-custom  -e MYSQL_USER=redhat -e MYSQL_PASSWORD=r3dh4t  -e MYSQL_ROOT_PASSWORD=r3dh4t  -d registry.redhat.io/rhel8/mysql-80
podman login registry.redhat.io------------------------------------------------------ login to redhat image registry 
podman run --name mysql-basic -e MYSQL_USER=user1 -e MYSQL_PASSWORD=mypa55 -e MYSQL_DATABASE=items -e MYSQL_ROOT_PASSWORD=r00tpa55 -d registry.redhat.io/rhel8/mysql-80:1
podman ps --format "{{.ID}} {{.Image}} {{.Names}}" ---------------------------------- to see the cotainer runs correctly or not .
podman exec -it mysql-basic /bin/bash ----------------------------------------------- To do the bash to a running container  -it says to go bash mode .
bash-4.2$ mysql -uroot 
		>enter the password 
		mysql > mysql --version 
		
podman run --name mysql-db  registry.redhat.io/rhel8/mysql-80:1	---------------------- it will run the container will name mysql-db 
podman run --name mysql  -d -e MYSQL_USER=user1 -e MYSQL_PASSWORD=mypa55  -e MYSQL_DATABASE=items -e MYSQL_ROOT_PASSWORD=r00tpa55  registry.redhat.io/rhel8/mysql-80:1---------- to run the mysql container and setting the mysql username and password by sending environment variable value in the command .
podman cp /home/student/DO180/labs/manage-lifecycle/db.sql mysql:/ ------------------- this will copy the file from host machine to container(mysql) root directory and gave mysql as the users.
podman exec mysql /bin/bash -c 'mysql -uuser1 -pmypa55 items < /db.sql'--------------- this command is used to run the sql file which will create the table and insert the row into it.
podman exec mysql /bin/bash -c 'mysql -uuser1 -pmypa55 -e "select * from items.Projects;"'-------------------------- this will send the select query as the env variable value and run it inside container.
podman login quay.io ----------------------------------------------------------------------------------------------- to login to the quay.io 
podman run -d --name official-httpd -p 8180:80 quay.io/redhattraining/httpd-parent---------------------------------- to run apache tomcat server using podman in a container.
podman exec -it official-httpd /bin/bash -
	bash : echo "Welcome from D0180 class" > /var/www/html/index.html
podman stop official-httpd ----------------------------------------------------------------------------------------- to stop the running container	
podman commit -a 'harmeet_singh4' official-httpd do180-custom-httpd -------------------------------------------------------------------- this will create a new image outof the running apache container.	
podman tag localhost/do180-custom-httpd quay.io/harmeet_singh4/do180-custom-httpd:v1.0 -------------------------------- tagging the image we create above to a new tag 
podman pull quay.io/harmeet_singh4/do180-custom-httpd:v1.0 ------------------------------------------------------------ pulling the images we commit , tagged and push to the quay.io 
	
podman pull quay.io/redhattraining/nginx:1.17
podman images 
podman run -d -p 8080:80 --name=official-nginx quay.io/redhattraining/nginx:1.17
podman ps
podman exec -it official-nginx /bin/bash
	bash&:> echo "DO180" > /usr/share/nginx/html/index.html
	bash&:>exit
curl 0.0.0.0:8080
		DO180 
podman stop official-nginx
podman commit -a 'harmeet_singh4' official-nginx do180/mynginx:v1.0-SNAPSHOT--------------------------------------------- tagged the images 

podman run -d -p 8080:80 --name= official-nginx-dev do180/mynginx:v1.0-SNAPSHOT------------------------------------------ create a container using thenew tagged image.
podman exec -it official-nginx-dev /bin/bash
	bash&:> echo "DO180 page" > /usr/share/nginx/html/index.html
	bash&:>exit
curl 0.0.0.0:8080
		DO180 
podman stop official-nginx-dev
podman commit -a 'harmeet_singh4' official-nginx-dev  do180/mynginx:v1.0
podman ps -a
podman rm -a 
podman rmi image name to remove.

podman build -t apache:latest  . -------------------------------------------------------------------------------------------- to build an image using the Dockerfile or the containerfile.	
container file : 
	FROM ubi8/ubi:8.3  ----------------------------------- THIS IMAGE ACT AS A UNIVERSAL BASE IMAGE FOR ALL YOUR APPS OR MIDDLEWARES ETC .
	MAINTAINER Harmeet harmeet.singh4@ibm.com
	LABEL Description="A custom apache container based on ubi 8"
	RUN yum install -y httpd && yum clean all
	RUN echo "Hello from containerfile" > /var/www/html/index.html
	EXPOSE 80
	CMD ["httpd","-D","FOREGROUND"]  ----------------------------------- HERE THE ENTRYPOINT will be /bin/bash -c 

podman run -d --name=lab-apache -p 10080:80 apache:v1.0------------------------------------------------------------------ to run an apache server.

-----------------------------------To mount a host path to the container path ---------------

.mkdir /home/student/dbfiles
.podman unshare chown -R 27:27 /home/student/dbfiles------------------The podman unshare command provides a session to execute commands within the same user namespace as the process running inside the container.
.sudo semanage fcontext -a -t container_file_t '/home/student/dbfiles(/.*)?'----------------Apply the container_file_t context to the directory (and all subdirectories) to allow containers access to all of its contents.
.sudo restorecon -Rv /home/student/dbfiles--------------------------------Apply the SELinux container policy that you set up in the first step to the newly created directory:
.podman run -v /home/student/dbfiles:/var/lib/mysql rhmap47/mysql ---------- Mounting a Volume
.podman run --name mysql  -v /home/student/dbfiles:/var/lib/mysql -d -e MYSQL_USER=user1 -e MYSQL_PASSWORD=mypa55  -e MYSQL_DATABASE=items -e MYSQL_ROOT_PASSWORD=r00tpa55  registry.redhat.io/rhel8/mysql-80:1 ------ running a  container and also mounting the path so that i can bash into it to see the file i added.


.mkdir -pv /home/student/local/mysql
.sudo semanage fcontext -a -t container_file_t '/home/student/local/mysql(/.*)?' ------Add the appropriate SELinux context for the /home/student/local/mysql directory and its contents.
.sudo restorecon -R /home/student/local/mysql -----------------------------------------Apply the SELinux policy to the newly created directory.
.ls -ldZ /home/student/local/mysql-----------------------------------------------------Verify that the SELinux context type for the /home/student/local/mysql directory is container_file_t.
.podman unshare chown 27:27 /home/student/local/mysql----------------------------------Change the owner of the /home/student/local/mysql directory to the mysql user and mysql group:
.podman run --name persist-db  -d -p 13306:3306 -v /home/student/local/mysql:/var/lib/mysql/data  -e MYSQL_USER=user1 -e MYSQL_PASSWORD=mypa55  -e MYSQL_DATABASE=items -e MYSQL_ROOT_PASSWORD=r00tpa55  registry.redhat.io/rhel8/mysql-80:1
.podman ps --format="{{.ID}} {{.Names}}" ---------------------------------------------- is used to check if the container created/strated successfully or not .
then do a bash inside the container to see the file here and there.

-----------------------------------To mount a host path to the container path ---------------

So wecan use -p [<IP address>:][<host port>:]<container port> to map the port of the host to the container port 
.podman run -d --name apache1 -p 8080:80  registry.redhat.io/rhel8/httpd-24 ------------------------------ To run the container httpd using localhost port 8080 mapped to 80 port of container 
.podman run -d --name apache3 -p 127.0.0.1::80  registry.redhat.io/rhel8/httpd-24 ------------------------ Here the host port is not specified so the podman assigned a random port.
.podman run -d --name apache4  -p 80 registry.redhat.io/rhel8/httpd-24 ---------------------------------- Here if we mention the container port then random host is assigned to it.


.podman run --name mysqldb-port -d -v /home/student/local/mysql:/var/lib/mysql/data -p 13306:3306 -e MYSQL_USER=user1 -e MYSQL_PASSWORD=mypa55 -e MYSQL_DATABASE=items -e MYSQL_ROOT_PASSWORD=r00tpa55 registry.redhat.io/rhel8/mysql-80:1 ---------------------------------------------------------------------- here we are running the mysql DB in a container mounting the volume and forwarding the port hostport : container port .
.podman ps --format="{{.ID}} {{.Names}} {{.Ports}}"------------------------------------------------------- to check if th container restarts correctly .
.mysql -uuser1 -h 127.0.0.1 -pmypa55 -P13306 items < /home/student/DO180/labs/manage-networking/db.sql-------------- to run the sql we copied to the container . this command you can see running mysql command  and running the sql from host machine , it is  possible using the port forwarding . done by -p13306
.podman exec -it mysqldb-port  mysql -uroot items -e "SELECT * FROM Item"------------------------------------------- to run a query to get the rows from the DB table 
.podman exec -it mysqldb-port /bin/bash----------------------------------------------------------------------------- doing bash to the mysql container and then run the sleect query 
	- mysql login -uroot -p
		- select * from item;
		
		or 
		
 mysql -uroot items -e "SELECT * FROM Item"		
 
 
------------------------VVVVIMP Question for the DB setup ----------------------------------------------------------------------------

Q. You should be able to deploy and manage a persistent database using a shared volume. You should also be able to start a second database using the same shared volume and observe that the data is consistent between the two containers because they are using the same directory on the host to store the MySQL data.

ANS : 
.mkdir -pv /home/student/local/mysql
.sudo semanage fcontext -a -t container_file_t '/home/student/local/mysql(/.*)?' ------Add the appropriate SELinux context for the /home/student/local/mysql directory and its contents.
.sudo restorecon -R /home/student/local/mysql -----------------------------------------Apply the SELinux policy to the newly created directory.
.ls -ldZ /home/student/local/mysql-----------------------------------------------------Verify that the SELinux context type for the /home/student/local/mysql directory is container_file_t.
.podman unshare chown 27:27 /home/student/local/mysql----------------------------------Change the owner of the /home/student/local/mysql directory to the mysql user and mysql group:
.podman run --name mysql-1 -p 13306:3306 -d -v /home/student/local/mysql:/var/lib/mysql/data -e MYSQL_USER=user1 -e MYSQL_PASSWORD=mypa55  -e MYSQL_DATABASE=items -e MYSQL_ROOT_PASSWORD=r00tpa55  registry.redhat.io/rhel8/mysql-80:1
. podman ps --format="{{.ID}} {{.Names}}"---------------------------------------------- to check if the container started successfully .
. mysql -uuser1 -h 127.0.0.1 -pmypa55 -P13306 items < /home/student/DO180/labs/manage-review/db.sql------------------------ to run the sql file to the mysql 
. podman exec -it mysql-1  mysql -uroot items -e "SELECT * FROM Item"------------------------------------------------- to get the items inserted to DB 

*********Note : Stop the first container now 
start another container as name mysql-2 you will see that the second container will automatially loads up the insert query and data into db aling with table creations becuase of the persistent volume mounted the second container picked up the same data.sql file.

.podman run --name mysql-2 -p 13306:3306 -d -v /home/student/local/mysql:/var/lib/mysql/data -e MYSQL_USER=user1 -e MYSQL_PASSWORD=mypa55  -e MYSQL_DATABASE=items -e MYSQL_ROOT_PASSWORD=r00tpa55  registry.redhat.io/rhel8/mysql-80:1
. podman ps -a > /tmp/my-containers ------------------------------------------------------------------------ to save the stopped and running containers in a file 
. podman exec -it mysql-2 /bin/bash 
	bash&: mysql -uroot
		mysql> use items ;                     ----------------------------------------- this is to selecte the Dbs.
		mysql> insert into Item (description, done) values ('Finished lab', 1);
		mysql> Select * from Item;

 
------------------------VVVVIMP Question for the DB setup ----------------------------------------------------------------------------
	
	
------------------------OC cli command Lab to deploy mysql using new-app command   ----------------------------------------------------------------------------
oc login -u ${RHT_OCP4_DEV_USER} -p ${RHT_OCP4_DEV_PASSWORD} ${RHT_OCP4_MASTER_API}
oc new-project ${RHT_OCP4_DEV_USER}-mysql-openshift
oc new-app --template=mysql-persistent -p MYSQL_USER=user1 -p MYSQL_PASSWORD=mypa55 -p MYSQL_DATABASE=testdb -p MYSQL_ROOT_PASSWORD=r00tpa55 -p VOLUME_CAPACITY=10Gi
oc status
oc get pods 
oc describe pod mysql-1-5vfn4
oc get svc
oc describe service mysql
oc get pvc 
oc port-forward mysql-1-5vfn4 3306:3306
mysql -uuser1 -pmypa55 --protocol tcp -h localhost ------------ run it from another terminal 
mysql > show databases; --- show the dbs
		use databasename; ----- use th dbs
		show tables;------------ show the tables 
		
oc delete project ${RHT_OCP4_DEV_USER}-mysql-openshift

 oc expose service quotedb --name quote : to create a route we have to expose the service.


------------------------OC cli command Lab to deploy mysql using new-app command   ----------------------------------------------------------------------------

------------------------OC cli command Lab to create route for a service    ----------------------------------------------------------------------------

oc login -u ${RHT_OCP4_DEV_USER} -p  ${RHT_OCP4_DEV_PASSWORD} ${RHT_OCP4_MASTER_API}
oc new-project ${RHT_OCP4_DEV_USER}-route
oc new-app --docker-image=quay.io/redhattraining/php-hello-dockerfile --name php-helloworld
oc get pods -w
oc logs -f php-helloworld-74bb86f6cb-zt6wl
oc get svc
oc describe svc/php-helloworld
oc expose svc/php-helloworld : it will create a route and allow to access the service from a url from internet 
oc delete route/php-helloworld
oc expose svc/php-helloworld --name=${RHT_OCP4_DEV_USER}-xyz
curl  ${RHT_OCP4_DEV_USER}-xyz-${RHT_OCP4_DEV_USER}-route.${RHT_OCP4_WILDCARD_DOMAIN}
------------------------OC cli command Lab to create route for a service    ----------------------------------------------------------------------------

--------------------------------OC CLI LAB to create new app using th S2I scripts-----------------------------------------------------------------------
git clone https://github.com/harmeet2401/DO180-apps
git checkout master
git checkout -b s2i -- create a new branch
git push -u origin s2i
oc login -u ${RHT_OCP4_DEV_USER} -p  ${RHT_OCP4_DEV_PASSWORD} ${RHT_OCP4_MASTER_API}
oc new-project ${RHT_OCP4_DEV_USER}-s2i
oc new-app php:7.3 --name=php-helloworld https://github.com/${RHT_OCP4_GITHUB_USER}/DO180-apps#s2i --context-dir php-helloworld ------ here the php:7.3 is the base image and it will build the project from s2i branch of the git project 
oc logs --all-containers -f php-helloworld-1-build 
oc describe deployment/php-helloworld------------------------------------------------------------------------------------------------ describe the deployment 
oc expose service php-helloworld --name ${RHT_OCP4_DEV_USER}-helloworld ------------------------------------------------------------- to create route of the service 
now chang the index.php and add some sentence . change and 
git add .
git commit -m ""
git push -u origin s2i 
oc start-build php-helloworld ------------------------------------------------------------------------------------------------------- to start the build again so that the new image will be created and new deployment will be rolled.
curl -s ${RHT_OCP4_DEV_USER}-helloworld-${RHT_OCP4_DEV_USER}-s2i. ${RHT_OCP4_WILDCARD_DOMAIN}
--------------------------------OC CLI LAB to create new app using th S2I scripts-----------------------------------------------------------------------


----------------------------------------------------------------------Lab Webconsole using S2I------------------------------------------------------------------------
login 
create projetc 
Developer catalog 
select the builder imaeg 
enter the git repo 
git ref : branch name : name
create 

source /usr/local/etc/ocp4.config
oc login -u ${RHT_OCP4_DEV_USER} -p  ${RHT_OCP4_DEV_PASSWORD} ${RHT_OCP4_MASTER_API}
oc new-project ${RHT_OCP4_DEV_USER}-ocp
oc new-app  --name=temps  php:7.3 https://github.com/RedHatTraining/DO180-apps/ --context-dir temps ---------- to create an app 
or 
oc new-app  --name=temps  php:7.3~https://github.com/RedHatTraining/DO180-apps/ --context-dir temps
----------------------------------------------------------------------Lab Webconsole------------------------------------------------------------------------

---------------------------------------Deploying the Web Application and MySQL on Linux Containers----------------------------------------------------------
ip -br addr list | grep eth0  ------------------------------------------------- Command to see the host ip address and port.
cat /home/student/DO180/labs/multicontainer-design/deploy/nodejs/nodejs-source/models/db.js ------- see the content
cat  /home/student/DO180/labs/multicontainer-design/deploy/nodejs/build.sh ---------- run the build.sh file to use the ContainerFile to create an image.
cd ~/DO180/labs/multicontainer-design/deploy/nodejs
./build.sh
podman images --format "table {{.ID}} {{.Repository}} {{.Tag}}"
Edit the run.sh file located at /home/student/DO180/labs/multicontainer-design/deploy/nodejs/networked to insert the podman run
podman run -d --name mysql -e MYSQL_DATABASE=items -e MYSQL_USER=user1 -e MYSQL_PASSWORD=mypa55 -e MYSQL_ROOT_PASSWORD=r00tpa55 -v $PWD/work/data:/var/lib/mysql/data -p 30306:3306 registry.redhat.io/rhel8/mysql-80:1 ------ to run the mysql image 
podman run -d --name todoapi -e MYSQL_DATABASE=items -e MYSQL_USER=user1 -e MYSQL_PASSWORD=mypa55 -p 30080:30080 do180/todonodejs --- command to run todo node js image
./run.sh --------------- this script is used to run the images and two containers formed by above two commands
podman ps --format="table {{.ID}} {{.Names}} {{.Image}} {{.Status}}" ------------ to see th pod started or not 
mysql -uuser1 -h 172.25.250.9  -pmypa55 -P30306 items < /home/student/DO180/labs/multicontainer-design/deploy/nodejs/networked/db.sql
podman exec -it todoapi env----------------------- to see th exposed env variable 
curl -w "\n" http://127.0.0.1:30080/todo/api/items/1 ------------ curl to the todoapi app 

---------------------------------------Deploying the Web Application and MySQL on Linux Containers----------------------------------------------------------


--------------------------------------Guided Exercise: Creating an Application on OpenShift-----------------------------------------------------------------
source /usr/local/etc/ocp4.config
oc login -u ${RHT_OCP4_DEV_USER} -p ${RHT_OCP4_DEV_PASSWORD} ${RHT_OCP4_MASTER_API}
oc new-project ${RHT_OCP4_DEV_USER}-application
cd /home/student/DO180/labs/multicontainer-application --------------- to see the yaml file a template 
oc create  -f todo-app.yml--------------------------------------------  to publish the application template to oc  
oc port-forward mysql 3306:3306 -------------------------------------- host machine port forwarding to container port 
cd /home/student/DO180/labs/multicontainer-application
mysql -uuser1 -h 127.0.0.1 -pmypa55 -P3306 items < db.sql------------- to run the sql file for the db installed cntainer.
oc expose service todoapi ----------------------------------------- create a route to access the container.
oc status | grep -o "http:.*com" ---------------------------------- to get the route url 
curl -w "\n" > routeurl(oc status se lelo )/todo/api/items/1 ---- curl to the todoapi 

--------------------------------------Guided Exercise: Creating an Application on OpenShift-----------------------------------------------------------------
	
	
----------------------Deploying a multi container application on OCP  env using a Template ------------------------------------------------------------
oc get template -n openshift ------------------------------- to get the templates on a project. 
oc get -o yaml dc,bc,is,svc,route >> complete_arch_template_app.yaml    ---------------------------------> now once you export this to a file it contains list so you have to convert it to a template 
which need some changes to the yaml file exported out  , item to and remove the status object , annotations , , create datetime , UID etc 
oc get template mysql-persistent -n openshift -o yaml --------------------------------------------------- to get the template in a yaml  or you can use >> to get that in a yaml file , -n shows the OCP project 
oc create -f todo-template.yaml ------------------------------------------------------------------------- to publish the application template to oc .
oc describe template mysql-persistent -n openshift ------------------------------------------------------ to get the description of a template 
oc process --parameters mysql-persistent -n openshift --------------------------------------------------- mysql-persistent is the template name 

template name example : 3scale-gateway










----------------------Deploying a multi container application on OCP  env using a Template ------------------------------------------------------------	

---------------------------------------------Podman command as similar as the docker commands.-------------------------------------------------------------------------------------------------------------------
