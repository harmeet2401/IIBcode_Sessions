Java Course ----------------------------------------
1. java is iteroperable or can be run on multiple platform using the JVM(java virtual machine) on the target system .
2. Platform independent : Java bytecode created by the java compiler .
	The byte code we can run it on the jvm in target system .
	
	
	
	
	java code ------------------------> compiler -----------> byte code --------------> translate the byte code to binary codes-----------------> Run on target system.
	
	C and c++ compiler doesnot create a byte code. It sirectly run the binary code post compilation 
	
	Because of the extra step in java of creating a byte code its some says its slower . But we can use JUST-IN-TIME-COMPILER .  whic at the same time converts the byte code to the binary code and machine language.
	
	JDK  -------Contains ---------------> Compiler & JRE  -------->Contains the JVM and class binaries  -------JVM -----> is the virtual env to run .class file
											|						required to run the program . 
																	No compiler is there
											|
											|
											|
								Its the source code compiler to compile the .java file to create the .class file.	
									  
3. JRE and JDk and JVM : 
	- JRE : Java run time environments.
		Its a software package that only contains the JVM and class liberaries which are required to run a java program . we can not compile the java program using a JRE.
		It provide just in run time env.
	- JDK : Java development kit : 
		Its a combination of JRE and Java compiler .
		Compiler will helps in compiling the new java code and JRE containg JVM will help in running the code by converting the byte code to binary language.
	

NOTE : IN NUT SHELL , IF WE NEED TO WRITE , COMPILE AND RUN THE CODE WE NEED JDK WHICH HAVE JRE AND COMPILER . IF WE WANT TO RUN A JAR FILE OR THE .CLASS FILE WE ONLY NEED JRE AS IT PROVIDES THE JVM FOR RUNNING THE CODE.

4. Class is the blueprint from which we an create the different objects .
	understand it like class is a generic page or higher classification . Like person : ----person is a blue print for two types of persons(girl or  a boy.)
	Class is Person 
	Object can be Person james = new Person()
	Object can be Person clark = new Person()
	Object can be Person mia = new Person()
	
5. Life of objects :  So we know that : Person a = new Person();

			Person a ----------> its like creating a reference object and a romote control ready to point to a  memory locations.
			
			new Person ---------> This will create a heap memory allocations .
				
				In order start making the ref remote cnotrol pointing to heap mem allocated we need to link these.
				
				Person a = new Person(); -------------> linking or start making the object a start pointing to JVM heap memory location 
				
			In my view creating multiple objects and heap memory with it will use more memory space of you system .
			Instead we can point the reference object to the same heap memory space . But that might end up bombarding the healp memory used by all instance objects 
			so we can create object by referencing it .
			Person a = new Person();
			Person b;
			b=a ------------------------- this will also point to the same heap memory locations.
			
6. Package name :  Collections of classes.

	Access modifier default is it is access with in the class only . 
	if we put that in different package we need to make it public to import it another clas. 
				
				With in Class 					IN Same package 			In subclasses			In Other packages 			
    public  	Allowed access					Allowed access				Allowed access			 Allowed access								
	protected   Allowed access					Allowed access				Allowed access 			 Denied access							
	default     Allowed access					Allowed access              Denied access            Denied access                                  		
	private   	Allowed access 					Denied Access 				Denied Access			 Denied Access 				
	
	
		
	
7. variables and data types  :

	a.  Premitive data type variable  : like : char , int , short , long , double . All these have different storage size.
			variables : Instance variable and Local variable
			- Instance variable : 
				Those variables which reside inside the class level. and is get initialized whenever the instance of that class is created,
			- Local variable : 
				Those variable declared inside the mthod of the class . those variables should be initialized or else the compiler will complaint.
				default value for int, byte , long , short =  0 , boolean is false ,  float , double  = 0.0 and for char = '\u0000' , this is the unicode value for char when you will sout the char using unicode it will print the char a , b, c, ....
				
	b.  Reference variable : Are the variable which are refrencesd to the heap memory .
			Person alex  = new Person();
			-----------
				|
				|
				|
			Reference variable .	

8. type casting  : Explicit casting from one data type to another .

9.Scope of variable : 				

	Static variable : It is accessible by all objects in a class and have a single copy of it across the class. This get loaded to the JVM when the program runs
	Instance variable : Which got initialized when the object or class gets instantiated. As it is on class level it can be accessed by all objects in the class
	Local variable : Is accessible only inside the method block .
	Block variabe : Whic is access only inside a block of code , like if  else block , for loop block etc . out side of these these are not accessible 
				Example: 
					if(x == false){
							boolean y = true 
							Sout(y); ------------------------ this will print the y
					}
					
					Sout(y) -------------- this will not print y and throws compile error.
					
10. variable modifier .

	Below access modifiers are used only for instance variables 
		- public : public/protected/default final in i =0 ; 
		- static : static final int i = 10; it wil have common copy for all objects and access to all.
		- transient : transient static int i = 10 ;  its used for variables not be included as part if the serialized string or value used for transmitting data to other system 
		- volatile : volatile int i =0 ; to make the variable thread safe .
		
	Below modifier is used only for local variables & instance variables. : 
		- final keyword : final int i = 10 . this is telling the compiler the final value for i is 10 and no one can chnge the value for i later . if you are writting instance variable with final keyword you have to initialize it or else compile issue will be ther e.
		
11. Operators in java : 

		Important point : always use equals in string comparisons 
		++ and -- : always try to use it in suffix like : ++x or --x , if  you want the value incremented assinged it to x immediatley 
			x++ and x-- will increament and decrement the valus but will be assigend to the variable on next set of code lines.
		
	- below loc will give same results  : 
		System.out.println(--x1);
        System.out.println(x1);
		
	- below loc will give diffe results : 
		System.out.println(x1--);
        System.out.println(x1);
		
	- conditional operators :  example 
		- z =  x==y ? z = 100 : z =109;
		- z = str1.equalsIgnoreCase(str2) ? 100 : 109;
		
	- you can either use & or &&  , | or || both will work in same manners

12. Wrapper classes : 	 In collections we use wrapper classes as we can not use primitive data types in collections to store data .
		ArrayList<int> alist = new ArrayList<int>(); // invalid
		ArrayList<Integer> alist = new ArrayList<Integer>(); // valid
		
		Where Integer is the wrapper class.
		These classes are ussed to wrap primitive data types value like : boolean , byte , char , int , long , short , double , float etc 
		
		primitive data types 				Wrapper class 
		boolean									Boolean
		byte									Byte 
		char									Character
		int										Integer
		long									Long
		short									Short
		double									Double
		float									Float

	Notes 	We can understand it like this : we can declared the wrapper class object as this Boolean b = new Boolean(false) ; ------> in this , the constructor is used to hold the primitive data value.
	
	****BOXING AND UNBOXING : 
		The automatic adaptation of primitive data types into its corresponding Wrapper type is known as boxing, and reverse operation is known as unboxing
	**** AUTOBOXING AND AUTOUNBOXING : Autoboxing is the process by which a primitive type is automatically encapsulated (boxed) into its equivalent type wrappers whenever an object of the type is needed	
		This is the cool feature of java in which if we want to convert the primitive data type value to wrapper class just directly write it like tihs :
		- Interger f = 100;   here the Integer is the wrapper class and 100 is an int value , java is converting it automaticaaly to wrapper which is now giving us the advantage to us all other functions that wrapper class provide.
		- normal way to wrap a primitive value in wrapper class  
			Byte b = new Byte(10);
			Float b = new Float(10f);
			Double b = new Double(10d);

13 . Q WHERE THE OBJECTS , METHOD , INSTANC VARIABLES , LOCAL VARIABLE RESIDES IN ?
				
		HEAP MEMORY (garbage collectable memory)-----								STACK MEMORY--------
        						
		Objects 																	Methods 
													
		instances variable 															Local variables 
			
		
			
	Objects reside in the heap memory which can be released when the garbage collector comes .
	instance variables are connected with Objects so it also stays on heap 
	
	Methods reside in stack just like a stack of books , execute the methods one by one and pos  out of the memory
	Local variables as usual declared inside mothods so it also stay on stack .
	
	
	While coding keep in mind how to utilize the memory 
	
14. Modifiers of Methods : 	
		public : access from all 
		protected : restrict the access in same package 
		private : can not acess.
		default : can call it from same class only 
		static  : no need to create an insance/objects of the class in which this method is to access it . It will beloing to class.
		final   : Can not override the method  in child class which inherit the base class that contain final method.
		abstract : it is used only to declare the method without body .
		synchronised : only one thread can access this mthod at a time . Oher threads will wait for the release.
		
15. lambda : 
		Now Let's convert regular incrementByOne method to Lambda expression step by step.
		
		This is original method,
		
		public int incrementByOne(int num) {
			return ++num;
		}
		Step 1: Remove Access Modifier, Return type and Method Name
		
		So expression will be like like this,
		
		(int num) {
			return ++num
		}
		Step 2: Add Lambda operator(->) between the parameters and method block,
		
		(int num) -> {
			return ++num
		}
		This is the modified version of incrementByOne using lambda expression. If you want to simplify further, parameter’s data type is optional, so Let's remove those
		
		So method will be looks like this now.
		
		(num) -> {
			return ++num
		}
		To simply further,
		
		If your method has only one line of statement, you can remove {}. And also, if code is not in block return keyword is not needed
		
		So method will be looks like this now.
		
		(num) -> ++num;
		
		
		Sample code for Lambda expression:
		
		interface NumExamples{
			public int incrementByOne(int num);
		}
		
		public class MyClass {
			public static void main(String[] args) {
			NumExamples result = ( num) -> ++num;
			}
		}
		Since we haven’t discussed interfaces yet, The above code might be hard to understand for you. For now, just understand the idea of the Lambda expression.
		
		Note: If you are comfortable with the earlier structure of method implementation, feel free strict with the same. This is just an advanced and simplified version of the method structure.

		
16. Switch statements are better then if else block , the execustion line of code is lsser and it is faster then if else .
			switch (a == 0 || a==-1 | a==-2 | a==-4 | a==-3 ? 0 : 10) {
            case (5):
                System.out.println("FIRST BLOCK WITH a = 5");
                break;
            case (1):
                System.out.println("SECOND BLOCK WITH a = 1");
                break;
            case (0):
                System.out.println("THIRD BLOCK WITH a = 0");
                break;
            default :
                System.out.println("DEFAULT BLOCK EXECUTED");
                break;
        }
 
17. lambda expression in java for loop to break use return statement in it .

18. Constructor : 
			- Constructor can not have return type and can not be statis 
			
			- It is used to initialize the class variable .
			
			- As we did in rest api to initialize the bean attributes to a values.
			
			- One amazing thing learned is in our pojo class or bean class we can add both the constructor parameterized and non parameterized
				Paramterized will help in initializing the attaribute variable by passing the value in constructor.
				Non-parameterized will help in initializing the variable by using the .(dot) opertaor by crating the object of the class.
			
			- this() function used in pojo class itself will caal the constructor of the same class and this one will call the non-parameterized one
			  this(1,"Meet","orlendo") this will call the 3 parameterized constructor in same pojo class.
			  this("meet",100999) this will call the 2 parameterized constructor in same pojo class.
			
			- super() function used in pojo class itself will call the constructor of the super class class and this one will call the non-parameterized one and if no super class is there then Object class constructor will be called 
			  super(1,"Meet","orlendo") this will call the 3 parameterized constructor in super pojo class.
			  super("meet",100999) this will call the 2 parameterized constructor in super pojo class.

	#IMP# : whenever you write a constructor in your class , compiler adds the super()function in starting point of it automaticaaly which will call the constructor of java.lang.object class if no class is extended.
	#IMP#  Single ton class : Can have only one object and can not be instantiated again .	

19. STATIC MEMBERS : static members can not call non-static members and vice - versa  . static is for class.

		Applied on below members of java : 
		
			1. static Instance variable : variables which are on class level can only be declared as static . public static int setavailable = 90;
				static variable are which will be common to all objects like 
					no of seats available is common to all tickets going to each pessenger . which will have an updated count . mean 90 is available for all .
			
			2. Static blocks : which will be run at the verry first step , sbse pehle run hogga 
			3. Static methods , will be called using the class name and not by creating a clas instance. Multiple static blocksare executed sequentially.
			
20. Inheritance : 			

	- Wecan use extends the super class 
	-  public class subclass extends superclass
		subclass object = new subclass();
		
		this will use the super class and base class members.
		
		superclass object = new subclass();
		this will again  use the super class and base class members.
		
		superclass object = new superclass;
		this will use the super class only.
	- We can also pass the subclass type object as a paramter to a function needing super class objects
		
		public static lesswalk (Human h){
		
			sout(name + " :   walks less");
			
		}
		
		psvm(){
			sportsperson a = new sportsperson();
			a.name = "keen";
			lesswalk(a); ---------------------------------------------------------> subclass refenrce means HUman super set hai and sportsperson is subset humans ka 
		
		}
	
	- ambiguous arises and java doesnot support multiple inheritance and extends for two super class , nope not possible.
	- if we use final keyword for a class make that class non extendable .
	
21. Interface : Are the abstract class which contains the abstract functions and promotes the abstraction features by not defining the method functions .

			we know human can be categories as Artists and musician , both have diffr eating style , walking , breathing level and eye colours .
			Thses differnet featres we can keep it as a template in interface and fill the template when Implemented in sub class.
			
			- variables are final and static 
			- functions ar abstract declared without body.
			- we can not make a instance for an interface 
				but we can create a references 
				
					GenericLivingCreatureInterface g = new Human(); --------------- possible
					Human h = new GenericLivingCreatureInterface();  --------------not possible 
			- we can multiple inheritance by multiple implements of interface 
			
			#IMP# : Imagine one interface is implemented in 1000 classes , adding a one more function in interface will break all 1000 classe 
				to overcome this we have default function in which we can add the function body in interface itself 
					
					default void check(){
						System.out.println("new function added");
					}
					
			- two interfaces have same fnction : how to call the functions then post implementation		
				
				code : Interfacename.super.functionname()
				
22. abstract classes : 
					- unlike interface , abstract classes can have functions with body . and withour body also .
					- even a one function in a class abstract then the clas is abstract
					- We extends these.
					
23. Encapsulation : - Hiding the back end functionality . Just like remote control , you can see the buttons to control .
					- Hiding can be done using the access modifiers .
					
					Steps to set the encapsulations : 
					- Private access modifier can be used to do that for all class instance variables.
					- then generate the getter and setter for them.
					- then go to places where we need the variable values using the getter and set the value usng setter.
					 setter : writting 
					 getter  : only readable 
					 
					------ in rest api or spring boot api , we don;t need to extends the bean class , we can import it and use it.

24. Polymorphism : 
				- One super class gots extends in two sub classes , overriding a functions of super class with two diff defination in two diff sub classes is polymorphism 
				- Runtime polymorphism: 
					overriding a mthod rule : 
							name same 
							arguments match 
							body differ.
							Access level should not be highly hidden like private . Keep public 
							We can not override a method marked as final 
				
				- Method overrloading   : 
						Rules : 
							Keep the name same 
							change the arguments list 
							change the return type 
							change the acess modifier 
					
25. String classes  : from java.lang.string 
				
				Keep this in mind
					- == operator if we apply on a reference objects it will tell if it is pointing to the same memory locations ?
					- equals operator will compare the string values . Always use equals/equalsIgnoreCase for string compare
					- String objects are immutable means we can change the value but need to chNGE THE REFERENCE VALUE 
						String str1 = "test ";
						str1 =str1.concat("jaav");
						sout(testjaav)
						
26. Stringbuffer and stringbuilder 	:  Strongest tool or classes to create string and can concatenate any data types value 
		stringBuilder.append("@@"); ----------------- the parameter can be int , float , double , short , string .
			
		these are not immutable classes , we can do as many chanes as we can .
		its thread safe .
		
		 StringBuffer strb = new StringBuffer("Welcome to java ");
          strb.append("((");
          System.out.println(strb);

          StringBuilder stringBuilder = new StringBuilder("Welcome to java ");
          stringBuilder.append("@@");
          System.out.println(stringBuilder);

27. Exception handling : 

	Exception are sudden error occured in our program which may be a result of a file not found exception or stackoverflow exceptio , array index ot of bound exception etc 
	
	Types of exception : 
	  - checked exception : These are the exception which comes during compilation . The java compiler throws these exception during the compile time and does not allow a clean compile and will not create a .class(byte code) file for it.
	  - Unchecked Exceptions : Runtime exception. These exception comes at runtime due to unwanted code bug etc . in this case the .class  has already been generated but will break while running the code in JVM.
	  
	The order or hierarchy of thr exception really matters :
		Objects 
			|
		Exception
			|
	ioex  , clssnotfoundex , .... runtime exception 
										|
									Arithmetic exception , numberformt exception , null pointerexceptio  ....... more 
									
	so we have to add multipe catch block by checking our code .
		Exception class is capable of catching all exceptions .
		
								
      - Finally block : 	
				This block always run . this block comes at the end of the catch or try block . We mostly used this block to close all the open inputstream , db connections , flush the buffer etc . This will help in reducing the memory leak due to db connection s, network leak etc .
				
	  - propagating the unhandled exceptions  : means the exception occured upstream or backword if not catched , similar to what we do in IIB .
		
	  - Throw and throws : 
			Throw key word we can use to throw an exception like throw new NumberFormatException("Messge for it")
			Throws we can use to throw multiple exceptions from downstream method to upstream .
			
	  - Custom exception or user define : 
													 - create a class and								
													 - extends Exception class and write a constructor and pass the message attribite to super(message)
													 - use throw new MyExceptionClass("your message")
													 
28. Collections :  it can hold collections of objects 
					commaon function s: 
						sort ()
						remove()
						purge()
						add() etc 
		List : it will store the list of objects , arrayList ,  are extended implementation of list.
		Set : to store the unique values . Hashset is the extendable of set 
		Map : Key and value pair.  when we need object from list or collections we have to iterate the collections , but map we can just push the key and we can get the value out. quick and faster then collections  , hashmap  is the extendable of map .
		Queues : FIFO flavour. linkedList is extendable
		
	1. Before using a collections always thing about : 
			You need : 
				- sorted or unsorted 
				- ordered or unordered 
				- unique or duplicate value 
				
		- Collection is an ordered data set .
		- sorting order is used to sort the data . we can use Collections.sort()
			: But how to sort the collection if it contains the bean objects collections 
				ArrayList<Person> arraylist = new ArrayList<Person>();
					We have to tell the Collections how to sort  verrrrrrryyyyyyyyyyyyyyyyyyeasy 
			: go to your pojo class implements the Comparable<Person> and override the compareTo method 
					  @Override
					  public int compareTo(Person o) {

							return name.compareTo(o.name);
							}
	Important : ---------								

		a. Arrayalist : collection of objects and kind of works as a array but is dynamic and can increase size without dclaring it in pre-requisite. Its index based insertions.
		
		b. LinkedList : Works in node structure .
						Single linkedlist : data|pointer(addressof next node)  ---------------> data|pointer(addressof next node)
						Double linkedlist : pointer(addressof previous node)|data|pointer(addressof next node)  ---------------> pointer(addressof previous node)|data|pointer(addressof next node).Its index based insertions.
						Faster then arraylist to delete and add the elements in list . we can use addfirst and addlist
						
		c. Vector : It is similar then arraylist , slower then array list and is thread safe means only one thread can access it one at a time.
			its synchronised and increase the size of the array to 100% if one more elements is added. Its index based insertions.
			
		d. Hashset : It will remove the duplicate elements and it is not index based data strucure . We know it will remove the duplicate in case of string objects , but how it will find duplicate in case of POJO java objects as a primitive passed in it 
			for exaple : Hashset<Person> newper = new Hashset<Person>();
				Q. Here we used person and want to remove the duplicacy how ?
				Ans. As  a dev first we have to find which attribute of person makes it duplicate . Same what we observed in Rule coding 
					for example we can use Id and name both to be part of duplicate check. 
					We have to override the equal and hashcode method of Object class which Person class extends by default . the default equals method says all person objects are Different .
					exmaple :  below two objects are different , if we do per1==per2 it will be false as it is point to a different memory space .
						Person per1 = new Person("beet","88277",9129);
						Person per2 = new Person("beet","88277",9129);
					
				IMP : Generate the hashcode and equals and  generating the hashcode and equals we could able to see the duplicate removed.
				
		e. Hashmap : its a key value pair data structure . its not index based insertion data str. Its faster then any other data strc we discusse .
		For large amount of data hashmap is used as look up of elements at different index is pretty easy , just pass the key and ollllaaaa we got it.
						
			Verry verry important : 
					How hashmap works internally  : 
					
				- hashmap works on the process called hashing .
				- hashing involves a hashcode function which generate the hashcode using the key we give while putting and that hashcode is the index value in the Hashmap bucket array that resides in memory .
				- Each array index of hashmap bucket contains a linkedList which holds the elements [key,value]|addresstonextnode 
				- When we do map.put("IN",indiabj);
				
				hashing will pick the IN key and push it to hashfunction and generate the hashcode (hashmap bucket array index) and stores the [key,value] at that index.
			
		Case 1 : inserting the data 
				example for IN ------> hashfunction() -----hashcode generated ----> 2
				
																													
							map.put("IN",indiaobj)								map.put("US",usobje)																
								|													|								
								|													|								
								IN													US																				
								|													|								
		hash fucntion () -- returns 2      									hashfunc() ---> returns 2
							
							
										
												map.put("GM",gmobje)
													|				
													|				
													GM				
													|				
											hashfunc() ---> returns 0
										
										
										
										
										
								Hasmap Bucket
							 ---------------------------------------------------	
							|Array							 					|					
							| 0 -->[GM,v]|pointer
							| 1                              					|	
							| 2 -->[IN,v]|pointer--->[US,v]|pointer     		|	
							| 3	                             					|	
							| 4                              					|	
							| 5                              					|	
                            | 6                              					|	
							| 7                              					|	                                                                            
							| 8                              					|	                                                                            
							| 9                              					|	                                                                            
							| 10                             					|																				
							|		                         					|																					
							 ---------------------------------------------------																							
		Case 2 : Getting the data 																											
		
											map.get("GM")
													|				
													|				
													GM				
													|				
											hashfunc() ---> returns 0
											
				It goes to the bucket at 0 index and using the equals functions will search the GM and retrun the value back.
																													
        Case 3  : what happen in case of th Person objects or pojo object saving then we can either add the hashcode fnction to override and equals method to override . But by default all classes extends the functiosn fro objects class.																														
																													
		f. Linkedhashset : 	Aswe saw the elements entered in hashset while retrieving it the elements are in different order.
			To remove that use Linkedhashset and ollla ||||.
		
		g.Treeset : We know we can use the Collections.sort to sort the collections , but when you push the data to treeSet it will automatically sort the data in ASCENDING ORDER and also removes the duplicates	 . this is one of best data structure for ascending ordered sorted and unique value holding technique.
		
		h. hashtable : are synchronised as hashmap is synchronised.
			It will not allow null for a key .hashtable.put(null,"kk"); /// null pointer exception will be thrown
		
		I. LinkedHashMap : The only difference is that it will maintain the order . and slower then hashmap.
		
		j. TreeMap : Its sorted , means sort acc to natural method. Similar to hashmap , but is sorted .Treemap it will sort the coll will not allow null on key
		
		K. queue collection :  Root interface and used by linkedList and Priorityqueue. dqueue to remove and add to insert .
		
		L. Priorityqueue : wil insert the data in sorted order .
		
29. Thread : Multithreading and multipe processing .

				Steps to create multi threaded env : 
					1. create  a class whih extends the Thread class  or implements the Runnable interface 
					2. Override the run method and implement the job .Run method can be invoked by crating object of the Thread class.

30. synchronised block and methods : This will help in multi threading architecture which will allow only one thread to  hold the method , variable or resource at a time .

			public synchronised void run(){   -----------> this will lock the method complete for on thread to complete 
			
			
			}
			
			synchronised(){ -------------------- this will allow use to lock a piece of code to get locked for one thread to complete and let go post that.
			}
			
			sleep()
			
			setPriority() --- to cheange the priority of thread Min_pri(1) , normal_pri(5) , max_pri (10)
			
			isAlive()----> to get if the thread is still alive 
			
			wait()-------->  this will make the thread to wait , but will not come alive untill we use notify method for it.
			
			yield ()-----> will give other thread the chance to run if other thread is taking more time
			
		- states of threads : 
				
				new ----->Runnablbe ------>Running ----------->Dead
							/\				|
							|				|
							|				\/
							|---Waiting/-----
									block 
									
31. Serialization : As we used this to convert the data to bytes to send across the network .
										As we used in kafka stream .
										
				We can serialized and deserialized at the target system .

			Remember when we serialized the data into byte stream in kafka produce stream and deserialize the data to readable in target ss
			
			Steps to do serialization : 
					- Create a class pojo class and implements it with Serializable .
					- In PSVM Create a fileoutputstream and filename in ti 
					- then create ObjectOutputStream object and pass the fileoutputstream obj
				    - ObjectOutputStream.writeObject(pojo);
					
			steps to do the deserialization : 
			- Create a class pojo class and implements it with Serializable .
					- In PSVM Create a fileintputstream and filename in ti 
					- then create ObjectinputStream object and pass the fileintputstream obj
				    - polo = ObjectOutputStream.readObjects();
					
			