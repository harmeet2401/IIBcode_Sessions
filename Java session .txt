Java Course ----------------------------------------
1. java is iteroperable or can be run on multiple platform using the JVM(java virtual machine) on the target system .
2. Platform independent : Java bytecode created by the java compiler .
	The byte code we can run it on the jvm in target system .
	
	
	
	
	java code ------------------------> compiler -----------> byte code --------------> translate the byte code to binary codes-----------------> Run on target system.
	
	C and c++ compiler doesnot create a byte code. It sirectly run the binary code post compilation 
	
	Because of the extra step in java of creating a byte code its some says its slower . But we can use JUST-IN-TIME-COMPILER .  whic at the same time converts the byte code to the binary code and machine language.
3. JRE and JDk and JVM : 
	- JRE : Java run time environments.
		Its a software package that only contains the JVM and class liberaries which are required to run a java program . we can not compile the java program using a JRE.
		It provide just in run time env.
	- JDK : Java development kit : 
		Its a combination of JRE and Java compiler .
		Compiler will helps in compiling the new java code and JRE containg JVM will help in running the code by converting the byte code to binary language.
	

NOTE : IN NUT SHELL , IF WE NEED TO WRITE , COMPILE AND RUN THE CODE WE NEED JDK WHICH HAVE JRE AND COMPILER . IF WE WANT TO RUN A JAR FILE OR THE .CLASS FILE WE ONLY NEED JRE AS IT PROVIDES THE JVM FOR RUNNING THE CODE.

4. Class is the blueprint from which we an create the different objects .
	understand it like class is a generic page or higher classification . Like person : ----person is a blue print for two types of persons(girl or  a boy.)
	
5. Life of objects :  So we know that : Person a = new Person();

			Person a ----------> its like creating a reference object and a romote control ready to point to a  memory locations.
			
			new Person ---------> This will create a heap memory allocations .
				
				In order start making the ref remote cnotrol pointing to heap mem allocated we need to link these.
				
				Person a = new Person();
				
			In my view creating multiple objects and heap memory with it will use more memory space of you system .
			Instead we can point the reference object to the same heap memory space . But that might end up bombarding the healp memory used by all instance objects 
6. Package name :  Collections of classes.

	Access modifier default is it is access with in the class only . 
	if we put that in different package we need to make it public to import it another clas. 
	
	private  : will be access with same class and package 
	protected   : 
	public  : can be access from anywhere 
	default : can access only with in clas
	
7. variables and data types  :

	a.  Premitive data type variable  : like : char , int , short , long , double . All these have different storage size.
			variables : Instance variable and Local variable
			- Instance variable : 
				Those variables which reside inside the class level. and is get initialized whenever the instance of that class is created,
			- Local variable : 
				Those variable declared inside the mthod os the class . those variables should be initialized or else the compiler will complaint.
				default value for int, byte , long , short =  0 , boolean is false ,  float , double  = 0.0 and for char = '\u0000' , this is the unicode value for char when you will sout the char using unicode it will print the char a , b, c, ....
				
	b.  Reference variable : Are the variable which are refrencesd to the heap memory .
			Person alex  = new Person();
			-----------
				|
				|
				|
			Reference variable .	

8. type casting  : Explicit casting from one data type to another .

9.Scope of variable : 				

	Static variable : It is accessible by all objects in a class and have a single copy of it across the class. This get loaded to the JVM when the program runs
	Instance variable : Which got initialized when the object or class gets instantiated. As it is on class level it can be accessed by all objects in the class
	Local variable : Is accessible only inside the method block .
	Block variabe : Whic is access only inside a block of code , like if  else block , for loop block etc . out side of these these are not accessible 
				Example: 
					if(x == false){
							boolean y = true 
							Sout(y); ------------------------ this will print the y
					}
					
					Sout(y) -------------- this will not print y and throws compile error.
					
10. variable modifier .

	Below access modifiers are used only for instance variables 
		- public : public/protected/default final in i =0 ; 
		- static : static final int i = 10; it wil have common copy for all objects and access to all.
		- transient : transient static int i = 10 ;  its used for variables not be included as part if the serialized string or value used for transmitting data to other system 
		- volatile : volatile int i =0 ; to make the variable thread safe .
		
	Below modifier is used only for local variables & instance variables. : 
		- final keyword : final int i = 10 . this is telling the compiler the final value for i is 10 and no one can chnge the value for i later . if you are writting instance variable with final keyword you have to initialize it or else compile issue will be ther e.
		
11. Operators in java : 

		Important point : always use equals in string comparisons 
		++ and -- : always try to use it in suffix like : ++x or --x , if  you want the value incremented assinged it to x immediatley 
			x++ and x-- will increament and decrement the valus but will be assigend to the variable on next set of code lines.
		
	- below loc will give same results  : 
		System.out.println(--x1);
        System.out.println(x1);
		
	- below loc will give diffe results : 
		System.out.println(x1--);
        System.out.println(x1);
		
	- conditional operators :  example 
		- z =  x==y ? z = 100 : z =109;
		- z = str1.equalsIgnoreCase(str2) ? 100 : 109;
		
	- you can either use & or &&  , | or || both will work in same manners

12. Wrapper classes : 	 In collections we use wrapper classes as we can not use primitive data types in collections to store data .
		ArrayList<int> alist = new ArrayList<int>(); // invalid
		ArrayList<Integer> alist = new ArrayList<Integer>(); // valid
		
		Where Integer is the wrapper class.
		These classes are ussed to wrap primitive data types value like : boolean , byte , char , int , long , short , double , float etc 
		
		primitive data types 				Wrapper class 
		boolean									Boolean
		byte									Byte 
		char									Character
		int										Integer
		long									Long
		short									Short
		double									Double
		float									Float

	Notes 	We can understand it like this : we can declared the wrapper class object as this Boolean b = new Boolean(false) ; ------> in this , the constructor is used to hold the primitive data value.
	
	****AUTOBOXING AND UNBOXING : 
		This is the cool feature of java in which if we want to convert the primitive data type value to wrapper class just directly write it like tihs :
		- Interger f = 100;   here the Integer is the wrapper class and 100 is an int value , java is converting it automaticaaly to wrapper which is now giving us the advantage to us all other functions that wrapper class provide.
		- normal way to wrap a primitive value in wrapper class  
			Byte b = new Byte(10);
			Float b = new Float(10f);
			Double b = new Double(10d);

13 . Q WHERE THE OBJECTS , METHOD , INSTANC VARIABLES , LOCAL VARIABLE RESIDES IN ?
				
		HEAP MEMORY (garbage collectable memory)-----								STACK MEMORY--------
        						
		Objects 																	Methods 
													
		instances variable 															Local variables 
			
		
			
	Objects reside in the heap memory which can be released when the garbage collector comes .
	instance variables are connected with Objects so it also stays on heap 
	
	Methods reside in stack just like a stack of books , execute the methods one by one and pos  out of the memory
	Local variables as usual declared inside mothods so it also stay on stack .
	
	
	While coding keep in mind how to utilize the memory 
	
14. Modifiers of Methods : 	
		public : access from all 
		protected : restrict the access in same package 
		private : can not acess.
		default : can call it from same class only 
		static  : no need to create an insance/objects of the class in which this method is to access it . It will beloing to class.
		final   : Can not override the method  in child class which inherit the base class that contain final method.
		abstract : it is used only to declare the method without body .
		synchronised : only one thread can access this mthod at a time . Oher threads will wait for the release.
		
15. lambda : 
		Now Let's convert regular incrementByOne method to Lambda expression step by step.
		
		This is original method,
		
		public int incrementByOne(int num) {
			return ++num;
		}
		Step 1: Remove Access Modifier, Return type and Method Name
		
		So expression will be like like this,
		
		(int num) {
			return ++num
		}
		Step 2: Add Lambda operator(->) between the parameters and method block,
		
		(int num) -> {
			return ++num
		}
		This is the modified version of incrementByOne using lambda expression. If you want to simplify further, parameter’s data type is optional, so Let's remove those
		
		So method will be looks like this now.
		
		(num) -> {
			return ++num
		}
		To simply further,
		
		If your method has only one line of statement, you can remove {}. And also, if code is not in block return keyword is not needed
		
		So method will be looks like this now.
		
		(num) -> ++num;
		
		
		Sample code for Lambda expression:
		
		interface NumExamples{
			public int incrementByOne(int num);
		}
		
		public class MyClass {
			public static void main(String[] args) {
			NumExamples result = ( num) -> ++num;
			}
		}
		Since we haven’t discussed interfaces yet, The above code might be hard to understand for you. For now, just understand the idea of the Lambda expression.
		
		Note: If you are comfortable with the earlier structure of method implementation, feel free strict with the same. This is just an advanced and simplified version of the method structure.

		
16. Switch statements are better then if else block , the execustion line of code is lsser and it is faster then if else .
 switch (a == 0 || a==-1 | a==-2 | a==-4 | a==-3 ? 0 : 10) {
            case (5):
                System.out.println("FIRST BLOCK WITH a = 5");
                break;
            case (1):
                System.out.println("SECOND BLOCK WITH a = 1");
                break;
            case (0):
                System.out.println("THIRD BLOCK WITH a = 0");
                break;
            default :
                System.out.println("DEFAULT BLOCK EXECUTED");
                break;
        }
 
17. lambda expression in java for loop to break use return statement in it .

18. Constructor : 
			- Constructor can not have return type and can not be statis 
			
			- It is used to initialize the class variable .
			
			- As we did in rest api to initialize the bean attributes to a values.
			
			- One amazing thing learned is in our pojo class or bean class we can add both the constructor parameterized and non parameterized
				Paramterized will help in initializing the attaribute variable by passing the value in constructor.
				Non-parameterized will help in initializing the variable by using the .(dot) opertaor 
			
			- this() function used in pojo class itself will caal the constructor of the same class and this one will call the non-parameterized one
			  this(1,"Meet","orlendo") this will call the 3 parameterized constructor in same pojo class.
			  this("meet",100999) this will call the 2 parameterized constructor in same pojo class.
			
			- super() function used in pojo class itself will call the constructor of the super class class and this one will call the non-parameterized one and if no super class is there then Object class constructor will be called 
			  super(1,"Meet","orlendo") this will call the 3 parameterized constructor in super pojo class.
			  super("meet",100999) this will call the 2 parameterized constructor in super pojo class.

	#IMP#  Single ton class : Can have only one object and can not be instantiated again .	

19. STATIC MEMBERS : static members can not call non-static members and vice - versa  . static is for class.

		Applied on below members of java : 
		
			1. static Instance variable : variables which are on class level can only be declared as static . public static int setavailable = 90;
				static variable are which will be common to all objects like 
					no of seta available is common to all tickets going to each pessenger . which will have an updated count . mean 90 is available for all .
			
			2. 	Static blocks : which will be run at the verry first step , sbse pehle run hogga 
			3. Static methods , will be called using the class name and not by creating a clas instance. Multiple static blocksare executed sequentially.
			
20. Inheritance : 			

	- Wecan use extends the super class 
	-  public class subclass extends superclass
		subclass object = new subclass();
		
		this will use the super class and base class members.
		
		superclass object = new subclass();
		this will again  use the super class and base class members.
		
		superclass object = new superclass;
		this will use the super class only.
	- We can also pass the subclass type object as a paramter to a function needing super class objects
		
		public static lesswalk (Human h){
		
			sout(name + " :   walks less");
			
		}
		
		psvm(){
			sportsperson a = new sportsperson();
			a.name = "keen";
			lesswalk(a); ---------------------------------------------------------> subclass refenrce means HUman super set hai and sportsperson is subset humans ka 
		
		}
	
	- ambiguous arises and java doesnot support multiple inheritance and extends for two super class , nope not possible.
	- if we use final keyword for a class make that class non extendable .
	
21. Interface : Are the abstract class which contains the abstract functions and promotes the abstraction features by not defining the method functions .

			we know human can be categories as Artists and musician , both have diffr eating style , walking , breathing level and eye colours .
			Thses differnet featres we can keep it as a template in interface and fill the template when Implemented in sub class.
			
			- variables are final and static 
			- functions ar abstract declared without body.
			- we can not make a instance for an interface 
				but we can create a references 
				
					GenericLivingCreatureInterface g = new Human(); --------------- possible
					Human h = new GenericLivingCreatureInterface();  --------------not possible 
			- we can multiple inheritance by multiple implements of interface 
			
			#IMP# : Imagine one interface is implemented in 1000 classes , adding a one more function in interface will break all 1000 classe 
				to overcome this we have default function in which we can add the function body in interface itself 
					
					default void check(){
						System.out.println("new function added");
					}
					
			- two interfaces have same fnction : how to call the functions then post implementation		
				
				code : Interfacename.super.functionname()
				
22. abstract classes : 
					- unlike interface , abstract classes can have functions with body . and withour body also .
					- even a one function in a class abstract then the clas is abstract
					- We extends these.
					
23. Encapsulation : - Hiding the back end functionality . Just like remote control , you can see the buttons to control .
					- Hiding can be done using the access modifiers .
					
					Steps to set the encapsulations : 
					- Private access modifier can be used to do that for all class instance variables.
					- then generate the getter and setter for them.
					- then go to places where we need the variable values using the getter and set the value usng setter.
					 setter : writting 
					 getter  : only readable 
					 
					------ in rest api or spring boot api , we don;t need to extends the bean class , we can import it and use it.

24. Polymorphism : 
				- One super class gots extends in two sub classes , overriding a functions of super class with two diff defination in two diff sub classes is polymorphism 
				- Runtime polymorphism: 
					overriding a mthod rule : 
							name same 
							arguments match 
							body differ.
							Access level should not be highly hidden like private . Keep public 
							We can not override a method marked as final 
				
				- Method overrloading   : 
						Rules : 
							Keep the name same 
							change the arguments list 
							change the return type 
							change the acess modifier 
					
25. String classes  : from java.lang.string 
				
				Keep this in mind
					- == operator if we apply on a reference objects it will tell if it is pointing to the same memory locations ?
					- equals operator will compare the string values . Always use equals/equalsIgnoreCase for string compare