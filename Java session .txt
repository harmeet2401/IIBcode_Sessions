Now, we can sort a list of Person objects based on their age simply by calling Collections.sort()
 class Person implements Comparable<Person> {
    private String name;
    private int age;
    
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    public String getName() {
        return name;
    }
    
    public int getAge() {
        return age;
    }
    
    @Override
    public int compareTo(Person otherPerson) {
        // Compare persons based on their age
        return Integer.compare(this.age, otherPerson.age);
    }
}
 Course ----------------------------------------
1. java is iteroperable or can be run on multiple platform using the JVM(java virtual machine) on the target system .
2. Platform independent : Java bytecode created by the java compiler .
	The byte code we can run it on the jvm in target system .
	
	
	
	
	java code ------------------------> compiler -----------> byte code --------------> translate the byte code to binary codes-----------------> Run on target system.
	
	C and c++ compiler doesnot create a byte code. It sirectly run the binary code post compilation 
	
	Because of the extra step in java of creating a byte code its some says its slower . But we can use JUST-IN-TIME-COMPILER .  whic at the same time converts the byte code to the binary code and machine language.
	
	JDK  -------Contains ---------------> Compiler & JRE  -------->Contains the JVM and class binaries  -------JVM -----> is the virtual env to run .class file
											|						required to run the program . 
																	No compiler is there
											|
											|
											|
								Its the source code compiler to compile the .java file to create the .class file.	
									  
3. JRE and JDk and JVM : 
	- JRE : Java run time environments.
		Its a software package that only contains the JVM and class liberaries which are required to run a java program . we can not compile the java program using a JRE.
		It provide just in run time env.
	- JDK : Java development kit : 
		Its a combination of JRE and Java compiler .
		Compiler will helps in compiling the new java code and JRE containg JVM will help in running the code by converting the byte code to binary language.
	

NOTE : IN NUT SHELL , IF WE NEED TO WRITE , COMPILE AND RUN THE CODE WE NEED JDK WHICH HAVE JRE AND COMPILER . IF WE WANT TO RUN A JAR FILE OR THE .CLASS FILE WE ONLY NEED JRE AS IT PROVIDES THE JVM FOR RUNNING THE CODE.

4. Class is the blueprint from which we can create the different objects .
	understand it like class is a generic page or higher classification . Like person : ----person is a blue print for two types of persons(girl or  a boy.)
	Class is Person 
	Object can be Person james = new Person()
	Object can be Person clark = new Person()
	Object can be Person mia = new Person()
	
5. Life of objects :  So we know that : Person a = new Person();

			Person a ----------> its like creating a reference object and a romote control ready to point to a  memory locations.
			
			new Person ---------> This will create a heap memory allocations .
				
				In order start making the ref remote cnotrol pointing to heap mem allocated we need to link these.
				
				Person a = new Person(); -------------> linking or start making the object a start pointing to JVM heap memory location 
				
			In my view creating multiple objects and heap memory with it will use more memory space of you system .
			Instead we can point the reference object to the same heap memory space . But that might end up bombarding the heap memory used by all instance objects 
			so we can create object by referencing it .
			Person a = new Person();
			Person b; ----------> only creating a refernce object but not allocating any heap memory
			b=a ------------------------- this will also point to the same heap memory locations as a object is doing 
			
6. Package name :  Collections of classes.

	Access modifier default is it is access with in the class only . 
	if we put that in different package we need to make it public to import it another clas. 
				
				With in Class 					IN Same package 			In subclasses			In Other packages 			
    public  	Allowed access					Allowed access				Allowed access			 Allowed access								
	protected   Allowed access					Allowed access				Allowed access 			 Denied access							
	default     Allowed access					Allowed access              Denied access            Denied access                                  		
	private   	Allowed access 					Denied Access 				Denied Access			 Denied Access 				
	
	
JAVA apis : application programming interfaces : which are the collections of packages of classes or programs writtern to be re-used . Like we used String , int and these classes are already wriiter in JDK know as the APIs
	
7. variables and data types  :

	a.  Primitive data type variable  : like : char , int , short , long , double . All these have different storage size. These are not user defined and can not be changed. These are built in datatypes.
			Variables : Instance variable and Local variable.
			- Instance variable : 
				Those variables which reside inside the class level. and is get initialized whenever the instance of that class is created.
			- Local variable : 
				Those variable declared inside the method of the class . those variables should be initialized or else the compiler will complaint.
				default value for int, byte , long , short =  0 , boolean is false ,  float , double  = 0.0 and for char = '\u0000' , this is the unicode value for char when you will sout the char using unicode it will print the char a , b, c, ....
			- Reference variable : Are the variable which are refrencesd to the heap memory .
				Person alex  = new Person();
				-----------
					|
					|
					|
				Reference variable .		
		
	b. Non-primitive data types are arrays , classes , string. These data types can be user defined means user can customize these data types to create new one.
		
	

8. type casting  : Explicit casting from one data type to another .

	String a = "";

8.1 Anonymous Inner class : In java annonymous ineer class is the no named class local inside another class which is used to implements an interface . These annonymous innner classes are declared inside another class and is not used anywhwre by referenec or instantiation.

Example 1 : Here we need to create one interface and then create an anonymous class for that interface without instantiating it and then calling it.

import java.util.Comparator;

interface Greeting{
    void greet();
}
public class anonymousInnerclass {
    public static void main(String[] args) {
        /**
         * This is used sort the objects in natural order using the defined values.
         */
        Comparable comparable = new Comparable() {
            @Override
            public int compareTo(Object o) {
                return 0;
            }
        };

        /**
         * This is used for sorting in order basis of comparing object using customized fields comparison.
         */
        Comparator comparator = new Comparator() {
            @Override
            public int compare(Object o, Object t1) {
                return 0;
            }
        };
        Greeting greeting = new Greeting() {
            @Override
            public void greet() {
                System.out.println("Hello from anonymous class");
            }
        };
        greeting.greet();
    }
}


Example 2 : For existing interfaces in java , Comparator , Comparable, Runnable etc
public class OuterClass {
    
    // Method with an anonymous inner class
    public void doSomething() {
        
        // Creating an anonymous inner class that implements the Runnable interface
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println("Inside the anonymous inner class");
            }
        };
        
        // Using the anonymous inner class
        Thread thread = new Thread(runnable);
        thread.start();
    }
    
    public static void main(String[] args) {
        OuterClass outer = new OuterClass();
        outer.doSomething();
    }
}


8.2	Immutable object  : Meaning of Immutability in Java In simple words, 
immutability means not modifiable. An object is considered as immutable if its state cannot change after its creation. Because they cannot change state after their creation so they cannot corrupt by the thread interference and are very useful in concurrent applications.

	All wrapper classes are immutable . wrapper classes like Byte , Character , String , Integer , Long , Double etc 
	String is also immutable and immutability means its state can not be changed by multiple threads all at the same time.In other words once an object of a 
String class is created in the java string pool it can not be changed. Means whenever a thread tried to update the value of state of the string object it will create a 
new string object without changing the existing string object .
So jab bhi ham string concatination and substring krte hai usme original string intact rehti hai 

	String a = "testing immutability"
	reference object is there n left hand side but the object will be saved in the java string pool which is a special heap memory.

9.Scope/Types of variable : 				

	Static variable : It is accessible by all objects in a class and have a single copy of it across the class. This get loaded to the JVM when the program runs
	Instance variable : Which got initialized when the object or class gets instantiated. As it is on class level it can be accessed by all objects in the class
	Local variable : Is accessible only inside the method block .
	Block variable : Which is access only inside a block of code , like if  else block , for loop block etc . out side of these are not accessible 
				Example: 
					if(x == false){
							boolean y = true 
							Sout(y); ------------------------ this will print the y
					}
					
					Sout(y) -------------- this will not print y and throws compile error.
					
	Reference variable : Are the variable which are refrencesd to the heap memory .
				Person alex  = new Person();
				-----------
					|
					|
					|
				Reference variable .					
					
10. variable modifier .

	Below access modifiers are used only for instance variables 
		- public : public/protected/default final in i =0 ; 
		- static : Fuor ways to use this 
			. variable : When a variabe is declared as static, a single copy of that variable will be shared among all the instances of the class. And will be initialised when the class is loaded in to the mem.
					or ek class mem mai tab load hotti hai jab uska object bnta ha .
			   Example : 
				Class Person{
						public static final int i = 10; it wil have common copy for all objects and access to all.
						public Person(){
								i++; // this static variable will get incremented when an object of the class will be created.

							}
						}
			. static Method : When a method is declared with static keyword then that method will be bound to the class defination at compile time and then can be called using the class name directly.
					oor static method can call only static memebrs only . like static variable hi use hogga or static method hi call kr skte ho 
					class Boy
					{
					    public static int i ; //it wil have common copy for all objects and access to all.
					    public Boy(int i){
					        this.i = i;
					    }
					    public static int getvalue(){
					        return i;  --------------------> i is static called from the static members. 
					    }
					}
					class Person {
					    public static void main(String[] args) {
					        System.out.println(Boy.getvalue());
					    }
					
					}	
			. static block : These are the block of code get executes way before the class is loaded into the memory.
					static {
						  System.out.println("hello from the static block");
						}

			. static nested classes : These are the nested static class which is under outer class used to access the outer class static members.
				package com.orielly.jpapersistence.jpamicroservice.entity;

						public class Vehicle {
						    public static int i = 10;
						    
						    public Vehicle(){
						        this.i = 100;
						    }
						    public static class FourWheeler{
						        public static void increaseValue(){
						            System.out.println(Vehicle.i);
						        }
						    }
						
						    public static void main(String[] args) {
						        Vehicle v = new Vehicle();
						        System.out.println(i);
						    }
						}




		- transient : transient static int i = 10 ;  its used for variables to be included as part of the serialized string or value used for transmitting data to other system 
		- volatile : volatile int i =0 ; to make the variable thread safe. This can be used in case of the multithreading process.
		- final keyword : 
			Three types of usages are there : It usually allow you to impose immutability to the members of the class.
			. Final variable  : If it is applied to a variable means that the value of that variable can not be changed after it got initialised.
				public final int i = 0;
			. Final Method : if the final keyword is used with the method then the method itself can not be overridden by the sub class extending it.
				public final int get(){ // this method couldn't get override by the subclass methods.
				} 
			. Final Class  : if the class is final it means the class will be forbidden to get extend  into the subclass. It means it will not allow it to be part of inheritance.
				public final class A{ // will not be allowed to be extended.

				}
		
11. Operators in java : 

		Important point : always use equals in string comparisons 
		++ and -- : always try to use it in suffix like : ++x or --x , if  you want the value incremented assinged it to x immediatley 
			x++ and x-- will increament and decrement the values but will be assigend to the variable on next set of code lines.
		
	- below loc will give same results  :  isme value pehle hi increment/decrement hojati hai  
	System.out.println(--x1);
        System.out.println(x1);
		
	- below loc will give diffe results : prefix mai value baad mai increment/decrement hotti hai . For loop ka example dekho 
			fo(int i = 0 ; i <10 ; i++){
				Sout(i);
				}
			pehle iteration mai value print hoggi 0 and then 1  , 2  , 3 .......

			fo(int i = 0 ; i <10 ; ++i){
				Sout(i);
				}
			pehle iteration mai value print hoggi 1 and then  , 2  , 3 .......
			
	System.out.println(x1--);
        System.out.println(x1);
		
	- conditional operators :  example 
		- z =  x==y ? z = 100 : z =109;
		- z = str1.equalsIgnoreCase(str2) ? 100 : 109;
		
	- you can either use & or &&  , | or || both will work in same manners

12. Wrapper classes :	

Wrapper classes in Java are classes that encapsulate primitive data types within an object. They provide a way to treat primitive data types as objects. The Java programming language provides a set of predefined wrapper classes for each primitive data type:

Byte: Represents a byte value (byte).
Short: Represents a short value (short).
Integer: Represents an integer value (int).
Long: Represents a long value (long).
Float: Represents a float value (float).
Double: Represents a double value (double).
Character: Represents a character value (char).
Boolean: Represents a boolean value (boolean).

In Java, wrapper classes are classes that allow primitive data types to be treated as objects. Java provides wrapper classes for each of the primitive data types, allowing them to be used in situations where an object is required instead of a primitive type. Wrapper classes also provide utility methods for converting between primitive types and strings, as well as for performing various operations on the values they wrap.
		In collections we use wrapper classes as we can not use primitive data types in collections to store data .
		ArrayList<int> alist = new ArrayList<int>(); // invalid
		ArrayList<Integer> alist = new ArrayList<Integer>(); // valid
		
		Wrapper classes allow primitive data types to be accessed as objects and objects as a primitive data types.
		The various wrapper classes for primitive data type are: Boolean, Byte, Character, Double, Float, Integer, Long and Short.
		Wrapper classes make the primitive type data to act as objects.

		Where Integer is the wrapper class.
		These classes are ussed to wrap primitive data types value like : boolean , byte , char , int , long , short , double , float etc 
		
		primitive data types 				Wrapper class 
		boolean									Boolean
		byte									Byte 
		char									Character
		int								   	Integer
		long									Long
		short									Short
		double									Double
		float									Float

	Notes 	We can understand it like this : we can declared the wrapper class object as this Boolean b = new Boolean(false) ; ------> in this , the constructor is used to hold the primitive data value.
	
	
****BOXING AND UNBOXING : 
The automatic adaptation of primitive data types into its corresponding Wrapper type is known as boxing, and reverse operation is known as unboxing.
	
**** AUTOBOXING AND AUTOUNBOXING : 
Autoboxing is the process by which a primitive type is automatically encapsulated (boxed) into its equivalent type wrappers whenever an object of the type is needed	
This is the cool feature of java in which if we want to convert the primitive data type value to wrapper class just directly write it like tihs :
- Interger f = 100;   here the Integer is the wrapper class and 100 is an int value , java is converting it automaticaaly to wrapper which is now giving us the advantage to us all other functions that wrapper class provide.
		- normal way to wrap a primitive value in wrapper class  
			Byte b = new Byte(10); ----------------------  this is called boxing converting from premitive data types to objects 
			Float b = new Float(10f); 
			Double b = new Double(10d);
			
public class Sample {
   public static void main (String args[]){
      Integer obj = new Integer("2526"); -------------- boxing 
      int i = obj.intValue(); --------- unboxing 
      System.out.println(i);
   }
}


public class Sample {
   public static void main (String args[]){
      Integer obj = 2526; -------------- Autoboxing 
      int i = obj --------- Autounboxing 
      System.out.println(i);
   }
}

13 . Q WHERE THE OBJECTS , METHOD , INSTANC VARIABLES , LOCAL VARIABLE RESIDES IN ?
				
		HEAP MEMORY (garbage collectable memory)-----								STACK MEMORY--------
        						
		Objects 												Methods 
													
		instances variable 											Local variables 
			
		
			
	Objects reside in the heap memory which can be released when the garbage collector comes .
	instance variables are connected with Objects so it also stays on heap 
	
	Methods reside in stack just like a stack of books , execute the methods one by one and pos  out of the memory
	Local variables as usual declared inside mothods so it also stay on stack .
	
	
	While coding keep in mind how to utilize the memory 
	
14. Modifiers of Methods : 	
		public : access from all 
		protected : can be acccess in Same class and in the samepackage by other classes. In sub classes (inherited one)
		private : can be access only in the same class.
		default : can be access in same class , in same package by the other classes.
		static  : no need to create an insance/objects of the class in which this method is to access it . It will beloing to class.
		final   : Can not override the method  in child class which inherit the base class that contain final method.
		abstract : it is used only to declare the method without body. As part of the abstract classes and in interfaces.
		synchronised : only one thread can access this method at a time . Oher threads will wait for the release.
		
15. lambda : 
Lambda expressions were introduced in Java 8 as a way to provide a concise syntax for writing anonymous functions, also known as "closures" or "function literals." Lambda expressions enable you to treat functionality as a method argument or create instances of functional interfaces more easily and concisely.
		Now Let's convert regular incrementByOne method to Lambda expression step by step.
		
		This is original method,
		
		public int incrementByOne(int num) {
			return ++num;
		}
		Step 1: Remove Access Modifier, Return type and Method Name
		
		So expression will be like like this,
		
		(int num) {
			return ++num
		}
		Step 2: Add Lambda operator(->) between the parameters and method block,
		
		(int num) -> {
			return ++num
		}
		'->' this is the lambda operator.
		This is the modified version of incrementByOne using lambda expression. If you want to simplify further, parameter’s data type is optional, so Let's remove those
		
		So method will be looks like this now.
		
		(num) -> {
			return ++num
		}
		To simply further,
		
		If your method has only one line of statement, you can remove {}. And also, if code is not in block return keyword is not needed
		
		So method will be looks like this now.
		
		(num) -> ++num;
		
		
		Sample code for Lambda expression:
		
		interface NumExamples{
			public int incrementByOne(int num);
		}
		
		public class MyClass {
			public static void main(String[] args) {
			NumExamples result = ( num) -> ++num;
			}
		}
		Since we haven’t discussed interfaces yet, The above code might be hard to understand for you. For now, just understand the idea of the Lambda expression.
		
		Note: If you are comfortable with the earlier structure of method implementation, feel free strict with the same. This is just an advanced and simplified version of the method structure.

		
16. Switch statements are better then if else block , the execustion line of code is lsser and it is faster then if else .
			switch (a == 0 || a==-1 | a==-2 | a==-4 | a==-3 ? 0 : 10) {
            case (5):
                System.out.println("FIRST BLOCK WITH a = 5");
                break;
            case (1):
                System.out.println("SECOND BLOCK WITH a = 1");
                break;
            case (0):
                System.out.println("THIRD BLOCK WITH a = 0");
                break;
            default :
                System.out.println("DEFAULT BLOCK EXECUTED");
                break;
        }
 
17. lambda expression in java for loop to break use return statement in it .

18. Constructor : 
					
			- A constructor can not have a return type , but can declared and defined with multiple input paamateres.
			
			- It is used to initialize the class variable .
			
			- As we did in rest api to initialize the bean attributes to a values.
			
			- One amazing thing learned is in our pojo class or bean class we can add both the constructor parameterized and non parameterized
				Paramterized will help in initializing the attaribute variable by passing the value in constructor.
				Non-parameterized will help in initializing the variable by using the .(dot) opertaor by creating the object of the class.
			
			- this() function used in pojo class itself will call the constructor of the same class and this one will call the non-parameterized one
			  this(1,"Meet","orlendo") this will call the 3 parameterized constructor in same pojo class.
			  this("meet",100999) this will call the 2 parameterized constructor in same pojo class.
			
			- super() function used in pojo class itself will call the constructor of the super class class and this one will call the non-parameterized one and if no super class is there then Object class constructor will be called 
			  super(1,"Meet","orlendo") this will call the 3 parameterized constructor in super pojo class.
			  super("meet",100999) this will call the 2 parameterized constructor in super pojo class.
			  "this" keyword onlone if you do this(dot) then it will show you all the instance members(class variable and methods) of the class.

	#IMP# : whenever you write a constructor in your class , compiler adds the super()function in starting point of it automaticaaly which will call the constructor of java.lang.object class if no class is extended.
	#IMP#  Single ton class : Can have only one object and can not be instantiated again .	

19. STATIC MEMBERS : static members can not call non-static members and vice - versa  . static is for class.

		Applied on below members of java : 
		
			1. static Instance variable : variables which are on class level can only be declared as static . public static int setavailable = 90;
				static variable are which will be common to all objects like 
					no of seats available is common to all tickets going to each pessenger . which will have an updated count . mean 90 is available for all .
			
			2. Static blocks : which will be run at the verry first step , sbse pehle run hogga 
			3. Static methods , will be called using the class name and not by creating a clas instance. Multiple static blocks are executed sequentially.
			4. Static innert nested class : which is used to call and access the static member of outer class.
			Important  : STATIc MEMBERS CAN BE CALLED BY THE STATIC MEMBER ONLY (MEMBSR CAN BE ANYTHING , CLASS , FUNCTION , VARIABLE ETC )
20. Inheritance : 			

	- Wecan use extends the super class 
	-  public class subclass extends superclass
		subclass object = new subclass();
		
		this will use the super class and base class members.
		
		superclass object = new subclass();
		this will again  use the super class and base class members.
		
		superclass object = new superclass;
		this will use the super class only.
	- We can also pass the subclass type object as a paramter to a function needing super class objects
		
		public static lesswalk (Human h){
		
			sout(name + " :   walks less");
			
		}
		
		psvm(){
			sportsperson a = new sportsperson();
			a.name = "keen";
			lesswalk(a); ---------------------------------------------------------> subclass refenrce means HUman super set hai and sportsperson is subset humans ka 
		
		}
	
	- ambiguous arises and java doesnot support multiple inheritance and extends for two super class , nope not possible.
	- if we use final keyword for a class make that class non extendable .
	
21. Interface : Are the abstract class which contains the abstract functions and promotes the abstraction features by not defining the method defination .

			we know human can be categories as Artists and musician , both have diffr eating style , walking , breathing level and eye colours .
			Thses differnet featres we can keep it as a template in interface and fill the template when Implemented in sub class.
			
			- variables are final and static 
			- We can not instantiate the interface and can not create objects of it.
			- functions are abstract declared without body. but no need to type the abstract keyword for thefunctions.
			- we can not make a instance for an interface 
				but we can create a references 
					If Human class is implementing the interface(GenericLivingCreatureInterface) and giving the defination to its functions then below can be possible
					GenericLivingCreatureInterface g = new Human(); --------------- possible , IF Human is a super class.
					Human h = new GenericLivingCreatureInterface();  --------------not possible 
				Another example ot it is 
						List<Integer> list = new ArrayList<>(); in which ArrayList is implementing the List interface and to instantiate the List we have to give reference to its
						implementation.
			- we can multiple inheritance by multiple implements of interface 
			
			#IMP# : Imagine one interface is implemented in 1000 classes , adding a one more function in interface will break all 1000 classe 
				to overcome this we have default function in which we can add the function body in interface itself 
					
					default void check(){
						System.out.println("new function added");
					}
					
			- two interfaces have same fnction : how to call the functions then post implementation		
				
				code : Interfacename.super.functionname()

22. abstract classes : 
					- unlike interface , abstract classes can have functions with body . and without body also .
					- even a one function in a class abstract then the clas is abstract
					- We extends these.
					
23. Encapsulation : - Hiding the back end functionality . Just like remote control , you can see the buttons to control .
					- Hiding can be done using the access modifiers .
					
					Steps to set the encapsulations : 
					- Private access modifier can be used to do that for all class instance variables.
					- then generate the getter and setter for them.
					- then go to places where we need the variable values using the getter and set the value usng setter.
					 setter : writting 
					 getter  : only readable 
					 
					------ in rest api or spring boot api , we don;t need to extends the bean class , we can import it and use it.

24. Polymorphism : 
				- One super(base) class gots extends in two sub classes , overriding a functions of super class with two diff defination in two diff sub classes is polymorphism 
				- Runtime polymorphism: 
					   overriding a mthod rule : 
							name same 
							arguments match 
							body differ.
							Access level should not be highly hidden like private . Keep public 
							We can not override a method marked as final 
				
				- Compile time Method overrloading  :
						Rules :
							Keep the name same 
							change the arguments list 
							change the return type 
							change the acess modifier 
					
25. String classes  : from java.lang.string
				
				Keep this in mind
					- == operator if we apply on a reference objects it will tell if it is pointing to the same memory locations ?
					- equals functions will compare the string values . Always use equals/equalsIgnoreCase for string compare.
					- String objects are immutable means we can change the value but need to CHANGE THE REFERENCE VALUE.
						String str1 = "test ";
						str1 =str1.concat("jaav");      or str1.concat("java") will not update the value if str1 , hme dubara se iski value str1 ko assign krni pdti hai 
						sout(testjaav)

VVVVVVVVIMP : In Java, the string constant pool is a special area in the Java heap memory where String literals are stored. When you create a String using a string literal (e.g., "hello"), Java checks the string constant pool to see if an equivalent string already exists. If it does, Java returns a reference to the existing string rather than creating a new one. This process is called STRING INTERNING.

Here's how the string constant pool works:

- String Interning: When you create a string using a string literal, Java checks if the string already exists in the string constant pool.
- Reuse of Existing Strings: If an equivalent string is found, Java returns a reference to that string. This helps in conserving memory by avoiding duplicate string objects.
- Creation of New Strings: If the string does not exist in the string constant pool, Java creates a new string object and adds it to the pool for future reference.
- Immutable Strings: Strings in the string constant pool are immutable, meaning their values cannot be changed after they are created. This ensures thread safety and prevents unintended modification of shared strings.

						
26. Stringbuilder and Stringbuffer 	:  Strongest tool or classes to create string and can concatenate any data types value 
		stringBuilder.append("@@"); ----------------- the parameter can be int , float , double , short , string .
			
		These are not immutable classes , we can do as many chanes as we can.
		Its thread safe. It means only one thread can access the object one at a time . Will released by one thread and picked by other thread.
		
		  StringBuffer strb = new StringBuffer("Welcome to java ");
          strb.append("(("); ------------------------------------------------------------ this shows StringBuffer and StringBuilders are mutable as strb.append("java") 
can change the strb value. no need to assign it back to strb
          System.out.println(strb);

          StringBuilder stringBuilder = new StringBuilder("Welcome to java ");
          stringBuilder.append("@@");
          System.out.println(stringBuilder);

. Both StringBuilder and StringBuffer are classes in Java used to create mutable (modifiable) sequences of characters. They are similar in functionality, but there are 
  some differences between them, primarily related to their performance characteristics and thread safety:

. Mutability:
	Both StringBuilder and StringBuffer are mutable, meaning you can modify the contents of the sequence of characters they represent.
. Thread Safety:
	StringBuilder is not thread-safe, meaning it's not synchronized and should not be used in multithreaded environments where multiple threads may access or modify 	it concurrently.
	StringBuffer is thread-safe, meaning it's synchronized and can be safely accessed and modified by multiple threads concurrently without causing data corruption 	or inconsistency.
. Performance:
	StringBuilder is faster and more efficient than StringBuffer in single-threaded environments because it's not burdened by the overhead of synchronization.
	StringBuffer, being synchronized, incurs some performance overhead due to the cost of acquiring and releasing locks to ensure thread safety. Therefore, it may 		be slower than StringBuilder.
. Synchronization:
	StringBuilder methods are not synchronized, so they are not suitable for use in scenarios where thread safety is required.
	StringBuffer methods are synchronized, ensuring that they can be safely accessed and modified by multiple threads concurrently. This makes StringBuffer suitable 	for use in multithreaded environments where thread safety is a concern.

Example of difference between the memory utilized by the string with direct values assigned and using the new keyword 
String ar1 = "Harmeet";           // Stored in the string constant pool
String ar2 = new String("Harmeet"); // Stored in the heap memory

27. Exception handling : 

	Exception are sudden error occured in our program which may be a result of a file not found exception or stackoverflow exceptio , array index ot of bound exception etc 
	
	Types of exception : 
	  - checked exception : These are the exception which comes during compilation . The java compiler throws these exception during the compile time and does not allow a clean compile and will not create a .class(byte code) file for it.
	  - Unchecked Exceptions : Runtime exception. These exception comes at runtime due to unwanted code bug etc . in this case the .class  has already been generated but will break while running the code in JVM.
	  
	The order or hierarchy of thr exception really matters :
		Objects 
			|
		Exception
			|
	ioex  , clssnotfoundex , .... runtime exception 
										|
									Arithmetic exception , numberformt exception , null pointerexceptio  ....... more 
									
	so we have to add multipe catch block by checking our code .
		Exception class is capable of catching all exceptions .
		
								
      - Finally block : 	
				This block always run . this block comes at the end of the catch or try block . We mostly used this block to close all the open inputstream , db connections , flush the buffer etc . This will help in reducing the memory leak due to db connection s, network leak etc .
				
	  - propagating the unhandled exceptions  : means the exception occured upstream or backword if not catched , similar to what we do in IIB .
		
	  - Throw and throws : 
			Throw key word we can use to throw an exception like throw new NumberFormatException("Messge for it") or the customised exception to the consumer
			Throws we can use to throw multiple exceptions from downstream method to upstream .
			
	  - Custom exception or user define : 
													 - create a class and								
													 - extends Exception class and write a constructor and pass the message attribite to super(message)
													 - use throw new MyExceptionClass("your message")
		Which exception is thrown when java is out of memory?
a) MemoryError
b) OutOfMemoryError
c) MemoryOutOfBoundsException
d) MemoryFullException

B : correct 											 
													 
28. Collections :  it can hold collections of objects 
					commaon function s: 
						sort ()
						remove()
						purge()
						add() etc 
		List : it will store the list of objects , arrayList ,  are extended implementation of list.
		Set : to store the unique values . Hashset is the extendable of set 
		Map : Key and value pair.  when we need object from list or collections we have to iterate the collections , but map we can just push the key and we can get the value out. quick and faster then collections  , hashmap  is the extendable of map .
		Queues : FIFO flavour. linkedList is extendable
		
	1. Before using a collections always thing about : 
			You need : 
				- sorted or unsorted 
				- ordered or unordered 
				- unique or duplicate value 
				
		- Collection is an ordered data set .
		- sorting order is used to sort the data . we can use Collections.sort()
			: But how to sort the collection if it contains the bean objects collections 
				ArrayList<Person> arraylist = new ArrayList<Person>();
					We have to tell the Collections how to sort  verrrrrrryyyyyyyyyyyyyyyyyyeasy 
			: go to your pojo class implements the Comparable<Person> and override the compareTo method 
					  @Override
					  public int compareTo(Person o) {

							return name.compareTo(o.name);
							}
	Important : ---------								

		a. Arrayalist : collection of objects and kind of works as a array but is dynamic and can increase size without declaring it in pre-requisite. Its index based insertions.
		
		b. LinkedList : Works in node structure .
						Single linkedlist : data|pointer(addressof next node)  ---------------> data|pointer(addressof next node)
						Double linkedlist : pointer(addressof previous node)|data|pointer(addressof next node)  ---------------> pointer(addressof previous node)|data|pointer(addressof next node).Its index based insertions.
						Faster then arraylist to delete and add the elements in list . we can use addfirst and addlist
						
		c. Vector : It is similar then arraylist , slower then array list and is thread safe means only one thread can access it one at a time.
			its synchronised and increase the size of the array to 100% if one more elements is added. Its index based insertions.
		d. Hashmap : its a key value pair data structure . its not index based insertion data str. Its faster then any other data strc we discusse .
		For large amount of data hashmap is used as look up of elements at different index is pretty easy , just pass the key and ollllaaaa we got it.
						
			Verry verry important : 
					How hashmap works internally  : 
					
				- hashmap works on the process called hashing .
				- hashing involves a hashcode function which generate the hashcode using the key we give while putting and that hashcode is the index value in the Hashmap bucket array that resides in memory .
				- Each array index of hashmap bucket contains a linkedList which holds the elements [key,value]|addresstonextnode 
				- When we do map.put("IN",indiabj);
				
				hashing will pick the IN key and push it to hashfunction and generate the hashcode (hashmap bucket array index) and stores the [key,value] at that index.
			
		Case 1 : inserting the data 
				example for IN ------> hashfunction() -----hashcode generated ----> 2
				
																													
							map.put("IN",indiaobj)								map.put("US",usobje)																
								|													|								
								|													|								
								IN													US																				
								|													|								
		hash fucntion () -- returns 2      									hashfunc() ---> returns 2
							
							
										
												map.put("GM",gmobje)
													|				
													|				
													GM				
													|				
											hashfunc() ---> returns 0
										
										
										
										
										
								Hasmap Bucket
							 ---------------------------------------------------	
							|Array							 					|					
							| 0 -->[GM,gmobje]|pointer
							| 1                              					|	
							| 2 -->[IN,indiaobj]|pointer--->[US,usobje]|pointer |	
							| 3	                             					|	
							| 4                              					|	
							| 5                              					|	
                            | 6                              					|	
							| 7                              					|	                                                                            
							| 8                              					|	                                                                            
							| 9                              					|	                                                                            
							| 10                             					|																				
							|		                         					|																					
							 ---------------------------------------------------																							
		Case 2 : Getting the data 																											
		
											map.get("GM")
													|				
													|				
													GM				
													|				
											hashfunc() ---> returns 0
											
											
		Issuse in hasmap : in java 7 the linked list on a single hashmap bucket index contains multiple elements . not when larger elements use Get function and if multiple get creates a hashvalue to same index there will be collision issue . 
				1. So as a solution : Java 8 hash elements use balanced trees instead of linked lists after a certain threshold is reached. Which means HashMap starts with storing Entry objects in a linked list but after the number of items in a hash becomes larger than a certain threshold. The hash will change from using a linked list to a balanced tree.
				2. The alternative String hash function added in Java 7 has been removed.
		
		
		
				It goes to the bucket at 0 index and using the equals functions will search the GM and retrun the value back.
																													
        Case 3  : what happen in case of th Person objects or pojo object saving then we can either add the hashcode fnction to override and equals method to override . But by default all classes extends the functiosn fro objects class.																														
						
		e. Hashset : https://javaconceptoftheday.com/how-hashset-works-internally-in-java/
		It will remove the duplicate elements and it is not index based data strucure . We know it will remove the duplicate in case of string objects , but how it will find duplicate in case of POJO java objects as a primitive passed in it 
			for exaple : Hashset<Person> newper = new Hashset<Person>();
				Q. Here we used person and want to remove the duplicacy how ?
				Ans. As  a dev first we have to find which attribute of person makes it duplicate . Same what we observed in Rule coding 
					for example we can use Id and name both to be part of duplicate check. 
					We have to override the equal and hashcode method of Object class which Person class extends by default . the default equals method says all person objects are Different .
					exmaple :  below two objects are different , if we do per1==per2 it will be false as it is point to a different memory space .
						Person per1 = new Person("beet","88277",9129);
						Person per2 = new Person("beet","88277",9129);
					
				IMP : Generate the hashcode and equals and  generating the hashcode and equals we could able to see the duplicate removed.

		VERYIMPORTANT : Whenever you insert an element into HashSet using add() method, it actually creates an entry in the internally backing HashMap object with element you have specified as it’s key and constant called “PRESENT” as it’s value. This “PRESENT” is defined in the HashSet class as below.
			Object PRESENT = new Object();																								
		f. Linkedhashset : 	Aswe saw the elements entered in hashset while retrieving it the elements are in different order.
			To remove that use Linkedhashset and ollla ||||.
		
		g.Treeset : We know we can use the Collections.sort to sort the collections , but when you push the data to treeSet it will automatically sort the data in ASCENDING ORDER and also removes the duplicates	 . this is one of best data structure for ascending ordered sorted and unique value holding technique.
		
		h. hashtable : are synchronised as hashmap is synchronised.
			It will not allow null for a key .hashtable.put(null,"kk"); /// null pointer exception will be thrown
		
		I. LinkedHashMap : The only difference is that it will maintain the order . and slower then hashmap.
		
		j. TreeMap : Its sorted , means sort acc to natural method. Similar to hashmap , but is sorted .Treemap it will sort the coll will not allow null on key
		
		K. queue collection :  Root interface and used by linkedList and Priorityqueue. dqueue to remove and add to insert .
		
		L. Priorityqueue : wil insert the data in sorted order .
		
29. Thread : Multithreading and multipe processing .

				Steps to create multi threaded env : 
					1. create  a class whih extends the Thread class  or implements the Runnable interface 
					2. Override the run method and implement the job .Run method can be invoked by crating object of the Thread class.

30. synchronised block and methods : This will help in multi threading architecture which will allow only one thread to  hold the method , variable or resource at a time .

			public synchronised void run(){   -----------> this will lock the method complete for on thread to complete 
			
			
			}
			
			synchronised(){ -------------------- this will allow use to lock a piece of code to get locked for one thread to complete and let go post that.
			}
			
			sleep()
			
			setPriority() --- to cheange the priority of thread Min_pri(1) , normal_pri(5) , max_pri (10)
			
			isAlive()----> to get if the thread is still alive 
			
			wait()-------->  this will make the thread to wait , but will not come alive untill we use notify method for it.
			
			yield ()-----> will give other thread the chance to run if other thread is taking more time
			
		- states of threads : 
				
				new ----->Runnablbe ------>Running ----------->Dead
							/\				|
							|				|
							|				\/
							|---Waiting/-----
									block 
									
31. Serialization : As we used this to convert the data to bytes to send across the network .
										As we used in kafka stream .
										
				We can serialized and deserialized at the target system .

			Remember when we serialized the data into byte stream in kafka produce stream and deserialize the data to readable in target ss
			
			Steps to do serialization : 
					- Create a class pojo class and implements it with Serializable .
					- In PSVM Create a fileoutputstream and filename in ti 
					- then create ObjectOutputStream object and pass the fileoutputstream obj
				    - ObjectOutputStream.writeObject(pojo);
					
			steps to do the deserialization : 
			- Create a class pojo class and implements it with Serializable .
					- In PSVM Create a fileintputstream and filename in ti 
					- then create ObjectinputStream object and pass the fileintputstream obj
				    - polo = ObjectOutputStream.readObjects();
					

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Java 8 session : ------------------------------------------------- 

Question : major changes took place while migrating from  java 7 to java 8 

1. lambda expression  : Allow more readability and compact code . reduces number of lines of codes and reusablity of the code. Assigning a block of code to an object variable 
2.  Java Optional Class : To hanlde the null point exception at runtime .
	Optional<String> op = Optional.of("Testing")
3. New Date and Time API : Localdate , LocalTime , LocalDateTime
4. Unsigned Integer Arithmetic
5. Stream API : used to create stresm of data and reduces the number of line of codes. increeased efficiency of program .
6. Parallel Sorting.
7. Hashmap hashset fn is removed and hashmap bucket linked list is replaced by a balanced tree after a threashhold.

** IMP : BUILD YOUR KNOWLEDGE ON THEFUNCTIONS INTRODUCED IN JAVA 8 AND USE THEM AS NEEDED.

1. couple of features were added to java 8 : 
				a. lambda functions : functional programming 
				b. Immutability is added. which means will remove the error of getting the objects changed. Take String for exmaple which is part of the string pool buffer and 
				doesn't allow other to access or change it at the same point of time. Which provides thread safe functionality.
				And in java 8 using streams api we can apply changes to the new objects rather then the existing Collections.
				c. Streams  : which include kafka streaming and all
				d. optional etc 
	
2. Imperitive and declarative programming 
	Imperitive proramming : Focus on what we need to achieve and keeping that in mind we code for it.
							Object mutability is involved in this type of programming
							This is th eold approach as we were doing since the java existence 
							Here we need to focus on how the job is happening example : removing the duplicacy , summing up the value etc 
							
	(Java 8)Declarative proramming : Doesn't focus on what we need to achieve and keeping that in mind we code for it.
							 Object imutability is involved in this type of programming.
							 This is actually what it specifically points to java 8 programming.
							 Java 8 release lot of functions which do the jobs as part of the streams introduced.
							 Here we no need to worry about how the job is happening .
							 See the SQL as an example of imperitive approach in which how the data is getting retrived wedon't know we just run the query and get the data .
							
		Example : We can use stream in wide range and go further to use functions 

			like : list.stream().distinct().collects(Collections.toList());
				   Intstream.rangeClosed(0,100).sum() ----> rangeClosed() is just ike we give range in loop , these functions will do the iterationa and all in the back .
				   
3. Lambda 
Its an annonymous functions 
Important point : Lambdafunctions are moslty used to provide defiintions to the functional interface(Single abstract method interfaces SAM) (interfaces which contains only exact one abstract fuction ) and then using the interface object to call the overriden fucntion to use that.
syntax : ()					-> 					{}       
		 fn pramater 	   lambda operator     fn body 
These are equivalent to the functions without function name
These are the anonymus funtions 
These expressions have all three features that a normal functions has 
	Method name
	Method body 
	Method Return type 
	
Some of the existing funtional interfaces available prior to java 8 (java 8 se pehle ) Runnable(which is for multi threading ) and Comparator(compare two parameter of any types) interfaces which are anotated with @FunctionalInterface
				
Q. What is a runnable interface ?
This is the interface which we implements in a class to allow multithreading to work .
Run method is declared in this interface with no body , no paramters and no return  types .
Java runnable is an interface used to execute code on a concurrent thread. It is an interface which is implemented by any class if we want that the instances of that class should be executed by a thread.

The lambda expresion target should be an interface.

Runnable interface is also a functional interface which helps in executing multi-threaded programs . So in jave 8 we use lambda expression to invoke the run mehod inside Runnable interface

examepl  : before java 8  ;
			- Runnable runnable = new Runnable(){
					
					 @Override
					public void run() {
						System.out.println("----Runnable interface run");
					}
			}
			new.Thread(runnable).start ();
			
			- After java 8 using lambda expressions.
			
			Runnable runnable2 = () -> {System.out.println("----Runnable interface run");}
			new.Thread(runnable2).start();
			
			So upr () ye brackets show the input parameter to run function of Runnable functional interface.
			-> this shows the lambda operator.
			{  sout  } this shows the body of the run method.
			
Q. what is a comparator Interface ?
Comparator interface are the functional interface which has only one abstract function and is annotated as @FunctionalInterfaces. It contains a compare function which is used to compare any type of field values .
 
 
		// Compare function using the lambda function
        Comparator<Integer> comparator1  = (Integer a,Integer b)->{
            return a.compareTo(b);
        };
        System.out.println("The value of compare using lambda approach1 :"+ comparator1.compare(3,4));

        /**
         * Below comparator expression shows that if we remove the curly braces then no need to ad the return statements
         */
        Comparator<Integer> comparator2  = (a,b)->   a.compareTo(b);

QQQ. Functional interfaces :  part of java.util.function part of rt.jar

Functional interfaces as a defination is an interface , annotated as @FuntionalInterface and can have only once abstract method .
In order to create your own functional interface we just need to 	
		1. create an interface 
		2. Annotate it with the @FunctionalInterface
		3. Add one astract method to the interface 
		4. This interface can have many default and static methods defined in this interface 
		
		Note : we already know the concept of default function added to the interface . Agar we add one more function to the interfac then all classes in all package have to implement the function and define it. to overcome that they introduced the concep t of default method which is a method with access modifier default with definition added to the interface to be used by all classes implementing the interface.


Four initial functional interfaces are 
	Consumer 
	predicate 
	Function 
	Supplier.
	
1. Consumer Functional interface : java.util.function	
		Interface name : Consumer 
Consumer chain in foreach we can add one conaumr object and then do (dot) and get addThen() .

 We need to create a program with one student bean , one class that instantiate the student beans and then we will you another class which will use lambda expression to call consumer and apply flter and other stuff.
 
 Consumer chain is th etechnique in which we can add more consumer objects in line line c1.addThen(c2) where c1 and c2 are the cosumer objects abd this approach is called consumer chain.

2. BIconsumer functional interface : Just like the consumer accept method want one paramter , the Biconsumer accept two paramters so that two objects can be used to do the task .

interface name : Biconsumer 				


3. Predicate functional interface : It mostly contains the functions which play arround the boolean values and results . 
	Function like : or , and , negate . test is the fn which accepts the paramter which is similar to accept function in consumer interfaces.
	interface name : Predicate  	

code reusablity is the best benefit that is provided by the functional interfaces.

4. BiPredicate interface : 
	Interface name : Bipredicate  : similar to predicate and the only diff is the test function will receive two paramters and return type is same as boolean.
	contains  : or , and , nagate .
	This interface test function will help is adding multiple conditions required for the conditional logic to work .
	For example if we have two separate conditon which were handled using two predicates , then we can clud these two predicate into single bipredicate object to code a condition.
	
	
NOTE : WE CAN DEFINE THE CONSUMER, BICONSUMER , PREDICATE , BIPREDICATE IN A COMMON CLASS AND LET THESE CONDITIONS TO BE USED ALL THROUGH THE PROJECTS .
THIS CLASS WILL BE LIKE A COMMAND UTILITY OF FUNCTIONS , CONDITIONS , SWITHCES ETC 	
QQQ Function - 

1. Function Interface - part 1 : its a functional interface just like (consumer , predicate , Biconsumer ,and bipredicate) but with diff features.

	. Interface name : Function.java 	 , functions available in this interface : addThen , compose and apply (input , output)
	. Its take an input and returns an output.
	. its like creating the implementation for each Function interface object and then use apply method to run it. Its like writing a function assigning it to a variable to be used anywhere   AWESOMEEEEEEEEEEEEEEEEEEEEEEEEEEEE
	
		//just going to perfomr uppercase
        System.out.println(function.apply("Harmeet Singh"));

        // will first apply the uppercase and then send it for concat
        System.out.println(function.andThen(addthenobj).apply("harmeet Singh"));

        // compose will execute the second function implementation of concat first and the go for the uppercase
        System.out.println(function.compose(addthenobj).apply("harmeet Singh"));

2. Bifuntional functional interface : Its just like the Function functional interface , the only difference is it takes two input parameter instead of one.
	interface name  : BiFunction  and it only have apply and addThen method .
	
NOte : --- operators function intefaces are used in case both the input and out are of same types 	

3. UnaryOpertor functional interface : this is the functional interface which extends Function functional interface is used if the input and out both are of same data type .
		
4. Binaryoperator functional interface : this is the functional operator which extends the BiFunction functional interface is used to take two input of same type and generate a output of same type

5. Supplier functional interface 
	interface name : Supplier 
	It is used to return something and it doesn't required any paramters .
	The syntax for lambda would be (no input params)->{}

Note : In Java, the diamond operator <> is used with generics to denote TYPE INFERENEC. It was introduced in Java 7 as part of the Project Coin enhancements.

QQQ  : Method references	

	1. Method references are just a shortcut way to write lambda expressions 
		
	
	syntax   : ClassName::Methodname
			ClassInstance::Methodname
			
			
			example : 
					- Function<String , String > function = (s)->s.toUpperCaseString(); --------------> this is lambda expression 
					when we right lambda expresion in place of method reference we give defination to the abstart method of th Function funtional interface
					
					
					- Functions<String , String > functions = String::toUpperCaseString(); -------------> method reference
					means we are telling compiler to refer the defination of the method on the right hand side to give implementation to the abstract method of Function functional interface
					
					
					For below example the getstudents_first is the public static function with Student object as a parameter.
					static public Function<Students,List<Students>> function1 = StudentsService::getStudents_first;
					
					
				There are some cases it is difficult to apply method reference .	   
	2. So in nutshell in JAVA8 we can use classname/object::method references and get the work done 
	
	if we have create a Class test and it has a method with input paramters or not . 
	
					We can use functional interface and then use th class Test::methodrefrences.
					
					But kepe in mind the functional interface that you will use either it is a Consumer , BiConsumer , Predicate , BiPredicate , Function , BiFunctional , UnaryOpertor , Binaryoperator or a supplier . The right hand side function that you are refering must have same method decalaration .
					
					Means we know that if we use Function functional interface then you might be sending input paramters .
	

QQQ. Constructor reference : 
static Supplier<Students> supplier = Students::new; // allow it to create an empty constructor

static Function<String,Students> function_cons_ref = Students::new;

the right hand side syntax will help in referencing the construcotr of the class with String as a input paramter.


QQQ. Local variables and its scope in labmda expressions.

 two restrictions are there : 
		inside lambda expression we can use the local variable 
		We can not reset the value of a local vaoriable to a new value 
		We can use the instance variable where ever we can .
		
QQQ. Effectively final : It means we saw that the when we tried to change the value of a local variable inside the labmda expression we get compilation . This concept shows that the lambda expression treat local variable as effectively FINAL (whose value can not be changed.)		

	fn(){
	
	int value = 9
	Consumer<integer> c = (u) ->{
		value = 8; // this line will shows compilation error as lambda treat local variables as final .
		
	}
	}
	
QQQ. Stream Api 
	Streams api is used over the List , or collection of data , which can be Map , List , ArrayList , LinkedList , treeset and all other collections .
	There are two stream  to create using below.
		students.stream()
		students.parallelStream() -----------> this will run all the other task like filter , collects etc in parallel.
	Stream is nothing but a streamlined data of a collection on which we can do all the manipulations.	
	Streams are lazy , no operation will be perfrmed untill the terminal operation is triggered.

	STREAM KA MATLAB HAI SEQUENCE OF VALUES or ELEMENTS  THAT CAN BE ANY THING 
	LIKE SO below are the example of the streams . Index nhi hotta but meri explaination ke liye : 
	[1,2,3,4,5,5]   Stream.1 = 1 , Stream.2 = 2 etc for first stream.
	
	[String1,String2,String3,String4,String5,String6] Stream.1 = String1 , Stream.2 = String2 etc for second stream.
	
	[List<Integer>1,List<Integer>2,List<Integer>3,List<Integer>4] Stream.1 = List<Integer>1 , Stream.2 = List<Integer>2 etc for first stream.
	
	1.How stream API works?
	
	Example : 
	StudentInstace.getstudents().stream() ------------------------------------> will create Stream<Students>
					.filter(p) ------------------------------------> will create Stream<Students> filtered
					.filter(p1)------------------------------------> will create Stream<Students> filtered
					.collect(Collectors.toMap(Students::getName,Students::getActivities));------------------------------------> will create Map<string , List<Activities>>
					
							Stream of Students 
				|Student |Student |Student |Student |Student |Student |		 ------- Stream()
				
				|Student |Student |Student |Student |Student |		 ------- filter()
				
				     |Student |Student |Student |	 ------- filter()
					 
					 
		Stream is nothing but a sequence of values or elements okay ! it doesn't hold data. And can be processed only once.
		
Q. Functions of Collectors interface and Comparator interface passed as a paramter to the collect() terminal fn of stream api ?
Ans : list.stream().collect( ? )
Collector.toSet()
Collector.toMap(key,value)
Collector.toList()

---------------All these functions need one parameter like Student::getNoteBooks which is an integer. Compile issue if no input -----------------------------
Collector.summingInt()
Collector.averageint()
Collector.averageDouble()
Collector.summingDouble()
----------------All these functions need one parameter like Student::getNoteBooks which is an integer. Compile issue if no input -----------------------------

Collector.groupingBy(key,value or the fields which willbe the key or give custom keys.) . give map wiht key and values as list of values/object
Collector.joining('delimiter','Start char','end char')
Collector.partitionBy(Parttion as true and false.)  give map wiht key and values as list of values/object
Collectors.counting() -- will give you count of the elements.
Collector.MinBy(Comparator.comparing(Student::getMarks))----------- this will give a min marks across the students
Collector.MaxBy(Comparator.comparing(Student::getMarks))----------- this will give a max marks across the students

Q. Function of comparator interface used in sorted function of stream api 
ANS : If you don't pass the parameter it will sort the students as per the natural order.
list.stream().sorted( ? ).collect(Collector.toList())
Comparator.naturalOrder()
Comparator.reverseOrder()
Comapartor.comparing(Student::getMarks)
Comapartor.comparing(Student::getMarks).reversed()
Q. Various functions of map in stream ?
Answer : 
map(Function<t>,return type <H>)  ------------ > Convert or drill to a single object 

----- Ye maps use krne ke baad aap direct average(),min,max,sum terminal functions use kr skte ho-----------
mapToObject(Function<t>,return type <H>) ---------> to cast mostly it is used
mapToInt(Function<t>,return type <H>) ----------> to cast to int mostly it is used
mapToDouble(Function<t>,return type <H>)----------> to cast to Double mostly it is used
mapToFloat(Function<t>,return type <H>)----------> to cast to float mostly it is used
maptoLong(Function<t>,return type <H>)----------> to cast to Long mostly it is used
----- Ye maps use krne ke baad aap direct average(),min,max,sum terminal functions use kr skte ho-----------


Q. How to convert from arrayList to linkedHashmap :

import java.util.*;
import java.util.stream.*;

public class Main {
    public static void main(String[] args) {
        // Create a list
        List<String> list = Arrays.asList("apple", "banana", "cherry", "date");

        // Convert the list to a LinkedHashMap using Stream API
        LinkedHashMap<String, Integer> linkedHashMap =
                list.stream()
                    .collect(Collectors.toMap(
                            // Key mapper: Use the list element itself as the key
                            Function.identity(),
                            // Value mapper: Use the length of the string as the value
                            String::length,
                            // Merge function: If there are duplicate keys, retain the first occurrence
                            (v1, v2) -> v1,
                            // Supplier: Create a LinkedHashMap
                            LinkedHashMap::new
                    ));

        // Print the LinkedHashMap
        System.out.println(linkedHashMap);
    }
}


Q.Difference between Char , Characters and CharSequence?

1. Char : it is the primitive datatypes and is used to hold one char value as shown below
char ch = 'a'
2. Characters : its a non premitive datatypes and are also known as wrapper classes to wrap the primitive data types which allow use of other utility functions provided by the wrapper classes.
char ch = 'a';
Character ch = new Character(ch);
3. CharSequence chs is the interface which is implemented by the classes like , String , Stringbuilder and stringbuffer to implement various operation on sequence of characters . Its can contain a single to a sequence of characters.

CharSequence ch  = "a";
CharSequence chs = "radar";

chs.Charat(index)
chs.subSequence(1,3) --- like substring
chs.length()---> get the length
					

Q. How to run loops in stream api ike for(i=0;i<892;i++) this one is replaced by what in ?
IntStream.range(0, str.length() / 2)  ----- this will make a loop from 0 to half a length of a strgin.
IntStream.range(0,100).------------------- this will make a loop of 0 to 100

2.Difference between Collections and streams 

	NOTE  : ANYTHING WHICH IS A LIST OR A COLLECTIONS (ARRAYLIS , HASHSET , TREEMAP , HASHMAP , LINKEDLIST , ARRAYS, LIST  ETC ) WE CAN CONVERT THOSE TO STREAM AND USE ALL THE STREAM API FUNCTION TO PLAY ARROUND
	
	Collections : 
		Elements can be added or removed from the collections as required
		Elements can be access from any index
		It is eagrly constructed
		It can traversed N number of times 
		Iteration is done using external iteration technique. We use for loop explicitly to traverse the collections .
		
	Streams : 
		Elemnets can not be added or removed from the stream . only the fiteration can be applied by adding the Predicate 
		Elements can be accessed only once .
		It is traversed only once using the streams . means we cannot apply for loop or an loop to traverse the stream created twice.
		Iteration for stream happened using internal iteration / internal stream api function .
		It can be eagrly or lazily traverse through the data.
	
		
3.How to debug a stream operation applied to a collections ?

	We can use peek () method and pass a consumer to peek() and print the single object of the stream 
	StudentsService.getStudents().stream()
               // .peek((student)->System.out.println(student)) /// this show internal iteration of each student object is happening.
                .filter(predicate1)
                .peek((student)->System.out.println("Post filter :  "+ student)) /// this show internal iteration of each student object is happening.
                .collect(Collectors.toList());

4. map() method in stream api . is used to convert one type of stream to another 
 example it can also be used to perform some type of operation on the stream like below 
 public Function<Students,String> function1 = (s)->{
	return s.getName();
 };
 Set<String> collect = StudentInstace.getstudents().stream() // will give Stream<Students>
                .map(function1) // will give Stream<String>  so map is converting the Stream of students type to stream of string type 
				.map(String::toUpperCaseString) // Stream<String> this is not coverting the type to another type . it is performing the operation to the stream.
                .collect(Collectors.toSet());

5 flatmap method in stream api : https://www.javatpoint.com/flatmap-method-in-java-8
/**
		 * loop inside loop is like stream inside the stream.
		 * Flatmap ka kaam hai elements ko combine krna
		 * below code mai map jo Stream of list return krra hai usko
		 * flatmap combine krra hai
		 */
		List<Integer> list1 = Arrays.asList(1, 2, 3);
		List<Integer> list2 = Arrays.asList(4, 5, 6);
		List<List<Integer>> pairs = list1.stream()
			//	.map(i->list2.stream().map(j->Arrays.asList(i,j)))
				.flatMap(i->list2.stream().map(j->Arrays.asList(i,j)))
				.peek(System.out::println)
				.collect(Collectors.toList());
		System.out.println(pairs);
output : 
[1, 4] ------------ > ye each list map return krra hai jisko lekr flatmap combine krra hai 
[1, 5]
[1, 6]
[2, 4]
[2, 5]
[2, 6]
[3, 4]
[3, 5]
[3, 6]
[[1, 4], [1, 5], [1, 6], [2, 4], [2, 5], [2, 6], [3, 4], [3, 5], [3, 6]]  ----------- Flatmap combine krke ToList ko detta hai and ollla .

Process finished with exit code 0


flatmap is similar to map function is applied to convert from one type to another .
And is applied to the stream in which each element in the stream contains multiple elemenst 

exmaple : below are the two example stream 
if Students class contains an attribute List<String> subjects = new ArrayList<>();

public Function<Students,List<String>> function1 = (s)->{
	return s.getSubjects();
 };
 Set<String> collect = StudentInstace.getstudents().stream() // will give Stream<Students>
                .flatmap(function1) // will give Stream<String>  so flatmap is converting the Stream of students type to stream of List of string type
                .collect(Collectors.toSet());
				
	Stream <List<String>> : This means each element in this stream contains List , List , List , List .....
	Stream<Arrays>: This emans each elements in this stream contains Array, Array, Array, Array, Array, ......
	
	
	Just like we had streams<String>
			It contains Str1 ,Str1 ,Str1 ,Str1 ,Str1 ,Str1 ,Str1 ,Str1 ,...
			
		Example : Before Flattening: [[1, 2, 3, 4], [7, 8, 9, 0], [5, 6], [12, 18, 19, 20, 17], [22]]
		
				  After Flattening: [1, 2, 3, 4, 7, 8, 9, 0, 5, 6, 12, 18, 19, 20, 17, 22]
			
6. We have some more functions in streams api : distinct , sorted and count 

distinct : it will return the distinct value form the stream .
Count : will give you the count of the element in the stream 
sorted : will sort the elements in alphabetical order .			
		 
		 
We an use Sort function which except a parameter sort(comparator function fnctional interface)

	- using sort function we can sort by selecting any field value as a comparator and help in sorting the values .
	example : StudentInstace.getstudents().stream() /// stream function always pass the elements ONE BY ONE 
                .sorted(Comparator.comparing(Students::getName).reversed())   // this will print the students in revred order as per the name
                .collect(Collectors.toList());
		 
7. FIlter function which wants predicate functional interface that contains conditions to help filter out the elements		 
	EXAMPLE :  StudentInstace.getstudents().stream()
                .filter(students -> students.getMarks()>500)
                .filter(students -> students.getActivities().stream().count()>2)
                .collect(Collectors.toList());

8. reduce function of stream api . it is also a terminal function means the end operation . Collect is also a terminal operations.

This function is used in case we neeed to reduce the set of value to a single value that you are looking for. example a list of integeres to a a sum or to a single values. This reduce will ask for binaryOPerator functional interface object . two input parameters with same data types and out put will be same.

Exmaple of map , filter and reduce 
StudentInstace.getstudents().stream() // Stream<Students>
                .filter(students -> students.getMarks()>300) // Stream<Students>
                .filter(students -> students.getActivities().stream().count()>2)// Stream<Students> with activities greater then 2
                .peek(student -> {
                    System.out.println("Post filter "+ student);
                })
                .map(Students::getNotebooks)// Will give Stream<Integers>
                .peek(notebooks -> {
                    System.out.println("Notebooks for each student "+ notebooks);
                })
                .reduce(0,(n1,n2)->n1+n2);

	Very important feature : Above reduce will break the stream into two parts and process the two notebooks streams parallely and will add at the end. 

	Reduce first iteration will be 0 assign hogga n1 ko and n2 ko notebookr values.then plus hogga 
	Reduce second iteration will be upr ka result  assign hogga n1 ko and n2 ko notebookr new values.then plus hogga

	this will go on.

				
9. min, max operation we can do using the method reference of Integer class like Integer::max(a,b) and Integer::min(a,b).
Always use reduce without default identity value

10. Limit() and Skip() fn of stream api .		

limit(3) --- > it means it will only send the first three elements from the stream to further process 
skip(3)----- > it means it will skip the firt three elements and send the rest of the elements to further process.

11. anymatch , nonmatch , allmatch stream api fn  return boolean 

all these three function wants predicate as a n input 

anyMatch () ---> will return true when any one of the elements matches the predicate 
Allmatch () --> will return true when all the elements from the streams matches the predicate .
nonmatch ()----> its opposite of allmatch it will return true when none of the elements matches the predicate and false it matches.
System.out.println(StudentInstace.getstudents().stream()
                .allMatch(students -> students.getMarks()>500));
        System.out.println(StudentInstace.getstudents().stream()
                .noneMatch(students -> students.getMarks()>500));
        System.out.println(StudentInstace.getstudents().stream()
                .anyMatch(students -> students.getMarks()>500));

12. findAny() and findFirst()

will find first elements from the stream . both of these functions are mostly used in combinatin with the filter functions

findAny : it will return any of the element that matches to the predicate 
findFirst : it will return the first element that matches to the predicate 

13. Short circuiting : 	its the process in which a given function doesn't iterate through the whole stream to get the results .
So all the functions below doens't iterate through the stream to get the results 

limit 
skip
allmatch
anymatch
noneMatch
findfirst 
findany

14. Stream api operations : 

of() - this funtion will help in creating the stream of values . The values can be infinite.
iterate()-  this function will iterate value to infinite values 
generate() - this function will also generate stream of infinite value and ask for a Supplier<> functional interface objects .
Stream.of : used to generate or initialize a stream.
File.lines() ---- Will return the Stream<String> stream . We can use it for further play .

15. NumericStreams : 

	Name of the stream : IntStream . 
	Why we have to use IntStream ? 
	Because when ever we do any numeric operation like blow the unboxing from Interger to int is happening one by one which is an added steps.
	So thats we can use IntStream,LongStream directly to do the operations.
	
	example : 
	return IntStream
                .rangeClosed(1,6)
                .sum();

16. NumericStreams range functions : 
	IntStream.Range(1,50) --> This will range the integre from 1 to 49  , excluding 50.
	IntStream.RangeClosed(1,50)---> this will range the integer from 1 to 50 .
	
	We have 
	LongStream.Range(1,50) --> This will range the integre from 1 to 49  , excluding 50.
	LongStream.RangeClosed(1,50)---> this will range the integer from 1 to 50 .
	
	We don't have range and ranegclosed for doublestream
	
	IntStream.RangeClosed(1,50).asDoubleStream().foreach(sout(i))
	
Note : WE CAN ITERATE THE STREAM ONLY ONCE , OR ELSE IT WILL CREATE AN EXCEPTION.	
	

		A. Different aggregate function used along with range functions 
		sum(),min(),max() and average()
		
		example : 
		System.out.println("Int Range closed sum : "+IntStream.rangeClosed(1,50).sum());
						System.out.println("Int Range sum : "+IntStream.range(1,50).sum());
						System.out.println("Long Range closed sum : "+LongStream.rangeClosed(1,50).sum());
						System.out.println("Long Range sum : "+LongStream.range(1,50).sum());
						System.out.println("Double Range closed sum : "+ IntStream.rangeClosed(1,50).asDoubleStream().sum());
						System.out.println("Double Range  sum : "+ IntStream.range(1,50).asDoubleStream().sum());
						OptionalInt min = IntStream.rangeClosed(1, 50).min();
				if(min.isPresent()){
					System.out.println(min.getAsInt());
				}else{
					System.out.println("No range is there");
				}
				OptionalInt max = IntStream.rangeClosed(0, 0).max();
				if(max.isPresent()){
					System.out.println(max.getAsInt());
				}else{
					System.out.println("No range is there");
				}	
				
		B. boxing and unboxing : 
		Unboxing  : its represents the unwrapping of data type from wrapper class(Integer , Double , Character , Boolean etc ) to premitive types(int , long , double etc ).		
		Boxing  : its represents the wrapping of premitive types(int , long , double etc ) to wrapper class(Integer , Double , Character , Boolean etc ).
		example : we can convert from int array to List of integer 
		Arrays.stream(arr)   ------------> IntStream
                .boxed()     ------------> Stream<Integer>
                .collect(Collectors.toList()); ------------> List<Integers>
			
		C. Some more NumericStream function : mapToObj , mapToLong , mapToDouble
			mapToObj : is used to convert intstream to any object . we can use customize class also for the conversion . Matlab kissi  bhi class ke constructor ko cal krke value pass kro and create an  object from it.
			
			mapToLong : this will convert the instream to long stream 
			
			mapTodouble : this will convert the instream to double stream 
			
17. Terminal functions : which is used to collect the end elemenst post all operations in a stream . Terminal functions actually kick start the stream processing.
		example of terminal functions : 
			max() , min() , sum () , reduce() , average() , collects () etc 
			
	Main focus on collect method () .
		collect(Collector class objects and a function call (joining , ToList etc ))

			- joining() which will concatenate all the elements 
			  joining (delimiter , preffix , suffix)
			 
			- counting() this will give the number of elements collected in the last collect fn.
			
			- mapping() this fn will apply the transformation first and then collects the data in a collecition (could be on ay type .)
				In this fun we can do the transformation as one parameter and collect in another paramater of the fn.
				
			- maxBy and minBy fn needs a comparator onbject and that comparator fn will need the function functional interface object (like a condition to use for )
			
			- averagingInt() and summingInt() . These two Collectors(dot) funtions will help is summing up and calculating average of the elements in the streams
				These fn will reduce one step or LOC .
					earlier approach  : We create stream , then map , then sum or average .
					now approiach  : we create stream , then collects(Collectors(dot)summingInt() or averagingInt)
			
VVVVIMP  	- groupingBy () : this function will help in grouping the data on a basis of the paramater we give as an input. 
								This fun will always return Map<k,V> . 
								
					Types : 
						type1 : In this we have one parameter groupingBY . in which only one condition will be there .
								
								   Map<Integer,List<Students>> collect = StudentInstace.getstudents()
								.stream()
								.collect(Collectors.groupingBy(students -> students.getMarks()));
								
						type2 : In which we can pass two level grouping by passing two parameters to it.
								groupingBy(fn classifier , Collector)
								
								 Map<String, Integer> map  = StudentInstace.getstudents()
								.stream()
								.collect(Collectors.groupingBy(Students::getName,Collectors.summingInt(Students::getNotebooks)));
								
					
						type3 : in which we will pass three paramters , one is input , 2nd is what is the data type or objects returned as a whole 
									, 3rd will be the output 
									 Map<Integer, List<Students>> map  = StudentInstace.getstudents()
									.stream()
									.filter(students -> students.getMarks()>500)
									.collect(Collectors.groupingBy(Students::getNotebooks, LinkedHashMap::new,Collectors.toList()));
									
		        - partitioningBy() : its also kind of groupingBy 
					It generate Map as an output.  will always create two Key and its value (key1 as true and key2 as false .)
					The key will always be a boolean 
					The first parameter is a predicate . 
					
					Type 1 : with single paramater only predicate 
					Type 2 : with two paramater (predicate , downstreamcollection .)

	- NOTE  : 
		Reduction terminal operations : which is the special kind of operation in nutshell which will eventually combine the data into a new collections or form 		at the end.
			not a reduction : allmatch , anymatch , FindAny, FindFirst : these fn are not reduction bcse all these function may or may not traverse the entire stream .
			A reduction : Min , max , count , sum , collect , reduce. These fn iterate all the values of a stream to a common collection or a value at the end.
					
					
18. Parallel streams : 					
	What are parallel streams : the parallel streams will break the steam into pieces and run the terminal operations parallely taking less amount of time.	
	Its not always increase the performance of the operation of apps. Always check it .
	     int sum = list.parallelStream()
                .reduce(0,(x,y)->x+y);
				
		Q when not to use parallel streams.?
			- whenever you are using a mutable variable not to use the parallel streams . because the thread created will keep on updating the value of the mutable variable 
				concurrently giving  wrong results 
			
19. Optional			: used to represnt a Non-null values in java 8 or avoid NullPointerException

	Optional<Person> ops = Optional.OfNullable(p1) -- this will return either a valid value or the optional.emmpty object back to handle the null value 
		if(ops.isEmpty()){
				sout("We can save the program to fall ina pit of null pointer and termination")
		}else{
				sout("it is not empty")
		}
	Optional.Of(p1) ---- this will either give you valid value of a null pointer exception in case of null value pass to it.
	Optional.Empty() -- this will return optiona.empty object back .

	So we used these Optional class to wrap the values to either generate a optional of values or an Optional of empty.
	
	This gives an advantage of getting optional as empty which is far better then getting a null which can not be used to check further and poses NullPointerException.
	
	In lemn term , we can do dot to optional object and still move away from getting exception in case empty value is there.
	
	SUMMARY : SO USING OPTIONAL.NULLABLEOF WILL WRAP THE NULL VALUE TO OPTION.EMPTY AND HELP BYPASSING GETTING NULL POINTER EXCEPTION .
	
  a. Methods used  :
		- orElse : this is used to return a value(String) other then the valid one 
			Optional<Students> optionalStudents = Optional.ofNullable(StudentInstace.supplier.get());
			return optionalStudents.map(Students::getName).orElse("Default name ");
			
		- orElseGet : this is used to return the value(It used supplier as a paramter) other then the valid one 
			Optional<Students> optionalStudents = Optional.ofNullable(StudentInstace.supplier.get());
			return optionalStudents.map(Students::getName).orElseGet(StudentInstace.supplierName);
			
		- orElseThrow  : this is used to return an exception if the value is not valid.
					Optional<Students> optionalStudents = Optional.ofNullable(StudentInstace.supplier.get());
			return optionalStudents.map(Students::getName).orElseThrow(StudentInstace.supplierException);
  
  b. More mthod : So ifPresent will do the thing that  if else is doing using isPresent
		- isPresent() : This fn will tell you if the value is present or not and return boolean results.
		- ifPresent()  : this fn will tell you if the vaue is present or not and also what to do further using a consumer functonal interface paramater 
		
  c. More method : 
		- filter() : just we used filter in strean to filter out the stream elements using a predicate , we can filter out the element from an Optional also  . It uses the predicate.
		- Map() : just like we used in stream to convert the value from the object to another . Here as an example we map the vaue from a student class to string while getting a name.
		- flatMap : it must be used in case we have element which is a list of elements .and convert it to elements of normal type .
					BUt here if we want to get the Optional elements under an another Optional Object
					
20. Interfaces : Which contains only fn declarative and not body for it. we have to define the body of the fn in the implementation class.
				Problem : if we add one fn to the interface then all classes have to import the newly added method for clean build.
				For this they added default fn in interfaces.
					Default methods contains the body of the fn and can be overriden in implementation classes.
					
	For List< > interface some more default fn are added to the interface.
		Those fns are
			default sort() : will sort the in either natural order or some other order.
			default replaceAll()
			dfeault Spliterator()
			
21. Comparator interface : Which is used to sort the collections like List .List has a default function sort which can be used to sort the collection we just have to pass he comparator to it.
				- now we have already seen that can be achievable using the stream.sort(Comparator.comparing(Students::getname)).Collect(Collection.toLIst) : which sort the students as per their names.
				
				- We can use the comparator interface itself to do the same .
				
				exmaple :  List<Students> list = StudentInstace.getstudents();
							list.sort(Comparator.comparing(Students::getMarks).thenComparing(Comparator.comparing(Students::getMarks)))
							OR
							list.stream()
							.sorted(Comparator.comparing(Students::getname))
							.collect(Collector.Tolist());
		
				- We can also chain the Comparator two or more  logics into one .
					thenComparing() is the fn we can use to chain an another criteria for sorting the elements 
					
						
				- How to handle if the elements lists contains null elements . To do so by using above method it will throw null pointer exception .
						So we can use another fn named : 
						  List<Students> list = StudentInstace.getstudents();
							list.sort(Comparator.nullsFirst(Comparator.comparing(Students::getName)));
							list.forEach(consumer);
				
				
22. INterfaces and two method introduced in JAVA 8 for interfaces.
	- default method : which will have a fn body and the fn can be overriden in the implementation class.
	- static method : which will have a fn body and can not  be overriden in implementation class because its on the class lvel .

23. Multiple inheritence : 
		Two imp points : 
			- one interface can extends anther interface 
			public interface Interface2 extends Interface1{
			- class can implements multiple interfaces .
			public class MultipleInheritence implements Interface1,Interface2, Interface3{
			
		Overiding precedence goes as follow : 
			1 priotity : the fn which is overriden in the IMPL class which is implementing the interface.
			2 priotity : the fn which is overriiden in the interface that extends the other interface.
				
		Imp Point : for exmaple interface1 has default mthodA and interface2 also has default methodB , then in main class impl java compile issue will be ther e.
					To resolve that we need to override the methodA in IMPL class .
					
24. Introduction to data/Time Liberaries  

Introduction to java 8 date / time classes. : immutable 
Localdate 
LocalTime 
LocalDateTIme
			LocalDate localDate = LocalDate.now();
        System.out.println("localDate : "+ localDate);
        LocalTime localTime = LocalTime.now();
        System.out.println("localTime : "+ localTime);
        LocalDateTime localDateTime = LocalDateTime.now();
        System.out.println("localDateTime : "+ localDateTime);
		
----------------------
   LocalDate localDate = LocalDate.now();
        System.out.println("localdate :  "+ localDate);
        System.out.println("day of the Era : " +localDate.get(ChronoField.YEAR_OF_ERA));
        System.out.println("Month using getmonth : "+localDate.getMonth());
        System.out.println("Month using get month  value :  "+ localDate.getMonthValue());
        localDate.getYear();
        localDate.getDayOfYear();
        localDate.getDayOfMonth();
        localDate.atStartOfDay();


How to modifying the localdate/localTime  instance : check the programs in git hub we wrote 

As a summray : 
	1. You can create an instance of Localdate , LocalTime and localdateTime using dot(.)now() funtions 
    2. Then you can also create the instances of each above class using Of() in which you can mention your values as per the date and time required 
	3. Then you can get the value from the instances you created using various method exmple  : getMonths() , getHours etc 
	4. Then you can also update or modify the instance value you created using many mthods like , Plus() , minus() , with () etc 
	5. We can also convert the localDate to localDatetime using .atTime(localTime instance ) mthod and also we can get the localdate and localtime from LocalDateTime instances .
	
25. Period class : This will be able to generate period of a time . it is compatible with LocalDate instance only . It can not be applied on other instances .
		// first create the period using localDate.untill(localDate1) method  or by using Period.ofYear(10).
		// Then we can get the value accordignly .
		
26. Duration  : it is only compatible with the localTime instance.
			Duration duration = Duration.ofDays(10);
        System.out.println("Second in a day : "+ duration.getSeconds());

        LocalTime localTime = LocalTime.of(21,23);
        LocalTime localTime1 = LocalTime.of(22,23);
        long duration1 = localTime.until(localTime1, ChronoUnit.MINUTES);
        System.out.println("Minutes in time differnce of loc1 and loc : "+duration1 );

        Duration duration2 = Duration.between(localTime,localTime1);
        System.out.println("Diff using between fn : "+duration2.getSeconds());
		
		
27. Instant : part of java.time , used to represents a time for machine readable format .	

28. TimeZone creation using java 8 zone sepcific date time liberaries
ZoneDateTime : generate the datetime asper the zone (region)  . It contains Zone id and Zone offset 

how to convert the localDateTime to ZonedDateTime .
We can use localDateTime.atZone	() fn to set the zone and get the time for that zone .

29. Convert java.util.date to localdate and vice versa and java.sql.date to localdate and vice versa.

30. DateTimeFormatter class : 

DateTimeFormatter is widely used to parse of format LocalDate , LocalTime , LocalDatTime.

So everytime we need to convert a string date to LocalDate format we can parse the localdate object using parse method and pass the date and DateTimeFormatter.Codeorformatttouse.
So everytime we need to convert a string date to LocalTime format we can parse the localTime object using parse method and pass the time and DateTimeFormatter.Codeorformatttouse.
So everytime we need to convert a string date to LocalDateTime format we can parse the localDateTime object using parse method and pass the Datetime and DateTimeFormatter.Codeorformatttouse.

31. Logger :  https://www.geeksforgeeks.org/spring-boot-logging/

We Can activate log level as per below command.

java -jar target/log-0.0.1-SNAPSHOT.jar –debug
java -jar target/log-0.0.1-SNAPSHOT.jar –trace

In Spring boot project we can set up the project my adding logging properties in application.yaml file. Below lines will activate the debug or trace logs and for color-coded log output can be seen in the console usinf ansi prop and we can send the logs to the file by using logging.file prop

debug=true
or
trace=true
spring.output.ansi.enabled=always
logging.file.path=C:/Github/IIBcode_Sessions/rest-webservice/logs
logging.file.name=C:/Github/IIBcode_Sessions/rest-webservice/logs/application.log

slf4j be the package to be imported.

Logger log = Loggerfactory.getLogger(Classname.class)

		logger.trace("Log level: TRACE");
        logger.info("Log level: INFO");
        logger.debug("Log level: DEBUG");
        logger.error("Log level: ERROR");
        logger.warn("Log level: WARN");
		
31. OAuth2.0 in spring boot : 
	OAuth 2.0 architecture consists of an OAuth Service or a server which generates a token for the consumer to get authenticate 
	https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2
	
	
App/Consumer -------Request Resource(1)/Authorozation grant request(1)-------------->    
				|														             | 
				| 																	 |	User(Resource Owner) (By using the application name , Client Id and uri it will Autheticate and generate a grante )
				|																	 |
		        |<-----------------Authorozation Grant send back(2)------------------- 	
				| 
				| 
				| 
				|----------------Access TOken Request using Grant(3)------------------>
				|																	  |
				|																	  |   Authorization Service or OAuth Server (Validating the Authorization grant it will generate the access token) 
				|                                                                     |
                |<---------------Access token sent back(4)-----------------------------
                |
				|
                |
                |---------------Using Access Token send resource request(5)------------>  Resource server or api or controller
				|																	  |
                |                                                                     |
                |<--------------Resource response sent back(6)------------------------|


Important points : 	
1. To start using OAuth from the user resource owner the consumer and application have to register itself with basic details like, Appname , application id and Redirect url etc .
2. Once your application is registered, the service will issue client credentials in the form of a client identifier and a client secret. 
				
				
		
Q : What is conc|urrent hashing.?
A concurrent has|h table (concurrent hash map) is an implementation of hash tables allowing concurrent access by multiple threads using a hash function.[1][2]

Concurrent hash tables thus represent a key concurrent data structure for use in concurrent computing which allow multiple threads to more efficiently cooperate for a computation among shared data.[1]

Q : Can we turn off Autoconfiguration.?
We can disable it by using exclude attribute of @EnableAutoConfiguration and mention the class name to be excluded.
@Configuration
@EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})
public class MyConfiguration {
}

Q : Why is string immutable ?
The String is immutable in Java because of the security, synchronization, concurrency, caching, and class loading. 
The reason of making string final is to destroy the immutability and to not allow others to extend it.
The String objects are cached in the String pool, and it makes the String immutable. The cached String literals are accessed by multiple clients. 
So, there is always a risk, where action performs by one client affects all other clients. For example,
if one client performs an action and changes the string value from Pressure to PRESSURE, all remaining clients will also read that value.
For the performance reason, caching of String objects was important, so to remove that risk, we have to make the String Immutable.		

Q. What is KeySet and ValueSet .?
These are used to iterate the hashmap as per the keys or as per the values. 

Q. What is Cloneable interface?
this interface is used in prototype deign pattern to clone the instance of the objects. Its has a clone method which we can override to wither send the object instance or to send the an exception of clonentsupportedexception.

Q. What is the Difference between comparator and Comparable ?

Both are interface which can be used to compare objects on the basis of a an attributes . The main difference between the Comparator and Comparable interface is that you can use Comparator to compare two independent objects. The Comparable on the other hand is used to compare the current object(this) with another object.

Comparator example : to compare two different objects 

Steps : 
	1. Create PersonComparator clas implements Comparator<Person> 
	2. Override the Compare method asking two objects(p1,p2) as a paramaters; p1.getAge()-p2.getage().
	3. then use this in test class create the object of Comparator<person> per = new PersonComparator();
	
Comparable	
Steps : to compare current instance with the other object.
	1. Make the Bean class (ex : Person) implements Comparable<Person>
	2. overrde the compareTo method asking for one perons objects(p1) and compare the this.age-p1.getage().
	3. Then use it in test class

https://learnjava.co.in/difference-between-comparator-and-comparable/#:~:text=Basic%20difference%20between%20Comparator%20and%20Comparable%20The%20main,to%20compare%20the%20current%20object%20with%20another%20object.


Q. What is JVM shutdown hook ?

Shutdown Hooks are a special construct that allows developers to plug in a piece of code to be executed when the JVM is shutting down. This comes in handy in cases where we need to do special clean up operations in case the VM is shutting down.

public class ShutDownHook
{
  public static void main(String[] args)
  {
 
    Runtime.getRuntime().addShutdownHook(new Thread()
    {
      public void run()
      {
        System.out.println("Shutdown Hook is running !");
      }
    });
    System.out.println("Application Terminating ...");
  }
}

Q. differnce between comparable and comparator?
Sure, here's an explanation with an example for both Comparable and Comparator interfaces in Java:

Comparable Interface:

The Comparable interface allows objects to be compared based on their natural ordering. Let's say we have a class Person:

public class Person implements Comparable<Person> {
    private String name;
    private int age;
    
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    public String getName() {
        return name;
    }
    
    public int getAge() {
        return age;
    }
    
    @Override
    public int compareTo(Person otherPerson) {
        // Compare persons based on their age
        return Integer.compare(this.age, otherPerson.age);
    }
}

Now, we can sort a list of Person objects based on their age simply by calling Collections.sort():

List<Person> people = new ArrayList<>();
people.add(new Person("Alice", 30));
people.add(new Person("Bob", 25));
people.add(new Person("Charlie", 35));

Collections.sort(people);

for (Person person : people) {
    System.out.println(person.getName() + ": " + person.getAge());
}


Comparator interface :
The Comparator interface allows for custom sorting logic to be defined separately from the class being sorted. Let's say we want to sort Person objects by name
import java.util.Comparator;

public class NameComparator implements Comparator<Person> {
    @Override
    public int compare(Person p1, Person p2) {
        return p1.getName().compareTo(p2.getName());
    }
}


Now, we can sort a list of Person objects by name using this comparator

List<Person> people = new ArrayList<>();
people.add(new Person("Alice", 30));
people.add(new Person("Bob", 25));
people.add(new Person("Charlie", 35));

Collections.sort(people, new NameComparator());

for (Person person : people) {
    System.out.println(person.getName() + ": " + person.getAge());
}

Q. How to enable and disable the autoconfiguration in spring boot ?
Answer : By default the autoconfiguration is enabled in spring boot and the user can disable it by using annotation or by using the spring properties.

1. Annotation used : @EnableAutoConfiguration
	 Example :
@SpringBootApplication
@EnableAutoConfiguration(exclude = {MyAutoConfiguration.class})
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}

2. Property useed : spring.autoconfigure.exclude = myAutonconfigurationclass.class
Example : spring.autoconfigure.exclude=com.example.MyAutoConfiguration

3. Property used for conditional exclusion  : spring.autoconfigure.condition.Somecondition=false.
spring.autoconfigure.condition.someCondition=false



Q. Nested loop in stream api :
import java.util.List;
public class Employee {
    private String name;
    private List<Task> tasks;
    // constructor, getters, setters
}
public class Task {
    private String name;
    private List<Subtask> subtasks;
    // constructor, getters, setters
}
public class Subtask {
    private String name;
    // constructor, getters, setters
}
-----------------------------------

import java.util.List;
public class Main {
    public static void main(String[] args) {
        List<Employee> employees = ...; // Retrieve list of employees

        employees.stream()
                 .flatMap(employee -> employee.getTasks().stream()) // Flatten tasks
                 .flatMap(task -> task.getSubtasks().stream())     // Flatten subtasks
                 .forEach(subtask -> System.out.println(subtask.getName()));
    }
}


