Java Course ----------------------------------------
1. java is iteroperable or can be run on multiple platform using the JVM(java virtual machine) on the target system .
2. Platform independent : Java bytecode created by the java compiler .
	The byte code we can run it on the jvm in target system .
	
	
	
	
	java code ------------------------> compiler -----------> byte code --------------> translate the byte code to binary codes-----------------> Run on target system.
	
	C and c++ compiler doesnot create a byte code. It sirectly run the binary code post compilation 
	
	Because of the extra step in java of creating a byte code its some says its slower . But we can use JUST-IN-TIME-COMPILER .  whic at the same time converts the byte code to the binary code and machine language.
	
	JDK  -------Contains ---------------> Compiler & JRE  -------->Contains the JVM and class binaries  -------JVM -----> is the virtual env to run .class file
											|						required to run the program . 
																	No compiler is there
											|
											|
											|
								Its the source code compiler to compile the .java file to create the .class file.	
									  
3. JRE and JDk and JVM : 
	- JRE : Java run time environments.
		Its a software package that only contains the JVM and class liberaries which are required to run a java program . we can not compile the java program using a JRE.
		It provide just in run time env.
	- JDK : Java development kit : 
		Its a combination of JRE and Java compiler .
		Compiler will helps in compiling the new java code and JRE containg JVM will help in running the code by converting the byte code to binary language.
	

NOTE : IN NUT SHELL , IF WE NEED TO WRITE , COMPILE AND RUN THE CODE WE NEED JDK WHICH HAVE JRE AND COMPILER . IF WE WANT TO RUN A JAR FILE OR THE .CLASS FILE WE ONLY NEED JRE AS IT PROVIDES THE JVM FOR RUNNING THE CODE.

4. Class is the blueprint from which we can create the different objects .
	understand it like class is a generic page or higher classification . Like person : ----person is a blue print for two types of persons(girl or  a boy.)
	Class is Person 
	Object can be Person james = new Person()
	Object can be Person clark = new Person()
	Object can be Person mia = new Person()
	
5. Life of objects :  So we know that : Person a = new Person();

			Person a ----------> its like creating a reference object and a romote control ready to point to a  memory locations.
			
			new Person ---------> This will create a heap memory allocations .
				
				In order start making the ref remote cnotrol pointing to heap mem allocated we need to link these.
				
				Person a = new Person(); -------------> linking or start making the object a start pointing to JVM heap memory location 
				
			In my view creating multiple objects and heap memory with it will use more memory space of you system .
			Instead we can point the reference object to the same heap memory space . But that might end up bombarding the heap memory used by all instance objects 
			so we can create object by referencing it .
			Person a = new Person();
			Person b; ----------> only creating a refernce object but not allocating any heap memory
			b=a ------------------------- this will also point to the same heap memory locations as a object is doing 
			
6. Package name :  Collections of classes.

	Access modifier default is it is access with in the class only . 
	if we put that in different package we need to make it public to import it another clas. 
				
				With in Class 					IN Same package 			In subclasses			In Other packages 			
    public  	Allowed access					Allowed access				Allowed access			 Allowed access								
	protected   Allowed access					Allowed access				Allowed access 			 Denied access							
	default     Allowed access					Allowed access              Denied access            Denied access                                  		
	private   	Allowed access 					Denied Access 				Denied Access			 Denied Access 				
	
	
JAVA apis : application programming interfaces : which are the collections of packages of classes or programs writtern to be re-used . Like we used String , int and these classes are already wriiter in JDK know as the APIs
	
7. variables and data types  :

	a.  Primitive data type variable  : like : char , int , short , long , double . All these have different storage size. These are not user defined and can not be changed.
			variables : Instance variable and Local variable
			- Instance variable : 
				Those variables which reside inside the class level. and is get initialized whenever the instance of that class is created,
			- Local variable : 
				Those variable declared inside the method of the class . those variables should be initialized or else the compiler will complaint.
				default value for int, byte , long , short =  0 , boolean is false ,  float , double  = 0.0 and for char = '\u0000' , this is the unicode value for char when you will sout the char using unicode it will print the char a , b, c, ....
		
		Non-primitive data types are arrays , classes , string. These data types can be user defined means user can customize these data types to create new one.
		
	b.  Reference variable : Are the variable which are refrencesd to the heap memory .
			Person alex  = new Person();
			-----------
				|
				|
				|
			Reference variable .	

8. type casting  : Explicit casting from one data type to another .

9.Scope of variable : 				

	Static variable : It is accessible by all objects in a class and have a single copy of it across the class. This get loaded to the JVM when the program runs
	Instance variable : Which got initialized when the object or class gets instantiated. As it is on class level it can be accessed by all objects in the class
	Local variable : Is accessible only inside the method block .
	Block variabe : Whic is access only inside a block of code , like if  else block , for loop block etc . out side of these are not accessible 
				Example: 
					if(x == false){
							boolean y = true 
							Sout(y); ------------------------ this will print the y
					}
					
					Sout(y) -------------- this will not print y and throws compile error.
					
10. variable modifier .

	Below access modifiers are used only for instance variables 
		- public : public/protected/default final in i =0 ; 
		- static : static final int i = 10; it wil have common copy for all objects and access to all.
		- transient : transient static int i = 10 ;  its used for variables not be included as part if the serialized string or value used for transmitting data to other system 
		- volatile : volatile int i =0 ; to make the variable thread safe .
		
	Below modifier is used only for local variables & instance variables. : 
		- final keyword : final int i = 10 . this is telling the compiler the final value for i is 10 and no one can chnge the value for i later . if you are writting instance variable with final keyword you have to initialize it or else compile issue will be ther e.
		
11. Operators in java : 

		Important point : always use equals in string comparisons 
		++ and -- : always try to use it in suffix like : ++x or --x , if  you want the value incremented assinged it to x immediatley 
			x++ and x-- will increament and decrement the valus but will be assigend to the variable on next set of code lines.
		
	- below loc will give same results  : 
		System.out.println(--x1);
        System.out.println(x1);
		
	- below loc will give diffe results : 
		System.out.println(x1--);
        System.out.println(x1);
		
	- conditional operators :  example 
		- z =  x==y ? z = 100 : z =109;
		- z = str1.equalsIgnoreCase(str2) ? 100 : 109;
		
	- you can either use & or &&  , | or || both will work in same manners

12. Wrapper classes : 	 In collections we use wrapper classes as we can not use primitive data types in collections to store data .
		ArrayList<int> alist = new ArrayList<int>(); // invalid
		ArrayList<Integer> alist = new ArrayList<Integer>(); // valid
		
		Where Integer is the wrapper class.
		These classes are ussed to wrap primitive data types value like : boolean , byte , char , int , long , short , double , float etc 
		
		primitive data types 				Wrapper class 
		boolean									Boolean
		byte									Byte 
		char									Character
		int										Integer
		long									Long
		short									Short
		double									Double
		float									Float

	Notes 	We can understand it like this : we can declared the wrapper class object as this Boolean b = new Boolean(false) ; ------> in this , the constructor is used to hold the primitive data value.
	
	****BOXING AND UNBOXING : 
		The automatic adaptation of primitive data types into its corresponding Wrapper type is known as boxing, and reverse operation is known as unboxing
	**** AUTOBOXING AND AUTOUNBOXING : Autoboxing is the process by which a primitive type is automatically encapsulated (boxed) into its equivalent type wrappers whenever an object of the type is needed	
		This is the cool feature of java in which if we want to convert the primitive data type value to wrapper class just directly write it like tihs :
		- Interger f = 100;   here the Integer is the wrapper class and 100 is an int value , java is converting it automaticaaly to wrapper which is now giving us the advantage to us all other functions that wrapper class provide.
		- normal way to wrap a primitive value in wrapper class  
			Byte b = new Byte(10);
			Float b = new Float(10f);
			Double b = new Double(10d);

13 . Q WHERE THE OBJECTS , METHOD , INSTANC VARIABLES , LOCAL VARIABLE RESIDES IN ?
				
		HEAP MEMORY (garbage collectable memory)-----								STACK MEMORY--------
        						
		Objects 																	Methods 
													
		instances variable 															Local variables 
			
		
			
	Objects reside in the heap memory which can be released when the garbage collector comes .
	instance variables are connected with Objects so it also stays on heap 
	
	Methods reside in stack just like a stack of books , execute the methods one by one and pos  out of the memory
	Local variables as usual declared inside mothods so it also stay on stack .
	
	
	While coding keep in mind how to utilize the memory 
	
14. Modifiers of Methods : 	
		public : access from all 
		protected : restrict the access in same package 
		private : can not acess.
		default : can call it from same class only 
		static  : no need to create an insance/objects of the class in which this method is to access it . It will beloing to class.
		final   : Can not override the method  in child class which inherit the base class that contain final method.
		abstract : it is used only to declare the method without body .
		synchronised : only one thread can access this method at a time . Oher threads will wait for the release.
		
15. lambda : 
		Now Let's convert regular incrementByOne method to Lambda expression step by step.
		
		This is original method,
		
		public int incrementByOne(int num) {
			return ++num;
		}
		Step 1: Remove Access Modifier, Return type and Method Name
		
		So expression will be like like this,
		
		(int num) {
			return ++num
		}
		Step 2: Add Lambda operator(->) between the parameters and method block,
		
		(int num) -> {
			return ++num
		}
		This is the modified version of incrementByOne using lambda expression. If you want to simplify further, parameter’s data type is optional, so Let's remove those
		
		So method will be looks like this now.
		
		(num) -> {
			return ++num
		}
		To simply further,
		
		If your method has only one line of statement, you can remove {}. And also, if code is not in block return keyword is not needed
		
		So method will be looks like this now.
		
		(num) -> ++num;
		
		
		Sample code for Lambda expression:
		
		interface NumExamples{
			public int incrementByOne(int num);
		}
		
		public class MyClass {
			public static void main(String[] args) {
			NumExamples result = ( num) -> ++num;
			}
		}
		Since we haven’t discussed interfaces yet, The above code might be hard to understand for you. For now, just understand the idea of the Lambda expression.
		
		Note: If you are comfortable with the earlier structure of method implementation, feel free strict with the same. This is just an advanced and simplified version of the method structure.

		
16. Switch statements are better then if else block , the execustion line of code is lsser and it is faster then if else .
			switch (a == 0 || a==-1 | a==-2 | a==-4 | a==-3 ? 0 : 10) {
            case (5):
                System.out.println("FIRST BLOCK WITH a = 5");
                break;
            case (1):
                System.out.println("SECOND BLOCK WITH a = 1");
                break;
            case (0):
                System.out.println("THIRD BLOCK WITH a = 0");
                break;
            default :
                System.out.println("DEFAULT BLOCK EXECUTED");
                break;
        }
 
17. lambda expression in java for loop to break use return statement in it .

18. Constructor : 
			- Constructor can not have return type and can not be static
			
			- It is used to initialize the class variable .
			
			- As we did in rest api to initialize the bean attributes to a values.
			
			- One amazing thing learned is in our pojo class or bean class we can add both the constructor parameterized and non parameterized
				Paramterized will help in initializing the attaribute variable by passing the value in constructor.
				Non-parameterized will help in initializing the variable by using the .(dot) opertaor by crating the object of the class.
			
			- this() function used in pojo class itself will call the constructor of the same class and this one will call the non-parameterized one
			  this(1,"Meet","orlendo") this will call the 3 parameterized constructor in same pojo class.
			  this("meet",100999) this will call the 2 parameterized constructor in same pojo class.
			
			- super() function used in pojo class itself will call the constructor of the super class class and this one will call the non-parameterized one and if no super class is there then Object class constructor will be called 
			  super(1,"Meet","orlendo") this will call the 3 parameterized constructor in super pojo class.
			  super("meet",100999) this will call the 2 parameterized constructor in super pojo class.
			  "this" keyword onlone if you do this(dot) then it will show you all the instance members(class variable and methods) of the class.

	#IMP# : whenever you write a constructor in your class , compiler adds the super()function in starting point of it automaticaaly which will call the constructor of java.lang.object class if no class is extended.
	#IMP#  Single ton class : Can have only one object and can not be instantiated again .	

19. STATIC MEMBERS : static members can not call non-static members and vice - versa  . static is for class.

		Applied on below members of java : 
		
			1. static Instance variable : variables which are on class level can only be declared as static . public static int setavailable = 90;
				static variable are which will be common to all objects like 
					no of seats available is common to all tickets going to each pessenger . which will have an updated count . mean 90 is available for all .
			
			2. Static blocks : which will be run at the verry first step , sbse pehle run hogga 
			3. Static methods , will be called using the class name and not by creating a clas instance. Multiple static blocksare executed sequentially.
			Important  : STATIS MEMBERS CAN BE CALLED BY THE STATIC MEMBER ONLY (MEMBSR CAN BE ANYTHING , CLASS , FUNCTION , VARIABLE ETC )
20. Inheritance : 			

	- Wecan use extends the super class 
	-  public class subclass extends superclass
		subclass object = new subclass();
		
		this will use the super class and base class members.
		
		superclass object = new subclass();
		this will again  use the super class and base class members.
		
		superclass object = new superclass;
		this will use the super class only.
	- We can also pass the subclass type object as a paramter to a function needing super class objects
		
		public static lesswalk (Human h){
		
			sout(name + " :   walks less");
			
		}
		
		psvm(){
			sportsperson a = new sportsperson();
			a.name = "keen";
			lesswalk(a); ---------------------------------------------------------> subclass refenrce means HUman super set hai and sportsperson is subset humans ka 
		
		}
	
	- ambiguous arises and java doesnot support multiple inheritance and extends for two super class , nope not possible.
	- if we use final keyword for a class make that class non extendable .
	
21. Interface : Are the abstract class which contains the abstract functions and promotes the abstraction features by not defining the method functions .

			we know human can be categories as Artists and musician , both have diffr eating style , walking , breathing level and eye colours .
			Thses differnet featres we can keep it as a template in interface and fill the template when Implemented in sub class.
			
			- variables are final and static 
			- functions ar abstract declared without body.
			- we can not make a instance for an interface 
				but we can create a references 
				
					GenericLivingCreatureInterface g = new Human(); --------------- possible , IF Human is a super class.
					Human h = new GenericLivingCreatureInterface();  --------------not possible 
			- we can multiple inheritance by multiple implements of interface 
			
			#IMP# : Imagine one interface is implemented in 1000 classes , adding a one more function in interface will break all 1000 classe 
				to overcome this we have default function in which we can add the function body in interface itself 
					
					default void check(){
						System.out.println("new function added");
					}
					
			- two interfaces have same fnction : how to call the functions then post implementation		
				
				code : Interfacename.super.functionname()
				
22. abstract classes : 
					- unlike interface , abstract classes can have functions with body . and withour body also .
					- even a one function in a class abstract then the clas is abstract
					- We extends these.
					
23. Encapsulation : - Hiding the back end functionality . Just like remote control , you can see the buttons to control .
					- Hiding can be done using the access modifiers .
					
					Steps to set the encapsulations : 
					- Private access modifier can be used to do that for all class instance variables.
					- then generate the getter and setter for them.
					- then go to places where we need the variable values using the getter and set the value usng setter.
					 setter : writting 
					 getter  : only readable 
					 
					------ in rest api or spring boot api , we don;t need to extends the bean class , we can import it and use it.

24. Polymorphism : 
				- One super class gots extends in two sub classes , overriding a functions of super class with two diff defination in two diff sub classes is polymorphism 
				- Runtime polymorphism: 
					   overriding a mthod rule : 
							name same 
							arguments match 
							body differ.
							Access level should not be highly hidden like private . Keep public 
							We can not override a method marked as final 
				
				- Compile time Method overrloading  :
						Rules :
							Keep the name same 
							change the arguments list 
							change the return type 
							change the acess modifier 
					
25. String classes  : from java.lang.string
				
				Keep this in mind
					- == operator if we apply on a reference objects it will tell if it is pointing to the same memory locations ?
					- equals functions will compare the string values . Always use equals/equalsIgnoreCase for string compare.
					- String objects are immutable means we can change the value but need to CHANGE THE REFERENCE VALUE.
						String str1 = "test ";
						str1 =str1.concat("jaav");
						sout(testjaav)
						
26. Stringbuffer and stringbuilder 	:  Strongest tool or classes to create string and can concatenate any data types value 
		stringBuilder.append("@@"); ----------------- the parameter can be int , float , double , short , string .
			
		These are not immutable classes , we can do as many chanes as we can.
		Its thread safe. It means only one thread can access the object one at a time . Will released by one thread and picked by other thread.
		
		  StringBuffer strb = new StringBuffer("Welcome to java ");
          strb.append("((");
          System.out.println(strb);

          StringBuilder stringBuilder = new StringBuilder("Welcome to java ");
          stringBuilder.append("@@");
          System.out.println(stringBuilder);

27. Exception handling : 

	Exception are sudden error occured in our program which may be a result of a file not found exception or stackoverflow exceptio , array index ot of bound exception etc 
	
	Types of exception : 
	  - checked exception : These are the exception which comes during compilation . The java compiler throws these exception during the compile time and does not allow a clean compile and will not create a .class(byte code) file for it.
	  - Unchecked Exceptions : Runtime exception. These exception comes at runtime due to unwanted code bug etc . in this case the .class  has already been generated but will break while running the code in JVM.
	  
	The order or hierarchy of thr exception really matters :
		Objects 
			|
		Exception
			|
	ioex  , clssnotfoundex , .... runtime exception 
										|
									Arithmetic exception , numberformt exception , null pointerexceptio  ....... more 
									
	so we have to add multipe catch block by checking our code .
		Exception class is capable of catching all exceptions .
		
								
      - Finally block : 	
				This block always run . this block comes at the end of the catch or try block . We mostly used this block to close all the open inputstream , db connections , flush the buffer etc . This will help in reducing the memory leak due to db connection s, network leak etc .
				
	  - propagating the unhandled exceptions  : means the exception occured upstream or backword if not catched , similar to what we do in IIB .
		
	  - Throw and throws : 
			Throw key word we can use to throw an exception like throw new NumberFormatException("Messge for it")
			Throws we can use to throw multiple exceptions from downstream method to upstream .
			
	  - Custom exception or user define : 
													 - create a class and								
													 - extends Exception class and write a constructor and pass the message attribite to super(message)
													 - use throw new MyExceptionClass("your message")
		Which exception is thrown when java is out of memory?
a) MemoryError
b) OutOfMemoryError
c) MemoryOutOfBoundsException
d) MemoryFullException

B : correct 											 
													 
28. Collections :  it can hold collections of objects 
					commaon function s: 
						sort ()
						remove()
						purge()
						add() etc 
		List : it will store the list of objects , arrayList ,  are extended implementation of list.
		Set : to store the unique values . Hashset is the extendable of set 
		Map : Key and value pair.  when we need object from list or collections we have to iterate the collections , but map we can just push the key and we can get the value out. quick and faster then collections  , hashmap  is the extendable of map .
		Queues : FIFO flavour. linkedList is extendable
		
	1. Before using a collections always thing about : 
			You need : 
				- sorted or unsorted 
				- ordered or unordered 
				- unique or duplicate value 
				
		- Collection is an ordered data set .
		- sorting order is used to sort the data . we can use Collections.sort()
			: But how to sort the collection if it contains the bean objects collections 
				ArrayList<Person> arraylist = new ArrayList<Person>();
					We have to tell the Collections how to sort  verrrrrrryyyyyyyyyyyyyyyyyyeasy 
			: go to your pojo class implements the Comparable<Person> and override the compareTo method 
					  @Override
					  public int compareTo(Person o) {

							return name.compareTo(o.name);
							}
	Important : ---------								

		a. Arrayalist : collection of objects and kind of works as a array but is dynamic and can increase size without declaring it in pre-requisite. Its index based insertions.
		
		b. LinkedList : Works in node structure .
						Single linkedlist : data|pointer(addressof next node)  ---------------> data|pointer(addressof next node)
						Double linkedlist : pointer(addressof previous node)|data|pointer(addressof next node)  ---------------> pointer(addressof previous node)|data|pointer(addressof next node).Its index based insertions.
						Faster then arraylist to delete and add the elements in list . we can use addfirst and addlist
						
		c. Vector : It is similar then arraylist , slower then array list and is thread safe means only one thread can access it one at a time.
			its synchronised and increase the size of the array to 100% if one more elements is added. Its index based insertions.
			
		d. Hashset : It will remove the duplicate elements and it is not index based data strucure . We know it will remove the duplicate in case of string objects , but how it will find duplicate in case of POJO java objects as a primitive passed in it 
			for exaple : Hashset<Person> newper = new Hashset<Person>();
				Q. Here we used person and want to remove the duplicacy how ?
				Ans. As  a dev first we have to find which attribute of person makes it duplicate . Same what we observed in Rule coding 
					for example we can use Id and name both to be part of duplicate check. 
					We have to override the equal and hashcode method of Object class which Person class extends by default . the default equals method says all person objects are Different .
					exmaple :  below two objects are different , if we do per1==per2 it will be false as it is point to a different memory space .
						Person per1 = new Person("beet","88277",9129);
						Person per2 = new Person("beet","88277",9129);
					
				IMP : Generate the hashcode and equals and  generating the hashcode and equals we could able to see the duplicate removed.
				
		e. Hashmap : its a key value pair data structure . its not index based insertion data str. Its faster then any other data strc we discusse .
		For large amount of data hashmap is used as look up of elements at different index is pretty easy , just pass the key and ollllaaaa we got it.
						
			Verry verry important : 
					How hashmap works internally  : 
					
				- hashmap works on the process called hashing .
				- hashing involves a hashcode function which generate the hashcode using the key we give while putting and that hashcode is the index value in the Hashmap bucket array that resides in memory .
				- Each array index of hashmap bucket contains a linkedList which holds the elements [key,value]|addresstonextnode 
				- When we do map.put("IN",indiabj);
				
				hashing will pick the IN key and push it to hashfunction and generate the hashcode (hashmap bucket array index) and stores the [key,value] at that index.
			
		Case 1 : inserting the data 
				example for IN ------> hashfunction() -----hashcode generated ----> 2
				
																													
							map.put("IN",indiaobj)								map.put("US",usobje)																
								|													|								
								|													|								
								IN													US																				
								|													|								
		hash fucntion () -- returns 2      									hashfunc() ---> returns 2
							
							
										
												map.put("GM",gmobje)
													|				
													|				
													GM				
													|				
											hashfunc() ---> returns 0
										
										
										
										
										
								Hasmap Bucket
							 ---------------------------------------------------	
							|Array							 					|					
							| 0 -->[GM,v]|pointer
							| 1                              					|	
							| 2 -->[IN,v]|pointer--->[US,v]|pointer     		|	
							| 3	                             					|	
							| 4                              					|	
							| 5                              					|	
                            | 6                              					|	
							| 7                              					|	                                                                            
							| 8                              					|	                                                                            
							| 9                              					|	                                                                            
							| 10                             					|																				
							|		                         					|																					
							 ---------------------------------------------------																							
		Case 2 : Getting the data 																											
		
											map.get("GM")
													|				
													|				
													GM				
													|				
											hashfunc() ---> returns 0
											
				It goes to the bucket at 0 index and using the equals functions will search the GM and retrun the value back.
																													
        Case 3  : what happen in case of th Person objects or pojo object saving then we can either add the hashcode fnction to override and equals method to override . But by default all classes extends the functiosn fro objects class.																														
																													
		f. Linkedhashset : 	Aswe saw the elements entered in hashset while retrieving it the elements are in different order.
			To remove that use Linkedhashset and ollla ||||.
		
		g.Treeset : We know we can use the Collections.sort to sort the collections , but when you push the data to treeSet it will automatically sort the data in ASCENDING ORDER and also removes the duplicates	 . this is one of best data structure for ascending ordered sorted and unique value holding technique.
		
		h. hashtable : are synchronised as hashmap is synchronised.
			It will not allow null for a key .hashtable.put(null,"kk"); /// null pointer exception will be thrown
		
		I. LinkedHashMap : The only difference is that it will maintain the order . and slower then hashmap.
		
		j. TreeMap : Its sorted , means sort acc to natural method. Similar to hashmap , but is sorted .Treemap it will sort the coll will not allow null on key
		
		K. queue collection :  Root interface and used by linkedList and Priorityqueue. dqueue to remove and add to insert .
		
		L. Priorityqueue : wil insert the data in sorted order .
		
29. Thread : Multithreading and multipe processing .

				Steps to create multi threaded env : 
					1. create  a class whih extends the Thread class  or implements the Runnable interface 
					2. Override the run method and implement the job .Run method can be invoked by crating object of the Thread class.

30. synchronised block and methods : This will help in multi threading architecture which will allow only one thread to  hold the method , variable or resource at a time .

			public synchronised void run(){   -----------> this will lock the method complete for on thread to complete 
			
			
			}
			
			synchronised(){ -------------------- this will allow use to lock a piece of code to get locked for one thread to complete and let go post that.
			}
			
			sleep()
			
			setPriority() --- to cheange the priority of thread Min_pri(1) , normal_pri(5) , max_pri (10)
			
			isAlive()----> to get if the thread is still alive 
			
			wait()-------->  this will make the thread to wait , but will not come alive untill we use notify method for it.
			
			yield ()-----> will give other thread the chance to run if other thread is taking more time
			
		- states of threads : 
				
				new ----->Runnablbe ------>Running ----------->Dead
							/\				|
							|				|
							|				\/
							|---Waiting/-----
									block 
									
31. Serialization : As we used this to convert the data to bytes to send across the network .
										As we used in kafka stream .
										
				We can serialized and deserialized at the target system .

			Remember when we serialized the data into byte stream in kafka produce stream and deserialize the data to readable in target ss
			
			Steps to do serialization : 
					- Create a class pojo class and implements it with Serializable .
					- In PSVM Create a fileoutputstream and filename in ti 
					- then create ObjectOutputStream object and pass the fileoutputstream obj
				    - ObjectOutputStream.writeObject(pojo);
					
			steps to do the deserialization : 
			- Create a class pojo class and implements it with Serializable .
					- In PSVM Create a fileintputstream and filename in ti 
					- then create ObjectinputStream object and pass the fileintputstream obj
				    - polo = ObjectOutputStream.readObjects();
					

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Java 8 session : ------------------------------------------------- 

** IMP : BUILD YOUR KNOWLEDGE ON THEFUNCTIONS INTRODUCED IN JAVA 8 AND USE THEM AS NEEDED.

1. coupe of features were added to java 8 : 
				a. lambda functions : functional programming 
				b. Immutability is added.
				c. Streams  : which include kafka streaming and all
				d. optional etc 
	
2. Imperitive an declarative programming 
	Imperitive proramming : focus on what we need to achieve and keeping that in mind we code for it.
							Object mutability is involved in this type of programming
							This is th eold approach as we were doing since the java existence 
							Here we need to focus on how the job is happening example : removing the duplicacy , summing up the value etc 
							
	(Java 8)Declarative proramming : Doesn't focus on what we need to achieve and keeping that in mind we code for it.
							 Object imutability is involved in this type of programming.
							 This is actually what it specifically points to java 8 programming.
							 Java 8 release lot of functions which do the jobs as part of the streams introduced.
							 Here we no need to worry about how the job is happening .
							
		Example : We can use stream in wide range and go further to use functions 

			like : list.stream().distinct().collects(Collections.toList());
				   Intstream.rangeClosed(0,100).sum() ----> rangeClosed() is just ike we give range in loop , these functions will do the iterationa and all in the back .
				   
3. Lambda 

Important point : Lambdafunctions are moslty used to provide defiintions to the functional interface (interfaces which contains only exact one abstract fuction ) and then using the interface object to call the overriden fucntion to use that.
syntax : ()					-> 					{}       
		 fn pramater 	   linked operator     fn body 
These are equivalent to the functions without function name
These are the anonymus funtions 
These expressions have all three features that a normal functions has 
	Method name
	Method body 
	Method Return type 
	
Lambdacan also be used to implemet Runnable(which is for multi threading ) and Comparator(compare two parameter of any types) interfaces.	
				
Q. What is a runnable interface ?
This is the interface which we implements in a class to allow multithreading to work .
Run method is declared in this interface with no body , no paramters and no return  types .
Java runnable is an interface used to execute code on a concurrent thread. It is an interface which is implemented by any class if we want that the instances of that class should be executed by a thread.

The lambda expresion target should be an interface.

Q. what is a comparator Interface ?
Comparator interface are the functional interface which has only one abstract function and is annotated as @FunctionalInterfaces. It contains a compare function which is used to compare any type of field values .


QQQ. Functional interfaces : 

Four initial functional interfaces are 
	Consumer 
	predicate 
	Function 
	Supplier.
	
1. Consumer Functional interface : java.util.function	
		Interface name : Consumer 
Consumer chain in foreach we can add one conaumr object and then do (dot) and get addThen() .

 We need to create a program with one student bean , one class that instantiate the student beans and then we will you another class which will use lambda expression to call consumer and apply flter and other stuff.
 
 Consumer chain is th etechnique in which we can add more consumer objects in line line c1.addThen(c2) where c1 and c2 are the cosumer objects

2.  BIconsumer functional interface : Just like the consumer accept method want one paramter , the Biconsumer accept two paramters so that two objects can be used to do the task .

interface name : Biconsumer 				


3. Predicate functional interface : It mostly contains the functions whic play arround the boolean values and resuts . 
	Function like : or , and , negate . test is the fn which accepts the paramter which is similar to accept function in consumer interfaces.
	interface name : Predicate  

code reusablity is the best benefit that is provided by the functional interfaces.

4. BiPredicate interface : 
	Interface name : Bipredicate  : similar to predicate and the only diff is the test function will receive two paramters and return type is same as boolean.
	contains  : or , and , nagate .
	This interface test function will help is adding multiple conditions required for the conditional logic to work .
	
	
QQQ Function - 

1. Functional Interface - part 1 : its a functional interface just like (consumer , predicate , Biconsumer ,and bi predicate) but with diff features.

interface name : Function.java 	 , functions available in this interface : addThen , compose and apply (input , output)

its like creating the implementation for each Function interface object and then use apply method to run it.

2. Bifuntional functional interface : Its just like the Function functional interface , the only difference is it takes two input parameter instead of one.
	interface name  : BiFunction  and it only have apply and addThen method .
	
NOte : --- operators functiona intefaces are used in case both the input and out are of same types 	
3. UnaryOpertor functional interface : this is the functional interface which extends Function functional	interface is used if the input and out both are of same data type .
		
4. Binaryoperator functional interface : this is the functional operator which extends the BiFunctionfunctional interface is used to take two input of same type and generate a output of same type

5. Supplier functional interface 
	interface name : Supplier 
	It is used to return something and it doesn't required any paramters .
	The syntax for lambda would be (no input params)->{}
	
QQQ  : Method references	

1. Method references are just a shortcut way to write lambda expressions 

syntax   : ClassName::Methodname
		   ClassInstance::Methodname
		   
		   
		 example : Function<String , String > function = (s)->s.toUpperCaseString(); --------------> this is lambda expression 
				   Functions<String , String > functions = String::toUpperCaseString(); -------------> method reference
				   
			There are some cases it is difficult to apply method reference .	   
2. So in nutshell in JAVA8 we can use classname::method references and get the work done 

if we have create a Class test and it has a method with input paramters or not . 

				We can use functional interface and then use th class Test::methodrefrences.
				
				But kepe in mind the functional interface that you will use either it is a Consumer , BiConsumer , Predicate , BiPredicate , Function , BiFunctional , UnaryOpertor or Binaryoperator . The right hand side function that you are refering must have same method decalaration .
				
				Means we know that if we use Function functional interface then you might be sending input paramters .

QQQ. Local variables and its scope in labmda expressions.

 two restrictions are there : 
		inside lambda expression we can use the local variable 
		We can not reset the value of a local vaoriable to a new value 
		We can use the instance variable where ever we can .
		
QQQ. Effectively final : It means we saw that the when we tried to change the value of a local variable inside the labmda expression we get compilation . This concept shows that the lambda expression treat local variable as effectively FINAL (whose value can not be changed.)		

	fn(){
	
	int value = 9
	Consumer<integer> c = (u) ->{
		value = 8; // this line will shows compilation error as lambda treat local variables as final .
		
	}
	}
	
QQQ. Stream Api 
	Streams api is used over the List , or collection of data , which can be Map , List , ArrayList , LinkedList and all other collections .
	There are two stream  to create using below.
		students.stream()
		students.parallelStream() -----------> this will run all the other task like filter , collects etc in parallel.
	Stream is nothing but a streamlined data of a collection on which we can do all the manipulations.	

1.How stream API works?

Example : 
StudentInstace.getstudents().stream() ------------------------------------> will create Stream<Students>
                .filter(p) ------------------------------------> will create Stream<Students> filtered
                .filter(p1)------------------------------------> will create Stream<Students> filtered
                .collect(Collectors.toMap(Students::getName,Students::getActivities));------------------------------------> will create Map<string , List<Activities>>
				
				
2.Difference between Collections 	and streams 

NOTE  : ANYTHING WHICH IS A LIST OR A COLLECTIONS (ARRAYLIS , HASHSET , TREEMAP , HASHMAP , LINKEDLIST , ARRAYS, LIST  ETC ) WE CAN CONVERT THOSE TO STREAM AND USE ALL THE STREAM API FUNCTION TO PLAY ARROUND

Collections : 
	Elements can be added or removed from the collections as required
	Elements can be access from any index
	It is eagrly constructed
	It can traversed N number of times 
	Iteration is done using external iteration technique. We use for loop explicitly to traverse the collections .
	
Streams : 
	Elemnets can not be added or removed from the stream . only the fiteration can be applied by adding he Predicate 
	Elements can be accessed only once 
	It is traversed only once using the streams 
	Iteration for stream happened using internal iteration / internal stream api function .
	
		
3.How to debug a stream operation applied to a collections ?

We can use peek () method and pass a consumer to peek() and print the single object of the stream 

4. map() method in stream api . is used to convert one type of stream to another 
 example 
 Set<String> collect = StudentInstace.getstudents().stream() // will give Stream<Students>
                .map(function1) // will give Stream<String>  so map is converting the Stream of students type to stream of string type 
                .collect(Collectors.toSet());

5 flatmap method in stream api : flatmap is similar to map function is applied to convert from one type to another .
And is applied to the stream in which each each element in the stream contains multiple elemenst 

exmaple : below are the two example stream 

	Stream <List> : This means each element in this stream contains List , List , List , List .....
	Stream<Arrays>: This emans each elements in this stream contains Array, Array, Array, Array, Array, ......
	
	
	Just like we had streams<String >
			It contains Str1 ,Str1 ,Str1 ,Str1 ,Str1 ,Str1 ,Str1 ,Str1 ,...
			
6. We have some more functions in streams api : distinct , sorted and count 

distinct : it will return the distinct value form the stream .
Count : will give you the count of the element in the stream 
sorted : will sort the elements in alphabetical order .			
		 
		 
We an use Sort function which except a parameter sort(comparator function fnctional interface)

	- using sort function we can sort by selecting any field value as a comparator and help in sorting the values .
	example : StudentInstace.getstudents().stream() /// stream function always pass the elements ONE BY ONE 
                .sorted(Comparator.comparing(Students::getName).reversed())   // this will print the students in revred order
                .collect(Collectors.toList());
		 
7. FIlter function which wants predicate functional interface that contains conditions to help filter out the elements		 
	EXAMPLE :  StudentInstace.getstudents().stream()
                .filter(students -> students.getMarks()>500)
                .filter(students -> students.getActivities().stream().count()>2)
                .collect(Collectors.toList());

8. reduce function of stream api . it is also a terminal function means the end operation . Collect is also a terminal operations.

This function si used in case we neeed to reduce the set of value to a single value that you are looking for. example a list of integeres to a a sum or to a single values.

Exmaple of map , filter and reduce 
StudentInstace.getstudents().stream() // Stream<Students>
                .filter(students -> students.getMarks()>300) // Stream<Students>
                .filter(students -> students.getActivities().stream().count()>2)// Stream<Students> with activities greater then 2
                .peek(student -> {
                    System.out.println("Post filter "+ student);
                })
                .map(Students::getNotebooks)// Will give Stream<Integers>
                .peek(notebooks -> {
                    System.out.println("Notebooks for each student "+ notebooks);
                })
                .reduce(0,(n1,n2)->n1+n2);
				
9. min, max operation  we can do using the method reference of Integer class like Integer::max(a,b) and Integer::min(a,b).
Always use reduce without default identity value

10. Limit() and Skip() fn of stream api .		

limit(3) --- > it means it will only send the first three elements from the stream to further process 
skip(3)----- > it means it will skip the firt three elements and send the rest of the elements to further process.

11. anymatch , nonmatch , allmatch stream api fn  return boolean 

all these three function wants predicate as a n input 

anyMatch () ---> will return true when any one of the elements matches the predicate 
Allmatch () --> will return true when all the elements from the streams matches the predicate .
nonmatch ()----> its opposite of allmatch it will return true when none of the elements matches the predicate and false it matches.
System.out.println(StudentInstace.getstudents().stream()
                .allMatch(students -> students.getMarks()>500));
        System.out.println(StudentInstace.getstudents().stream()
                .noneMatch(students -> students.getMarks()>500));
        System.out.println(StudentInstace.getstudents().stream()
                .anyMatch(students -> students.getMarks()>500));

12. findAny() and findFirst()

will find first elements from the stream 

13. Short circuiting : 	its the process in which a given function doesn't iterate through the whole stream to get the results .
So all the functions below doens't iterate through the stream to get the results 

limit 
allmatch
anymatch
noneMatch
findfirst 
findany

14. Stream api operations : 

of() - this funtion will help in creating the stream of values . The values can be infinite 
iterate()-  this function will iterate value to infinite values 
generate() - this function will also generate stream of infinite value and ask for a Supplier<> functional interface objects .


15. NumericStreams : 

	Name of the stream : IntStream . 
	Why we have to use IntStream ? 
	Because when ever we do any numeric operation like blow the unboxing from Interger to int is happening one by one which is an added steps.
	So thats we can use IntStream,LongStream directly to do the operations.
	
	example : 
	return IntStream
                .rangeClosed(1,6)
                .sum();

16. NumericStreams range functions : 
	IntStream.Range(1,50) --> This will range the integre from 1 to 49  , excluding 50.
	IntStream.RangeClosed(1,50)---> this will range the integer from 1 to 50 .
	
	We have 
	LongStream.Range(1,50) --> This will range the integre from 1 to 49  , excluding 50.
	LongStream.RangeClosed(1,50)---> this will range the integer from 1 to 50 .
	
	We don't have range and ranegclosed for doublestream
	
	IntStream.RangeClosed(1,50).asDoubleStream().foreach(sout(i))
	
Note : WE CAN ITERATE THE STREAM ONLY ONCE , OR ELSE IT WILL CREATE AN EXCEPTION.	
	

		A. Different aggregate function used along with range functions 
		sum(),min(),max() and average()
		
		example : 
		System.out.println("Int Range closed sum : "+IntStream.rangeClosed(1,50).sum());
						System.out.println("Int Range sum : "+IntStream.range(1,50).sum());
						System.out.println("Long Range closed sum : "+LongStream.rangeClosed(1,50).sum());
						System.out.println("Long Range sum : "+LongStream.range(1,50).sum());
						System.out.println("Double Range closed sum : "+ IntStream.rangeClosed(1,50).asDoubleStream().sum());
						System.out.println("Double Range  sum : "+ IntStream.range(1,50).asDoubleStream().sum());
						OptionalInt min = IntStream.rangeClosed(1, 50).min();
				if(min.isPresent()){
					System.out.println(min.getAsInt());
				}else{
					System.out.println("No range is there");
				}
				OptionalInt max = IntStream.rangeClosed(0, 0).max();
				if(max.isPresent()){
					System.out.println(max.getAsInt());
				}else{
					System.out.println("No range is there");
				}	
				
		B. boxing and unboxing : 
		Unboxing  : its represents the unwrapping of data type from wrapper class(Integer , Double , Character , Boolean etc ) to premitive types(int , long , double etc ).		
		Boxing  : its represents the wrapping of premitive types(int , long , double etc ) to wrapper class(Integer , Double , Character , Boolean etc ).
		
		
		C. Some more NumericStream function : mapToObj , mapToLong , mapToDouble
			mapToObj : is used to convert intstream to any object . we can use customize class also for the conversion . Matlab kissi  bhi class ke constructor ko cal krke value pass kro and create an  object from it.
			
			mapToLong : this will convert the instream to long stream 
			
			mapTodouble : this will convert the instream to double stream 
			
17. Terminal functions : which is used to collect the end elemenst post all operations in a stream .
		exmaple of terminal functions : 
			max() , min() , sum () , reduce() , average() , collects () etc 
			
	Main focus on collect method () .
		collect(Collector class objects and a function call (joining , ToList etc ))

			- joining() which will concatenate all the elements 
			  joining (delimiter , preffix , suffix)
			 
			- counting() this will give the number of elements collected in the last collect fn.
			
			- mapping() this fn will apply the transformation first and then collects the data in a collecition (could be on ay type .)
				In this fun we can do the transformation as one parameter and collect in another paramater of the fn.
				
			- maxBy and minBy fn needs a comparator onbject and that comparator fn will need the function functional interface object (like a condition to use for )
			
			- averagingInt() and summingInt() . These two Collectors(dot) funtions will help is summing up and calculating average of the lements in the streams
				These fn will reduce one step or LOC .
					earlier approach  : We create stream , then map , then sum or average .
					now approiach  : we create stream , then collects(Collectors(dot)summingInt() or averagingInt)
			
			- groupingBy () : this function will help in grouping the data on a basis of the paramater we give as an input. 
								This fun will always return Map<k,V> . 
					
		